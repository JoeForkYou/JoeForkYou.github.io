<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nRF52832开发环境的搭建</title>
      <link href="/2025/03/06/nodic/%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/03/06/nodic/%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>由于工作的原因，需要搭建这个相关的开发环境，于是边写边做呗</p>]]></content>
      
      
      <categories>
          
          <category> nodic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【水果】【水果营养成分速查】</title>
      <link href="/2024/12/29/%E6%A4%8D%E7%89%A9/%E6%B0%B4%E6%9E%9C/"/>
      <url>/2024/12/29/%E6%A4%8D%E7%89%A9/%E6%B0%B4%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="热量"><a href="#热量" class="headerlink" title="热量"></a>热量</h1><h2 id="热量有三大来源"><a href="#热量有三大来源" class="headerlink" title="热量有三大来源"></a>热量有三大来源</h2><p>  热量，即食物中含有的能量，主要来源于食物中的三大营养物质:碳水化合物,脂类，蛋白质</p><ul><li>碳水化合物:主要是碳水化合物，如水果、蔬菜、肉类、蛋类等。</li><li>脂类:主要是脂肪、胆固醇、维生素等。</li><li>蛋白质:主要是蛋白质，如蔬菜蛋白、肉蛋白、蛋黄等。</li></ul><h2 id="热量是人类生命活动的基础"><a href="#热量是人类生命活动的基础" class="headerlink" title="热量是人类生命活动的基础"></a>热量是人类生命活动的基础</h2><p>  热量是人类生命活动的基础，是人体赖以存活的能量。<br>  富含热量的水果:</p><ol><li><strong>香蕉</strong>：香蕉富含碳水化合物，尤其是天然糖分，能够快速提供能量。</li><li><strong>牛油果</strong>：牛油果含有丰富的健康脂肪，尤其是单不饱和脂肪酸，热量较高。</li><li><strong>椰子</strong>：椰子的果肉和椰子油都含有较高的脂肪，热量丰富。</li><li><strong>榴莲</strong>：榴莲被称为“水果之王”，含有较高的碳水化合物和脂肪，热量非常高。</li><li><strong>枣</strong>：枣类水果如红枣、椰枣等，含有丰富的天然糖分，热量较高。</li><li><strong>葡萄</strong>：葡萄尤其是葡萄干，含有较高的糖分，能够提供较多的能量。</li><li><strong>芒果</strong>：芒果含有丰富的碳水化合物和天然糖分，热量较高。</li><li><strong>柠檬</strong>：柠檬含有丰富的碳水化合物和脂肪酸，热量较高。</li></ol><p>这些水果在日常饮食中可以作为能量补充的来源，但也要注意适量摄入，避免过量导致热量过剩。</p><h1 id="蛋白质"><a href="#蛋白质" class="headerlink" title="蛋白质"></a>蛋白质</h1><h2 id="蛋白质的作用"><a href="#蛋白质的作用" class="headerlink" title="蛋白质的作用"></a>蛋白质的作用</h2><p>蛋白质是人体必需的营养物质，它能够帮助人体进行代谢、组织形成、免疫调节、免疫功能、免疫诱导等功能。</p><ol><li><strong>牛油果</strong>：每100克牛油果约含2克蛋白质，同时还富含健康脂肪。</li><li><strong>番石榴</strong>：每100克番石榴约含2.6克蛋白质，是水果中蛋白质含量较高的选择。</li><li><strong>黑莓</strong>：每100克黑莓约含1.4克蛋白质，同时富含纤维和抗氧化剂。</li><li><strong>猕猴桃</strong>：每100克猕猴桃约含1.1克蛋白质，还含有丰富的维生素C。</li><li><strong>杏子</strong>：每100克杏子约含1.4克蛋白质，尤其是干杏的蛋白质含量更高。</li></ol><p>虽然这些水果的蛋白质含量相对较高，但若想补充蛋白质，仍需依赖豆类、坚果、肉类、鱼类和乳制品等更丰富的蛋白质来源。</p><h1 id="脂肪"><a href="#脂肪" class="headerlink" title="脂肪"></a>脂肪</h1><p>脂肪中的热量是蛋白质的2倍多<br>脂肪的主要作用是存储能量，并为人体提供必要的营养素。</p><ol><li><p><strong>牛油果（鳄梨）</strong><br>牛油果是脂肪含量最高的水果之一，富含健康的不饱和脂肪酸，尤其是单不饱和脂肪酸，对心脏健康有益。</p></li><li><p><strong>椰子</strong><br>椰子肉和椰子油中含有较高的饱和脂肪，但同时也富含中链脂肪酸，易于消化和吸收。</p></li><li><p><strong>橄榄</strong><br>橄榄（尤其是橄榄油）富含单不饱和脂肪酸，是地中海饮食的重要组成部分。</p></li><li><p><strong>榴莲</strong><br>榴莲虽然以高热量著称，但其脂肪含量也相对较高，同时富含多种营养素。</p></li></ol><p>这些水果虽然脂肪含量较高，但大多含有健康的脂肪酸，适量食用对身体有益。</p><h1 id="碳水化合物"><a href="#碳水化合物" class="headerlink" title="碳水化合物"></a>碳水化合物</h1><p>碳水化合物是能量的供应源.<br>碳水化合物是构成细胞的主要成分。<br>富含碳水化合物的水果:</p><ol><li><p><strong>香蕉</strong>：香蕉是碳水化合物含量较高的水果之一，尤其是成熟的香蕉，含有较多的天然糖分。</p></li><li><p><strong>葡萄</strong>：葡萄中的碳水化合物主要来自葡萄糖和果糖，尤其是干葡萄（葡萄干）的碳水化合物含量更高。</p></li><li><p><strong>芒果</strong>：芒果不仅富含维生素和矿物质，碳水化合物含量也较高。</p></li><li><p><strong>无花果</strong>：无花果的碳水化合物含量较高，尤其是干无花果。</p></li><li><p><strong>枣</strong>：枣类水果（如红枣、椰枣）的碳水化合物含量非常高，尤其是干枣。</p></li><li><p><strong>菠萝</strong>：菠萝含有较多的碳水化合物，尤其是其天然糖分。</p></li><li><p><strong>苹果</strong>：苹果的碳水化合物含量适中，尤其是甜度较高的品种。</p></li><li><p><strong>梨</strong>：梨的碳水化合物含量也较高，尤其是成熟的梨。</p></li><li><p><strong>柿子</strong>：柿子的碳水化合物含量较高，尤其是甜柿。</p></li><li><p><strong>榴莲</strong>：榴莲不仅热量高，碳水化合物含量也较高。</p></li></ol><p>这些水果虽然富含碳水化合物，但同时也含有丰富的维生素、矿物质和膳食纤维，适量食用对健康有益。不过，对于需要控制碳水化合物摄入的人群（如糖尿病患者），应注意适量食用。</p><h1 id="膳食纤维"><a href="#膳食纤维" class="headerlink" title="膳食纤维"></a>膳食纤维</h1><p>膳食纤维对人体健康至关重要，它有助于维持肠道健康、降低胆固醇水平、控制体重等。<br>富含膳食纤维的水果:</p><ol><li><strong>牛油果</strong>：虽然牛油果含有较高的脂肪和热量，但其膳食纤维含量也很高，尤其是未成熟的绿色部分。</li><li><strong>番石榴</strong>：番石榴是一种热带水果，其皮和果实都富含膳食纤维。</li><li><strong>黑莓</strong>：黑莓不仅含有丰富的维生素C和抗氧化剂，还富含膳食纤维。</li><li><strong>梨</strong>：梨的果肉中含有较多的膳食纤维，特别是成熟的梨。</li><li><strong>苹果</strong>：苹果是膳食纤维的良好来源，尤其是带皮的苹果。</li><li><strong>无花果</strong>：无花果的膳食纤维含量较高，尤其是干无花果。</li><li><strong>枣</strong>：枣类水果（如红枣）的膳食纤维含量也相对较高。</li><li><strong>菠萝</strong>：菠萝的果肉中含有一部分的膳食纤维。</li><li><strong>芒果</strong>：芒果的果肉中也含有一定的膳食纤维。</li></ol><p>这些水果在提供丰富营养的同时，也能帮助增加膳食纤维的摄入量，对维护肠道健康非常有益。不过，对于需要控制膳食纤维摄入的人群（如高血脂患者），应注意适量食用。</p><h1 id="维生素A"><a href="#维生素A" class="headerlink" title="维生素A"></a>维生素A</h1><p>维生素A对人体健康至关重要，它有助于维持皮肤和眼睛的健康。<br>富含维生素A的水果:<br>富含维生素A的水果包括：</p><ol><li><strong>芒果</strong>：芒果是维生素A的丰富来源，尤其是成熟的芒果。</li><li><strong>哈密瓜</strong>：哈密瓜含有大量的维生素A，对眼睛健康特别有益。</li><li><strong>杏</strong>：杏子不仅美味，还富含维生素A。</li><li><strong>木瓜</strong>：木瓜中的维生素A含量较高，有助于皮肤和眼睛健康。</li><li><strong>柿子</strong>：柿子也是维生素A的良好来源，尤其是成熟的柿子。</li></ol><p>这些水果不仅美味，还能帮助补充维生素A，对维持皮肤和眼睛健康非常有益。</p><h1 id="胡萝卜素"><a href="#胡萝卜素" class="headerlink" title="胡萝卜素"></a>胡萝卜素</h1><p>富含胡萝卜素的水果包括：</p><ol><li><strong>芒果</strong>：芒果不仅富含维生素A，还含有丰富的胡萝卜素，有助于保护视力和皮肤健康。</li><li><strong>哈密瓜</strong>：哈密瓜中的胡萝卜素含量较高，对眼睛和免疫系统有益。</li><li><strong>杏</strong>：杏子中的胡萝卜素有助于维持皮肤和眼睛的健康。</li><li><strong>木瓜</strong>：木瓜不仅含有维生素A，还富含胡萝卜素，对皮肤和眼睛健康有显著效果。</li><li><strong>柿子</strong>：柿子中的胡萝卜素含量丰富，有助于增强免疫力和保护视力。</li></ol><p>这些水果不仅美味，还能帮助补充胡萝卜素，对维持皮肤和眼睛健康非常有益。</p><h1 id="维生素B1"><a href="#维生素B1" class="headerlink" title="维生素B1"></a>维生素B1</h1><p>维生素B1对人体健康至关重要，它有助于维持骨骼健康、抗氧化作用、抗癌作用。<br>富含维生素B1的水果:</p><ol><li><strong>橙子</strong>：橙子不仅富含维生素C，还含有一定量的维生素B1，有助于维持神经系统健康。</li><li><strong>香蕉</strong>：香蕉是维生素B1的良好来源，有助于能量代谢和神经系统功能。</li><li><strong>菠萝</strong>：菠萝中含有维生素B1，有助于消化和免疫系统的健康。</li><li><strong>草莓</strong>：草莓不仅美味，还含有维生素B1，有助于维持心脏和神经系统的健康。</li><li><strong>猕猴桃</strong>：猕猴桃富含维生素B1，有助于提高免疫力和促进新陈代谢。</li></ol><p>这些水果不仅美味，还能帮助补充维生素B1，对维持身体健康非常有益。</p><h1 id="维生素B2"><a href="#维生素B2" class="headerlink" title="维生素B2"></a>维生素B2</h1><p> 维生素B2对人体健康至关重要，它有助于维持骨骼健康、抗氧化作用、抗癌作用。<br> 富含维生素B2的水果:<br> 富含维生素B2的水果包括：</p><ol><li><strong>鳄梨（牛油果）</strong>：鳄梨不仅富含健康脂肪，还含有丰富的维生素B2，有助于维持皮肤和眼睛健康。</li><li><strong>香蕉</strong>：香蕉除了是维生素B1的良好来源外，也含有一定量的维生素B2，有助于能量代谢和细胞功能。</li><li><strong>猕猴桃</strong>：猕猴桃不仅富含维生素C和B1，还含有维生素B2，有助于提高免疫力和促进新陈代谢。</li><li><strong>草莓</strong>：草莓不仅美味，还含有维生素B2，有助于维持皮肤和眼睛健康。</li><li><strong>橙子</strong>：橙子不仅富含维生素C，还含有一定量的维生素B2，有助于维持皮肤和眼睛健康。</li></ol><p>这些水果不仅美味，还能帮助补充维生素B2，对维持身体健康非常有益。</p><p>水果主要是上述的一些营养成分，还有一些烟酸，维生素c,钙的以后再去做整理。</p>]]></content>
      
      
      <categories>
          
          <category> 植物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 植物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串相等</title>
      <link href="/2024/12/15/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
      <url>/2024/12/15/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>在C和C++中判断字符串是否相等的方法有所不同。</p><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p>在C语言中，字符串是以字符数组的形式存储的，比较字符串是否相等通常使用 <code>strcmp</code> 函数。该函数在 <code>&lt;string.h&gt;</code> 头文件中声明。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串相等\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串不相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h1><p>在C++中，可以使用标准库中的 <code>std::string</code> 类来处理字符串，这提供了更方便和直观的方法来比较字符串。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在C中使用 <code>strcmp</code> 函数比较字符串。</li><li>在C++中可以直接使用 <code>==</code> 运算符比较 <code>std::string</code> 对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidBp</title>
      <link href="/2024/12/15/Android/AndroidBp/"/>
      <url>/2024/12/15/Android/AndroidBp/</url>
      
        <content type="html"><![CDATA[<p>Android.bp 是 Android Build System 中使用的一种构建描述文件格式，类似于 Makefile，但以更简洁的方式定义构建模块。以下是一个基本的 Android.bp 文件示例，展示了其基本语法和用法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个库模块</span><br><span class="line">cc_library &#123;</span><br><span class="line">    name: &quot;my_library&quot;,  # 模块名称</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;file1.cpp&quot;,      # 源文件</span><br><span class="line">        &quot;file2.cpp&quot;,</span><br><span class="line">    ],</span><br><span class="line">    cflags: [            # 编译选项</span><br><span class="line">        &quot;-Wall&quot;,</span><br><span class="line">        &quot;-Werror&quot;,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [      # 依赖的共享库</span><br><span class="line">        &quot;liblog&quot;,       # 依赖的库名称</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义一个可执行程序模块</span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;my_executable&quot;,  # 执行文件名称</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;main.cpp&quot;,           # 主源文件</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [</span><br><span class="line">        &quot;my_library&quot;,        # 依赖的静态库</span><br><span class="line">    ],</span><br><span class="line">    cflags: [</span><br><span class="line">        &quot;-O2&quot;,               # 优化选项</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义一个测试模块</span><br><span class="line">cc_test &#123;</span><br><span class="line">    name: &quot;my_library_test&quot;,  # 测试模块名称</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;my_library_test.cpp&quot;,  # 测试源文件</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [</span><br><span class="line">        &quot;my_library&quot;,           # 被测试的库</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ol><li><strong>模块类型</strong>：可以定义多种类型的模块，比如 <code>cc_library</code>（C++库），<code>cc_binary</code>（可执行程序），<code>cc_test</code>（测试）等。</li><li><strong>name</strong>：每个模块都有一个唯一的名称。</li><li><strong>srcs</strong>：指定源文件列表，可以是相对路径。</li><li><strong>cflags</strong>：编译标志，用于设置编译时的选项。</li><li><strong>shared_libs&#x2F;static_libs</strong>：分别指定依赖的共享库和静态库。</li></ol><p>了解这些基本组件后，你可以根据自己的项目需求，进一步扩展和修改 Android.bp 文件。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP生成so</title>
      <link href="/2024/12/14/CPP/CPP%E7%94%9F%E6%88%90so/"/>
      <url>/2024/12/14/CPP/CPP%E7%94%9F%E6%88%90so/</url>
      
        <content type="html"><![CDATA[<p>在C++中生成共享库（.so文件）并使用它，涉及到以下几个步骤。假设我们要创建一个简单的共享库并在一个主程序中调用它。</p><h1 id="1-创建共享库"><a href="#1-创建共享库" class="headerlink" title="1: 创建共享库"></a>1: 创建共享库</h1><ol><li><strong>创建头文件</strong>（例如 <code>example.h</code>）:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建实现文件</strong>（例如 <code>example.cpp</code>）:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>编译生成共享库</strong>:</li></ol><p>使用以下命令编译 <code>example.cpp</code> 为共享库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared example.cpp -o libexample.so</span><br></pre></td></tr></table></figure><ul><li><code>-fPIC</code> 表示生成位置无关代码（Position Independent Code），适合共享库。</li><li><code>-shared</code> 指定生成共享库。</li></ul><h1 id="2-使用共享库"><a href="#2-使用共享库" class="headerlink" title="2: 使用共享库"></a>2: 使用共享库</h1><ol><li><strong>创建主程序文件</strong>（例如 <code>main.cpp</code>）:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>编译并链接共享库</strong>:</li></ol><p>使用以下命令编译 <code>main.cpp</code> 并链接到生成的共享库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -L. -lexample -o main</span><br></pre></td></tr></table></figure><ul><li><code>-L.</code> 指定当前目录为查找库的目录。</li><li><code>-lexample</code> 指定链接名为 <code>libexample.so</code> 的库（省略 <code>lib</code> 和 <code>.so</code>）。</li></ul><ol start="3"><li><strong>运行程序</strong>:</li></ol><p>在运行时，可能需要设置 <code>LD_LIBRARY_PATH</code> 环境变量，以便程序能够找到共享库。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，你可以成功创建并使用一个简单的共享库。在实际应用中，可能会有更多的复杂性，比如处理多个源文件，或者使用构建工具（如 CMake）来管理构建流程。希望这个示例对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串包含</title>
      <link href="/2024/12/14/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB/"/>
      <url>/2024/12/14/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<p>在实际项目应用中我们经常要去做一些字符相关的判断.<br>比较常用的是判断字符串是否包含另外一个字符串的内容<br>在cpp中有不少可以直接拿来使用的<br>直接添加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后写个判断的函数即可如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">const</span> std::string&amp; substr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">find</span>(substr) != std::string::npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是判断str是否包含substr,如果包含则返回true,否则返回false.<br>完整的使用demo如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">const</span> std::string&amp; substr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">find</span>(substr) != std::string::npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::string substr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contains</span>(str, substr)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串包含子字符串&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串不包含子字符串&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c中我们没有这些类的概念，可以参考如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(str, substr) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* substr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contains</span>(str, substr)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串包含子字符串\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串不包含子字符串\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CPP基础】【四】【申请释放】</title>
      <link href="/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_4_%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE/"/>
      <url>/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_4_%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>在C++中，<code>new</code>和<code>delete</code>是用于动态内存分配和释放的运算符。它们与堆内存相关，允许程序在运行时分配和管理内存。</p><h1 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h1><p><code>new</code>运算符用于在堆上分配内存。它可以用于分配单个对象或对象数组，并返回指向所分配内存的指针。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol><li><p><strong>分配单个对象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure><p>这行代码在堆上分配一个<code>MyClass</code>对象，并调用其构造函数。返回值是指向这个对象的指针。</p></li><li><p><strong>分配数组：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这里在堆上分配了一个包含10个整数的数组，返回指向数组首元素的指针。</p></li><li><p><strong>初始化：</strong><br><code>new</code>还可以用来初始化对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); <span class="comment">// 分配内存并将其初始化为5</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="delete-运算符"><a href="#delete-运算符" class="headerlink" title="delete 运算符"></a>delete 运算符</h1><p><code>delete</code>运算符用于释放之前使用<code>new</code>分配的内存。它可以释放单个对象或对象数组。</p><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><ol><li><p><strong>释放单个对象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj;</span><br></pre></td></tr></table></figure><p>这行代码会调用<code>obj</code>指向的对象的析构函数，并释放该对象占用的内存。</p></li><li><p><strong>释放数组：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure><p>这里使用<code>delete[]</code>来释放使用<code>new[]</code>分配的数组。需要注意，使用<code>delete[]</code>和<code>delete</code>不可以互换。</p></li></ol><h2 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h2><p>在释放内存后，将指针设置为<code>nullptr</code>是一个良好的编程习惯。这可以防止悬挂指针问题，即指针仍然指向已经被释放的内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p><strong>配对使用：</strong> 每个由<code>new</code>分配的内存都应该用<code>delete</code>释放，每个<code>new[]</code>分配的数组都应该用<code>delete[]</code>释放，以避免内存泄漏。</p></li><li><p><strong>避免重复释放：</strong> 在释放指针后，应该清楚指针的状态，避免重复释放同一内存区域。</p></li><li><p><strong>自定义析构函数：</strong> 如果类中有动态内存分配的成员，确保在类的析构函数中适当释放这些资源，避免内存泄漏。</p></li></ol><p>通过正确使用<code>new</code>和<code>delete</code>，可以有效地管理C++程序中的动态内存。<br>详细demo代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">/* 构造函数代码 */</span> &#125;</span><br><span class="line">    <span class="comment">// 如果需要，可以添加析构函数、其他成员函数和数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;        <span class="comment">// 为一个整数分配内存</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];    <span class="comment">// 为一个整数数组分配内存</span></span><br><span class="line"></span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();  <span class="comment">// 调用构造函数</span></span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptr;    <span class="comment">// 释放单个对象 这边释放后ptr指向的内存区域将被释放，,详细debug看ptr指向的值以及变成其他值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr;  <span class="comment">// 释放数组</span></span><br><span class="line">    ptr = <span class="literal">nullptr</span>; <span class="comment">// 防止悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果MyClass有自定义的析构函数，也应该在此处释放obj</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    obj = <span class="literal">nullptr</span>; <span class="comment">// 防止悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串常见操作</title>
      <link href="/2024/11/24/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/11/24/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="常用字符串操作函数"><a href="#常用字符串操作函数" class="headerlink" title="常用字符串操作函数"></a>常用字符串操作函数</h1><ol><li><p>**<code>strcpy</code>**：用于将源字符串复制到目标字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(dest, src);  <span class="comment">// dest 现在包含 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strncpy</code>**：用于复制指定长度的源字符串到目标字符串，防止缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="number">5</span>);  <span class="comment">// dest 现在包含 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strlen</code>**：用于计算字符串的长度（不包括终止字符 <code>\0</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> length = <span class="built_in">strlen</span>(str);  <span class="comment">// length 现在是 5</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strcat</code>**：用于将源字符串连接到目标字符串的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(dest, src);  <span class="comment">// dest 现在包含 &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strncat</code>**：用于将指定长度的源字符串连接到目标字符串的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strncat</span>(dest, src, <span class="number">3</span>);  <span class="comment">// dest 现在包含 &quot;Hello Wo&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strcmp</code>**：用于比较两个字符串。如果相等返回0，如果第一个字符串小于第二个字符串返回负数，大于返回正数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(str1, str2);  <span class="comment">// result 为 0</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strncmp</code>**：用于比较指定长度的两个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;abcdx&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strncmp</span>(str1, str2, <span class="number">4</span>);  <span class="comment">// result 为 0 (前4个字符相等)</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strchr</code>**：用于查找字符在字符串中第一次出现的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;e&#x27;</span>);  <span class="comment">// ptr 指向 &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strstr</code>**：用于查找一个字符串在另一个字符串中首次出现的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> haystack[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> needle[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr = <span class="built_in">strstr</span>(haystack, needle);  <span class="comment">// ptr 指向 &quot;World!&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些函数是处理C语言字符串时非常有用的工具，掌握它们可以让你的字符串操作更加得心应手。注意在使用这些函数时，要确保目标字符数组够大，以防止发生缓冲区溢出。</p><h1 id="字符串相等判断"><a href="#字符串相等判断" class="headerlink" title="字符串相等判断"></a>字符串相等判断</h1><p>在C++中，判断字符串相等一般使用 <code>std::string</code> 类的 <code>==</code> 运算符或者 <code>compare</code> 方法。以下是这两种方法的示例：</p><ol><li><p><strong>使用 <code>==</code> 运算符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str3 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str3) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>compare</code> 方法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str3 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str<span class="number">1.</span><span class="built_in">compare</span>(str2) == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str<span class="number">1.</span><span class="built_in">compare</span>(str3) == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在这两种方法中，使用 <code>==</code> 运算符更为简洁和直观，因此在日常编程中更为常用。 <code>compare</code> 方法则提供了更丰富的比较功能，例如可以用于比较字符串的部分内容和不同的比较规则。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidMk基础</title>
      <link href="/2024/11/24/Android/AndroidMk%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/24/Android/AndroidMk%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Android.mk 文件是 Android 系统中用于描述构建过程的文件，主要用在 Android NDK（Native Development Kit）中。它们是用来定义模块的构建规则和依赖关系。以下是 Android.mk 文件的基础和常用语法：</p><h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><ol><li><p><strong>变量定义</strong>：</p><ul><li>可以使用 <code>:=</code>、<code>+=</code> 等方式定义变量。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>模块类型</strong>：</p><ul><li>使用 <code>LOCAL_MODULE</code> 来指定模块名称。</li><li>使用 <code>include</code> 来包含其他 mk 文件。</li></ul></li><li><p><strong>模块的属性</strong>：</p><ul><li><code>LOCAL_SRC_FILES</code>：指定源文件。</li><li><code>LOCAL_C_INCLUDES</code>：指定 C&#x2F;C++ 头文件的搜索路径。</li><li><code>LOCAL_LDLIBS</code>：链接时需要的库。</li></ul></li></ol><h1 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h1><ol><li><p><strong>定义静态库</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := my_static_lib</span><br><span class="line">LOCAL_SRC_FILES := my_static_lib.cpp</span><br><span class="line">LOCAL_C_INCLUDES := <span class="variable">$(LOCAL_PATH)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义动态库</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := my_shared_lib</span><br><span class="line">LOCAL_SRC_FILES := my_shared_lib.cpp</span><br><span class="line">LOCAL_LDLIBS := -llog</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义可执行文件</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := my_executable</span><br><span class="line">LOCAL_SRC_FILES := main.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>清理变量</strong>：</p><ul><li>使用 <code>include $(CLEAR_VARS)</code> 可以清除之前定义的变量，避免冲突。</li></ul></li><li><p><strong>依赖关系</strong>：</p><ul><li>可以使用 <code>LOCAL_WHOLE_STATIC_LIBRARIES</code> 来定义静态库的依赖。</li></ul></li></ol><h1 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h1><ul><li><p><strong>链接库</strong>：</p><ul><li><code>LOCAL_LDLIBS</code> 用于定义需要链接的库，例如 <code>-lc</code>、<code>-lm</code>等。</li></ul></li><li><p><strong>编译选项</strong>：</p><ul><li>还可以使用 <code>LOCAL_CPPFLAGS</code> 和 <code>LOCAL_CFLAGS</code> 来添加编译选项。</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android.mk 文件通过模块定义和构建规则来构建 C&#x2F;C++ 代码。在编写文件时，需要注意规范和模块间的依赖关系。随着 Android 的发展，渐渐地 CMake 也被广泛使用作为构建系统，但 Android.mk 仍然是一个重要的部分，特别是在 NDK 项目中。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CPP基础】【三】【继承多态封装】</title>
      <link href="/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_3_%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%B0%81%E8%A3%85/"/>
      <url>/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_3_%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>在C++中，继承、多态和封装是面向对象编程的三大基本特性。下面我将分别介绍这三者，并给出相应的示例。</p><h1 id="1-封装（Encapsulation）"><a href="#1-封装（Encapsulation）" class="headerlink" title="1. 封装（Encapsulation）"></a>1. 封装（Encapsulation）</h1><p>封装是指将数据（成员变量）和操作数据的方法（成员函数）放在一起，形成一个类，通过访问控制来限制对类内部数据的直接访问，从而保护数据的完整性。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> balance; <span class="comment">// 私有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">double</span> initialBalance) &#123;</span><br><span class="line">        balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BankAccount <span class="title">account</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    account.<span class="built_in">deposit</span>(<span class="number">500</span>);</span><br><span class="line">    account.<span class="built_in">withdraw</span>(<span class="number">200</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前余额: &quot;</span> &lt;&lt; account.<span class="built_in">getBalance</span>() &lt;&lt; endl; <span class="comment">// 输出: 当前余额: 1300</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-继承（Inheritance）"><a href="#2-继承（Inheritance）" class="headerlink" title="2. 继承（Inheritance）"></a>2. 继承（Inheritance）</h1><p>继承是指一个类可以从另一个类中继承成员变量和方法，从而实现代码的重用。子类（派生类）可以扩展或重写父类（基类）的行为。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物发声&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">// Dog类继承自Animal类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写父类的方法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal animal;</span><br><span class="line">    animal.<span class="built_in">speak</span>(); <span class="comment">// 输出: 动物发声</span></span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.<span class="built_in">speak</span>(); <span class="comment">// 输出: 汪汪</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-多态（Polymorphism）"><a href="#3-多态（Polymorphism）" class="headerlink" title="3. 多态（Polymorphism）"></a>3. 多态（Polymorphism）</h1><p>多态是指同一个操作可以作用于不同的对象上，不同的对象可以根据其具体类型表现出不同的行为。C++中的多态通常通过虚函数实现。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制形状&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写父类的虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制圆形&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写父类的虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制正方形&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(Shape* shape)</span> </span>&#123; <span class="comment">// 接受基类指针</span></span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(&amp;circle); <span class="comment">// 输出: 绘制圆形</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;square); <span class="comment">// 输出: 绘制正方形</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>封装通过访问控制保护数据，提供了安全性。</li><li>继承实现了代码的复用，允许子类扩展父类的功能。</li><li>多态让程序更加灵活，同一操作可以作用于多个类型，增强了代码的可扩展性和可维护性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel加时间戳</title>
      <link href="/2024/11/18/Android/Kernel%E5%8A%A0%E6%97%B6%E9%97%B4%E6%88%B3/"/>
      <url>/2024/11/18/Android/Kernel%E5%8A%A0%E6%97%B6%E9%97%B4%E6%88%B3/</url>
      
        <content type="html"><![CDATA[<hr><p>添加对应的头文件和包装函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ktime.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">thermal_get_current_time_ms</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec64</span> t;</span><br><span class="line">    <span class="built_in">ktime_get_ts64</span>(&amp;t);</span><br><span class="line">    temp = (((<span class="type">long</span> <span class="type">long</span>) t.tv_sec) * <span class="number">1000000</span> + (<span class="type">long</span>)t.tv_nsec/<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> (temp/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c中static 受到编译器的影响 禁止使用long long类型.所以debug的时候还是去掉static的申明.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> time_diff,start_timestamp,end_timestamp;</span><br><span class="line"></span><br><span class="line">start_timestamp = <span class="built_in">thermal_get_current_time_ms</span>();</span><br><span class="line"></span><br><span class="line">end_timestamp = <span class="built_in">thermal_get_current_time_ms</span>();</span><br><span class="line">time_diff = end_timestamp - start_timestamp;</span><br><span class="line"><span class="built_in">printk</span>(<span class="string">&quot;[time] timestamp_diff = %lld ms&quot;</span>,time_diff);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CPP基础】【二】【设计模式】</title>
      <link href="/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_2_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1/"/>
      <url>/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_2_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我其实是想把指针当做我学习的第二部分，奈何指针很麻烦，智能指针一时半会也说不完.<br>于是先整理下设计模式<br>因为我在实际项目中开发用到不少的工厂模式，就先以工厂模式为主要的研究内容开始进行复习和拓展。</p><p>设计模式是一种在软件开发中常用的解决方案，旨在帮助开发者解决常见问题，提高软件的可维护性、可重用性和可扩展性。设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。</p><ol><li><p><strong>创建型模式</strong>：这些模式主要关注对象的创建机制，以适应不同的需求和场景。</p><ul><li><strong>单例模式</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>工厂方法模式</strong>：定义一个创建对象的接口，让子类决定实例化哪一个类。</li><li><strong>抽象工厂模式</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</li></ul></li><li><p><strong>结构型模式</strong>：这些模式主要关注对象之间的组合关系。</p><ul><li><strong>适配器模式</strong>：将一个类的接口转换成客户端期望的另一个接口，从而使不兼容的接口能够合作。</li><li><strong>装饰者模式</strong>：动态地给一个对象添加额外的职责，就增加功能来说，这种模式比生成子类更为灵活。</li><li><strong>代理模式</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li></ul></li><li><p><strong>行为型模式</strong>：这些模式主要关注对象之间的交互和职责分配。</p><ul><li><strong>观察者模式</strong>：定义了一种一对多的依赖关系，使得一当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。</li><li><strong>策略模式</strong>：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换，策略模式让算法的变化独立于使用算法的客户。</li><li><strong>命令模式</strong>：将一个请求封装成一个对象，从而使你能够使用不同的请求、队列或日志请求，并支持可撤销的操作。</li></ul></li></ol><p>设计模式是软件开发的宝贵经验积累，通过运用这些模式，可以有效地解决许多普遍存在的问题，使代码更加简洁、清晰和易于维护。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>这个在我是实际开发中用到的比较多</p><p>单例模式是一种创建型设计模式，它的主要目的是确保一个类只有一个实例，并提供一个全局访问点。这种模式在需要控制对某些资源的访问时尤其有用，比如数据库连接或配置管理等。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li><strong>唯一性</strong>：单例模式确保任何时候都只有一个类的实例存在。</li><li><strong>全局访问</strong>：提供一个静态方法，让用户可以获取到这个唯一实例。</li><li><strong>延迟初始化</strong>：可以实现懒汉式单例，只有在第一次使用时才创建实例。</li></ol><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>单例模式的实现方式有多种，以下是最常见的几种：</p><ol><li><p><strong>懒汉式</strong>：</p><ul><li>在需要时才创建实例，在多线程环境下需要加锁以保证线程安全。</li><li>完整的代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 加锁以保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>饿汉式</strong>：</p><ul><li>在类加载时就创建实例，线程安全，但不支持延迟加载。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态方法来获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 在第一次调用时创建实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值运算符，以防意外复制</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例对象并调用方法</span></span><br><span class="line">    Singleton::<span class="built_in">getInstance</span>().<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>双重检查锁定</strong>：</p><ul><li>在懒汉式的基础上，使用双重检查加锁，减少了同步的性能开销。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态方法来获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 首次检查</span></span><br><span class="line">        <span class="keyword">if</span> (!instance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对共享资源加锁</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="comment">// 再次检查</span></span><br><span class="line">            <span class="keyword">if</span> (!instance)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">// 创建实例</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值运算符，以防意外复制</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton *instance; <span class="comment">// 单例指针</span></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;   <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量初始化</span></span><br><span class="line">Singleton *Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例对象并调用方法</span></span><br><span class="line">    Singleton::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li>配置管理：一个应用程序通常只需要一个配置对象来管理配置参数。</li><li>日志记录：通常使用单例模式来管理日志记录，以确保日志的统一性。</li><li>数据库连接或线程池：避免创建多个连接，节省资源。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>单例模式通过控制实例的创建，提供了对共享资源的管理，避免了资源浪费和状态不一致的问题。在实际应用中，选择合适的实现方式以满足线程安全、性能和资源利用的需求非常重要。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是一种常见的设计模式，其主要目的是通过创建一个工厂来集中创建对象。工厂模式的主要类型包括：</p><ol><li><p><strong>简单工厂模式</strong>：</p><ul><li>定义一个工厂类，根据传入的参数决定创建哪一种产品类的实例。虽然简单工厂模式本身不是GoF设计模式，但它在很多项目中得到了广泛应用。</li></ul></li><li><p><strong>工厂方法模式</strong>：</p><ul><li>定义一个接口用于创建对象，但将实例化的工作推迟到子类中。每个子类都实现了自己的工厂方法，负责创建特定类型的对象。</li></ul></li><li><p><strong>抽象工厂模式</strong>：</p><ul><li>提供一个接口，用于创建一系列相关或依赖的对象，而不需要指定具体类。这种模式通常用于创建一组相关产品，适用于产品族的设计。</li></ul></li><li><p><strong>静态工厂方法</strong>：</p><ul><li>工厂方法被定义为静态方法，可以在没有创建工厂类实例的情况下调用。通常用于简单的对象创建操作。</li></ul></li></ol><p>这些工厂模式各有优缺点，根据具体需求选择合适的模式可以提高代码的可维护性和可扩展性。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>简单工厂模式使用一个工厂类根据给定的信息返回不同类型的对象。这个模式不推荐用于复杂的系统，因为它违反了开闭原则，但对于简单的应用场景非常有用。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Product* <span class="title">createProduct</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;B&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product* productA = SimpleFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    productA-&gt;<span class="built_in">use</span>();</span><br><span class="line">    <span class="keyword">delete</span> productA;</span><br><span class="line"></span><br><span class="line">    Product* productB = SimpleFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    productB-&gt;<span class="built_in">use</span>();</span><br><span class="line">    <span class="keyword">delete</span> productB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h3><p>工厂方法模式定义一个用于创建产品的接口，但由子类来决定实例化哪一个产品。这样可以更好地遵循开闭原则。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">factoryMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product* product = <span class="built_in">factoryMethod</span>();</span><br><span class="line">        product-&gt;<span class="built_in">use</span>();</span><br><span class="line">        <span class="keyword">delete</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorA</span> : <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">factoryMethod</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorB</span> : <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">factoryMethod</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Creator* creatorA = <span class="keyword">new</span> <span class="built_in">ConcreteCreatorA</span>();</span><br><span class="line">    creatorA-&gt;<span class="built_in">someOperation</span>();</span><br><span class="line">    <span class="keyword">delete</span> creatorA;</span><br><span class="line"></span><br><span class="line">    Creator* creatorB = <span class="keyword">new</span> <span class="built_in">ConcreteCreatorB</span>();</span><br><span class="line">    creatorB-&gt;<span class="built_in">someOperation</span>();</span><br><span class="line">    <span class="keyword">delete</span> creatorB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h3><p>抽象工厂模式提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定具体的类。这种模式非常适合用于需要创建多个不同类型的产品的场景。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> : <span class="keyword">public</span> ProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> : <span class="keyword">public</span> ProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductA* <span class="title">createProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductB* <span class="title">createProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ProductB* <span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ProductB* <span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* factory1 = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">    ProductA* productA1 = factory1-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">    ProductB* productB1 = factory1-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">    </span><br><span class="line">    productA1-&gt;<span class="built_in">use</span>();</span><br><span class="line">    productB1-&gt;<span class="built_in">use</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> productA1;</span><br><span class="line">    <span class="keyword">delete</span> productB1;</span><br><span class="line">    <span class="keyword">delete</span> factory1;</span><br><span class="line"></span><br><span class="line">    AbstractFactory* factory2 = <span class="keyword">new</span> <span class="built_in">ConcreteFactory2</span>();</span><br><span class="line">    ProductA* productA2 = factory2-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">    ProductB* productB2 = factory2-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">    </span><br><span class="line">    productA2-&gt;<span class="built_in">use</span>();</span><br><span class="line">    productB2-&gt;<span class="built_in">use</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> productA2;</span><br><span class="line">    <span class="keyword">delete</span> productB2;</span><br><span class="line">    <span class="keyword">delete</span> factory2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>简单工厂模式</strong>适合用于简单的对象创建，便于使用和管理。</li><li><strong>工厂方法模式</strong>通过子类化来实现扩展功能，更符合面向对象的原则。</li><li><strong>抽象工厂模式</strong>能够创建一系列相关的产品，适用性更广。</li></ul><p>这些工厂模式在软件开发中非常常见，尤其在需要解耦对象创建与使用逻辑时，能够有效提高代码的可维护性和可扩展性。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CPP基础】【一】</title>
      <link href="/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_1/"/>
      <url>/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_1/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这是对c++的泛式编程的梳理<br>c++的基础就那边点,无非就是流程控制和对象继承等<br>剩下的就是STL的内容。<br>所以我觉得还是有必要深究下来，一来就是我这个人的性格是这样的.<br>学习链接:<br><a href="https://www.learncpp.com/">https://www.learncpp.com/</a></p><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整型: int, long, long long</li><li>浮点型: float, double, long double</li><li>字符型: char, wchar_t</li><li>布尔型: bool</li><li>指针型: pointer, reference</li><li>数组型: array</li><li>枚举型: enum</li><li>结构体型: struct</li><li>类型: class</li></ul><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>布尔型</td><td>bool</td></tr><tr><td>字符型</td><td>char</td></tr><tr><td>整型</td><td>int</td></tr><tr><td>浮点型</td><td>float</td></tr><tr><td>双浮点型</td><td>double</td></tr><tr><td>无类型</td><td>void</td></tr><tr><td>宽字符型</td><td>wchar_t</td></tr></tbody></table><p>补充表格</p><table><thead><tr><th>类型</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1字节</td><td>-128~127</td></tr><tr><td>unsigned char</td><td>1字节</td><td>0~255</td></tr><tr><td>signed char</td><td>1字节</td><td>-128~127</td></tr><tr><td>int</td><td>4字节</td><td>-2^31~2^31-1</td></tr><tr><td>unsigned int</td><td>4字节</td><td></td></tr><tr><td>signed int</td><td>4字节</td><td></td></tr><tr><td>short int</td><td>2字节</td><td></td></tr><tr><td>unsigned short int</td><td>2字节</td><td></td></tr><tr><td>signed short int</td><td>2字节</td><td></td></tr><tr><td>long int</td><td>8字节</td><td></td></tr><tr><td>signed long int</td><td>8字节</td><td></td></tr><tr><td>unsigned long int</td><td>8字节</td><td></td></tr><tr><td>float</td><td>4字节</td><td></td></tr><tr><td>double</td><td>8字节</td><td></td></tr><tr><td>long long</td><td>8字节</td><td></td></tr><tr><td>long double</td><td>16字节</td><td></td></tr></tbody></table><p>typedef 使用格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type newname;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line">INT INI16;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p><p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p><p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 静态将int类型转换为float类型</span></span><br></pre></td></tr></table></figure><h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">    Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br><span class="line">    ptr_derived-&gt;<span class="built_in">func</span>(); <span class="comment">// 调用派生类函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常量转换"><a href="#常量转换" class="headerlink" title="常量转换"></a>常量转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 常量转换，将const int转换为int</span></span><br></pre></td></tr></table></figure><h3 id="重新解释转换"><a href="#重新解释转换" class="headerlink" title="重新解释转换"></a>重新解释转换</h3><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p><p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 重新解释将int类型转换为float类型</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一般来说有三个地方可以定义变量：</p><ul><li>在函数或一个代码块内部声明的变量，称为<strong>局部变量</strong>。</li><li>在函数参数的定义中声明的变量，称为<strong>形式参数</strong>。</li><li>在所有函数外部声明的变量，称为<strong>全局变量</strong>。</li></ul><p>作用域是程序的一个区域，变量的作用域可以分为以下几种：</p><ul><li><strong>局部作用域</strong>：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。</li><li><strong>全局作用域</strong>：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。</li><li><strong>块作用域</strong>：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。</li><li><strong>类作用域</strong>：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>常用的几个如下</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>strcpy(s1,s2)</strong></td><td>复制字符串s2到字符串s1</td></tr><tr><td><strong>strcat(s1, s2);</strong></td><td>连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如:<br/>string str1 &#x3D; “demo1”;<br/>string str2 &#x3D; “demo2”;<br/>string str &#x3D; str1 + str2;</td></tr><tr><td><strong>strlen(s1);</strong></td><td>返回字符串 s1 的长度。</td></tr><tr><td><strong>strcmp(s1, s2);</strong></td><td>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td></tr><tr><td><strong>strchr(s1, ch);</strong></td><td>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td><strong>strstr(s1, s2);</strong></td><td>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span>  var1 = <span class="number">10</span>;</span><br><span class="line">   <span class="type">char</span> var2[<span class="number">12</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">   cout &lt;&lt; &amp;var1 &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; var1 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">   cout &lt;&lt; &amp;var2 &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; var2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="type">int</span>    i;</span><br><span class="line">   <span class="type">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="type">int</span>&amp;    r = i;</span><br><span class="line">   <span class="type">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>直接放代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 提供接口框架的纯虚函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      width = w;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="type">int</span> width;</span><br><span class="line">   <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height)/<span class="number">2</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   Triangle  Tri;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   Tri.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Tri.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class="built_in">getArea</span>() &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><p>格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>举例如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp标准</title>
      <link href="/2024/11/14/CPP/cpp%E6%A0%87%E5%87%86/"/>
      <url>/2024/11/14/CPP/cpp%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>‌C++标准‌是C++编程语言的规范，由国际标准化组织（ISO）制定。<br>C++标准的发展历程可以追溯到1998年,<br>当时ISO&#x2F;IEC 14882:1998标准被发布，这被认为是第一个C++标准，常被称为C++98。<br>随后，C++标准经历了多次更新和修订，<br>包括C++03（2003年）、C++11（2011年）、C++14（2014年）和C++17（2017年）。最新的C++标准是C++20，于2020年发布，引入了许多新特性，如概念（concepts）、范围库（ranges）、协程（coroutines）等。此外，C++23标准也在2023年确定，但目前支持完整的编译器较少。<br>C++标准的发展历程</p><p>‌C++98‌：1998年发布的第一个C++标准，常被称为C++98。<br>‌C++03‌：2003年发布的修订版，增加了对自动存储期变量的支持等新特性。<br>‌C++11‌：2011年发布的版本，增加了lambda表达式、自动类型推导等功能。<br>‌C++14‌：2014年发布的版本，增加了基于范围的for循环、constexpr等功能。<br>‌C++17‌：2017年发布的版本，增加了结构化绑定、文件系统库等功能。<br>‌C++20‌：2020年发布的版本，引入了概念（concepts）、范围库（ranges）、协程（coroutines）等新特性。<br>‌C++23‌：2023年确定的版本，目前支持完整的编译器较少。<br>目前按照我接触的标准来说.<br>市面上大部分项目都是以C++11&#x2F;14&#x2F;17&#x2F;20为主, 而C++98&#x2F;03则是少数.  这主要是因为一些老项目的历史原因, 也有一些公司的项目使用C++98&#x2F;03, 这也是C++标准的发展历程.<br>本文先介绍个大概,后续再介绍C++11&#x2F;14&#x2F;17&#x2F;20的详细新特性。</p><h1 id="2-C-11-新特性"><a href="#2-C-11-新特性" class="headerlink" title="2 C++11 新特性"></a>2 C++11 新特性</h1><p>C++11标准引入了许多新特性，以下是一些重要的特性及其代码示例：</p><ol><li><p><strong>自动类型推导（auto）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;      <span class="comment">// x 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2.5</span>;    <span class="comment">// y 被推导为 double</span></span><br></pre></td></tr></table></figure></li><li><p><strong>范围for循环（for each）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : vec) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出每个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型：nullptr</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>; <span class="comment">// nullptr 是类型安全的空指针</span></span><br></pre></td></tr></table></figure><p>早期一直用的是NULL, 后来发现NULL是int类型, 所以就引入了nullptr, 它是一个空指针常量, 类型安全, 避免了类型转换错误。这使得代码更加安全和可读性更高。</p></li><li><p><strong>右值引用和移动语义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>lambda表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">lambda</span>(<span class="number">5</span>); <span class="comment">// 输出25</span></span><br></pre></td></tr></table></figure><p><strong>注意lambda是最后使用发射的,在用QT的时候,我经常会使用connect函数, 它会自动生成一个lambda表达式, 这个时候要注意局部变量和全局变量的生命周期，如果在外层申明了一个局部变量，在lambda表达式中使用这个变量，就会出现未定义行为导致程序崩溃。</strong></p></li><li><p><strong>智能指针（std::unique_ptr和std::shared_ptr）</strong><br>智能指针单独开一个章节说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 独占所有权的智能指针</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>; <span class="comment">// 共享所有权的智能指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong>线程支持库（std::thread）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br></pre></td></tr></table></figure></li><li><p><strong>静态断言（static_assert）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;Size of int is not 4 bytes!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>变长模板（Variadic templates）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="comment">// 使用折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;text&quot;</span>); <span class="comment">// 输出: 123text</span></span><br></pre></td></tr></table></figure></li><li><p><strong>枚举类（enum class）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">Color c = Color::Red; <span class="comment">// 强类型枚举</span></span><br></pre></td></tr></table></figure></li></ol><p>以上是C++11引入的一些主要新特性及其简单示例，这些特性极大地增强了C++的功能和灵活性。</p><h1 id="3-C-14-新特性"><a href="#3-C-14-新特性" class="headerlink" title="3 C++14 新特性"></a>3 C++14 新特性</h1><h2 id="1-二进制字面量"><a href="#1-二进制字面量" class="headerlink" title="1. 二进制字面量"></a>1. 二进制字面量</h2><p>C++14 引入了二进制字面量，允许使用 <code>0b</code> 或 <code>0B</code> 前缀来表示二进制数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> binaryNum = <span class="number">0b101010</span>; <span class="comment">// 二进制 101010 等于十进制 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;二进制 101010 的十进制值是: &quot;</span> &lt;&lt; binaryNum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 使用二进制字面量时，必须在编译器开启 C++14 标准的情况下编译代码。</p><h2 id="2-泛型-Lambda-表达式"><a href="#2-泛型-Lambda-表达式" class="headerlink" title="2. 泛型 Lambda 表达式"></a>2. 泛型 Lambda 表达式</h2><p>在 C++14 中，Lambda 表达式支持模板参数，可以使用 <code>auto</code> 作为参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">auto</span> n) &#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        <span class="built_in">print</span>(num); <span class="comment">// 调用 泛型 Lambda</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 泛型 Lambda 可能在某些老旧的编译器上不被支持，请确认编译器版本。</p><h2 id="3-std-make-unique"><a href="#3-std-make-unique" class="headerlink" title="3. std::make_unique"></a>3. std::make_unique</h2><p>C++14 引入了 <code>std::make_unique</code> 来简化 <code>std::unique_ptr</code> 的创建，避免手动使用 <code>new</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 创建一个 unique_ptr 并初始化</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 使用 <code>std::make_unique</code> 可以防止内存泄漏，但是请确保使用 C++14 或更高版本编译。</p><h2 id="4-返回类型推导"><a href="#4-返回类型推导" class="headerlink" title="4. 返回类型推导"></a>4. 返回类型推导</h2><p>C++14 允许推导函数的返回类型，可以使用 <code>auto</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 返回类型自动推导</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 使用返回类型推导时，确保函数体简单，编译器能够清晰推导出返回类型。</p><h2 id="5-std-shared-timed-mutex-和-std-shared-lock"><a href="#5-std-shared-timed-mutex-和-std-shared-lock" class="headerlink" title="5. std::shared_timed_mutex 和 std::shared_lock"></a>5. std::shared_timed_mutex 和 std::shared_lock</h2><p>C++14 引入了 <code>std::shared_timed_mutex</code> 和 <code>std::shared_lock</code>，支持更灵活的多线程锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reading data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writing data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(read)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(write)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 当在多线程环境下使用锁时，确保正确地管理锁的生命周期，避免死锁和资源竞争。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++14 引入了多项新特性，增强了语言的灵活性和表达能力。在使用这些特性时，请注意兼容性和编译器支持情况，以确保代码的可移植性和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【uiautomator】自动化测试camera【一】</title>
      <link href="/2024/11/11/Python/uiautomator2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95camera_1/"/>
      <url>/2024/11/11/Python/uiautomator2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95camera_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>本文档是自己写andorid camera自动化测试的随笔<br>测试机器为<br>OPPO Find x7<br>测试Apk为oppo的系统相机.</p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><p>我电脑是有装conda环境的,所以我直接用conda创建虚拟环境专门用于相关的测试.<br>官网下的巨慢，直接去清华大学的镜像源下载速度快很多.<br><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>下载对应的系统版本即可<br>linux对应sh文件.<br>windows直接双击exe文件安装即可.<br>我不是很喜欢直接破坏本机电脑的python环境,所以我创建了一个新的虚拟环境. 这种包管理更为安全，pip炸了就炸了 打不了删了重新建一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py3 python=3.7  #创建python3.7的虚拟环境</span><br><span class="line">conda activate  py3             #激活虚拟环境</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">conda deactivate               <span class="comment">#退出虚拟环境</span></span></span><br><span class="line">conda info --envs               #查看虚拟环境</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda environments:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">py2                      C:\Users\Admin\.conda\envs\py2</span></span><br><span class="line">py3                      C:\Users\Admin\.conda\envs\py3</span><br><span class="line">base                     D:\conda</span><br></pre></td></tr></table></figure><p>激活后会显示当前所在的环境名字，比如我这边是py3.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(py3) D:\Pr\demo&gt;</span><br></pre></td></tr></table></figure><p>安装需要的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uiautomator2</span><br><span class="line">pip install pyyaml</span><br></pre></td></tr></table></figure><p>电脑要提前安装好相关的adb.直接去谷歌官网下就行，linux下直接apt-get install adb就行.<br>如果adb 版本有问题，可以到<a href="https://developer.android.com/studio/releases/platform-tools%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88.%E7%84%B6%E5%90%8E%E6%B7%BB%E5%8A%A0%E5%88%B0">https://developer.android.com/studio/releases/platform-tools下载最新版.然后添加到</a><br>我需要先获得测试apk的包名,本质上我都去调用一些api接口.<br>这个包名可以替换的.<br>清下log,然后开始抓log.开始抓log后打开你所用的camera app.<br>adb logcat -c<br>adb logcat -G 20M<br>adb logcat -b all &gt;main.txt<br>打开main.txt log<br>过滤log 关键字connect call<br>看到我这边打印的一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11-11 21:42:43.435  1458  8995 I CameraService: CameraService::connect call (PID 6159 &quot;com.oplus.camera&quot;, camera ID 5) and Camera API version 2</span><br></pre></td></tr></table></figure><p>com.oplus.camera 就是我用的测试apk的包名,对应的camera ID 5 就是我打开的相机的ID.<br>话说为什么是5,我记得后摄一般项目都是做成0.<br>一般remosaic的相机ID是会做别的映射，我打了好多不同模式的，没明白他的映射id是怎么做的.<br>等有机会我自己写个apk，给这个手机hal的信息慢慢剖出来看下人家产品是怎么做的.<br>11-11 21:53:24.108  1458 10185 I CameraService: CameraService::connect call (PID 6159 “com.oplus.camera”, camera ID 5) and Camera API version 2<br>11-11 21:53:27.274  1458  9223 I CameraService: CameraService::connect call (PID 6159 “com.oplus.camera”, camera ID 1) and Camera API version 2<br>11-11 21:53:46.899  1458  2400 I CameraService: CameraService::connect call (PID 6159 “com.oplus.camera”, camera ID 2) and Camera API version 2<br>扯远了.</p><h1 id="3-写个demo"><a href="#3-写个demo" class="headerlink" title="3 写个demo"></a>3 写个demo</h1><p>新建一个python文件,名字为oppoCam.py<br>写个简单的demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2</span><br><span class="line"><span class="keyword">import</span> yaml                         <span class="comment"># 引入yaml模块 预留我后续用这个做基本配置文件</span></span><br><span class="line"><span class="keyword">import</span> time                         <span class="comment"># 引入time模块 预留我后续用这个做延时</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    package = <span class="string">&quot;com.mediatek.camera&quot;</span> <span class="comment"># 设置需要运行的包名</span></span><br><span class="line"></span><br><span class="line">    sn = <span class="string">&#x27;YD9HVGXGZLA6ZHCQ&#x27;</span>         <span class="comment"># 设置手机序列号 adb devices -l 获取</span></span><br><span class="line"></span><br><span class="line">    d = u2.connect(sn)              <span class="comment"># 连接手机</span></span><br><span class="line">    d.app_start(package)            <span class="comment"># 启动app</span></span><br><span class="line">    <span class="built_in">print</span>(d.info)                   <span class="comment"># 打印手机信息</span></span><br></pre></td></tr></table></figure><p>第一次运行好像还会从github上下载ATX和uiautomator2的包,下载完后就可以运行了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oppoCam.py</span><br></pre></td></tr></table></figure><p>第二次运行就很快了.<br>我这边打印出来了一些信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(py3) D:\Pr\demo\py&gt;python oppoCam.py</span><br><span class="line">&#123;&#x27;currentPackageName&#x27;: &#x27;com.android.launcher&#x27;, &#x27;displayHeight&#x27;: 2256, &#x27;displayRotation&#x27;: 0, &#x27;displaySizeDpX&#x27;: 360, &#x27;displaySizeDpY&#x27;: 792, &#x27;displayWidth&#x27;: 1080, &#x27;productName&#x27;: &#x27;PHZ110&#x27;, &#x27;screenOn&#x27;: True, &#x27;sdkInt&#x27;: 34, &#x27;naturalOrientation&#x27;: True&#125;</span><br></pre></td></tr></table></figure><p>自此相关的准备工作都已经完成可以做后续的拍照&#x2F;切换&#x2F;录像等操作了.<br>剩余部分另外整理</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidCamera架构</title>
      <link href="/2024/11/10/Android/AndroidCamera%E6%9E%B6%E6%9E%84/"/>
      <url>/2024/11/10/Android/AndroidCamera%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>分层：将各层的接口和实现分开<br>Camera架构</p><h1 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h1><p>所在位置<br>    架构最顶层<br>作用<br>    负责跟用户交互<br>流程<br>    接受到用户上的UI操作<br>    将UI操作通过request操作下发<br>    接收到底层返回的信息并反馈给用户</p><h1 id="CameraFramework-Service"><a href="#CameraFramework-Service" class="headerlink" title="CameraFramework&#x2F;Service"></a>CameraFramework&#x2F;Service</h1><p>CameraFramework<br>    作用<br>        以jar包的形式运行在APP进程中<br>    流程<br>        暴露接口供app调用<br>        接收app的请求<br>        通过调用Camera AIDL跨进程接口将请求发送到camera service进行处理<br>        将相关的结果返回至app<br>Camera Service<br>    作用<br>        封装Camera AIDL跨进程接口<br>        独立进程 Android 系统启动初期运行起来</p><h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><p>内部加载Camera Hal Module<br>    遵循谷歌制定的标准Camera Hal3接口<br>    由OEM&#x2F;ODM实现Module</p><h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><p>CameraSensor 驱动&#x2F;AF&#x2F;otp等相关驱动。用于实现其基本逻辑</p><h1 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h1><p>camera最底层V4L2<br>物理实现部分&#x2F;dts&#x2F;相关设备树供电<br><img src="https://s2.loli.net/2024/11/10/iAr8ZIY4FcgGkMp.png" alt="camera架构.png"></p>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装完后操作</title>
      <link href="/2024/11/10/Linux/linux%E5%AE%89%E8%A3%85%E5%AE%8C%E5%90%8E%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/11/10/Linux/linux%E5%AE%89%E8%A3%85%E5%AE%8C%E5%90%8E%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1 基础操作"></a>1 基础操作</h1><p>ftp工具下载:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install filezilla</span><br><span class="line">sudo apt-get install filezilla-locales #工具包</span><br></pre></td></tr></table></figure><p>dpkg 警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --reinstall install `dpkg --get-selections | grep &#x27;[[:space:]]install&#x27; | cut -f1`</span><br></pre></td></tr></table></figure><p>这些错误是说add-apt-repository的远程仓库没有这个文件，这个IP也是ping不通的。</p><p>添加的仓库保存在 &#x2F;etc&#x2F;apt&#x2F;sources.list.d目录下。删除对应的错误仓库文件即可</p><p>阿里镜像源</p><p> deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br> deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse</p><p> deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br> deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse</p><p> deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br> deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse</p><p> deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br> deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse</p><p> deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br> deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p><p>运行权限chmod +x qt-opensource-linux-x64-android-5.8.0.run</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apt/</span><br><span class="line">sudo cp sources.list sources.list.bak</span><br><span class="line">sudo cp sources.list sources.list.bak #更换镜像源</span><br></pre></td></tr></table></figure><p>ctrl + alt +t :打开终端</p><p>ctrl + d :关闭终端</p><p>ctrl + c:终止进程</p><p>win +e : 打开计算机</p><p>ctrl+s:阻断向终端输出</p><p>ctrl+q:恢复向终端输出</p><p>文件基本操作</p><p>-r 就是向下递归，不管有多少级目录，一并删除</p><p> -f 就是直接强行删除，不作任何提示的意思</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir test1 #创建文件夹</span><br><span class="line">rm -f main2.cpp #直接删除文件</span><br></pre></td></tr></table></figure><p>sudo apt-get autoclean                清理旧版本的软件缓存 sudo apt-get clean                    清理所有软件缓存 </p><p>sudo apt-get autoremove             删除系统不再使用的孤立软件 这三个命令主要清理升级缓存以及无用包的。</p><p>cpu:</p><p>查看物理cpu个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;physical id&quot;|sort |uniq|wc -l</span><br></pre></td></tr></table></figure><p>查看逻辑cpu个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</span><br></pre></td></tr></table></figure><p>查看cpu是几核的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;cores&quot;|uniq</span><br></pre></td></tr></table></figure><p>查看cpu的主频</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep MHz|uniq</span><br></pre></td></tr></table></figure><p>查看操作系统的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  Intel(R) Core(TM) i5-8300H CPU @ 2.30GHz</span></span><br><span class="line">cat /proc/cpuinfo | grep physical | uniq -c</span><br><span class="line">getconf LONG_BIT</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出64 当前工作在64位</span></span><br></pre></td></tr></table></figure><p>find命令如果出现   umount: &#x2F;run&#x2F;user&#x2F;1000&#x2F;gvfs: 权限不够</p><p>直接下面命令卸载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /run/user/1000/gvfs    // 卸载该文件</span><br><span class="line">rm -rf /run/user/1000/gvfs    // 删除该文件</span><br></pre></td></tr></table></figure><p>meld 比较工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meld main1.cpp main2.cpp</span><br></pre></td></tr></table></figure><p>解决：Gtk-Message: Failed to load module “canberra-gtk-module”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libcanberra-gtk-module</span><br></pre></td></tr></table></figure><p>cp 复制操作</p><p>mv指令  mv before.txt after.txt</p><h2 id="1-1-vim"><a href="#1-1-vim" class="headerlink" title="1.1 vim"></a>1.1 vim</h2><p>按i进入插入模式</p><p>命令模式直接输入</p><p>语法高亮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax enable</span><br></pre></td></tr></table></figure><p>显示行数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set nu</span><br></pre></td></tr></table></figure><p>突出当前行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cursorline  </span><br></pre></td></tr></table></figure><p> 如何把另外一个文件的内容拷贝到你文件内容下</p><p>例子:把main.cpp的内容拷贝到光标所在的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r!cat main.cpp</span><br></pre></td></tr></table></figure><p>按下数字 0 光标移动到行首</p><p>ctrl + u :向上翻页</p><p>ctrl + d :向下翻页</p><p>H ：光标移至屏幕首行大写</p><p>M ：光标移至屏幕中间</p><p>L ：光标移至屏幕最末行</p><p>：数字 光标移动到指定行</p><p>跳转到文件末尾:shift+g  或在G</p><p>跳转到最后一行最后一个字符 shitf+g $</p><p>跳转到第一行的第一个字符:俩下g</p><p>复制粘贴:</p><p>:reg 查看粘贴板子</p><p>其他地方的内容复制过来”+p</p><p>要选中内容进行复制，先在命令模式下按 v 进入 Visual Mode，然后用方向键 或 hjkl 选择文本，再按 y 进行复制。</p><h2 id="1-2-apt-get"><a href="#1-2-apt-get" class="headerlink" title="1.2 apt-get"></a>1.2 apt-get</h2><p>ubuntun</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:apt-fast/stable</span><br><span class="line">sudo apt-get install apt-fast</span><br></pre></td></tr></table></figure><hr><p>sudo add-apt-repository ppa:apt-fast&#x2F;stable</p><p>sudo add-apt-repository ppa:saiarcot895&#x2F;myppa</p><p>是可以直接使用的，格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install/delete package</span><br><span class="line">sudo apt-get -f install                                   #修复安装</span><br><span class="line">sudo apt-get dist-upgrade                                 #升级系统</span><br><span class="line">sudo apt-get upgrade                                      #更新已安装的包</span><br><span class="line">apt-get source package                                    #下载该包的源代码</span><br><span class="line">sudo apt-get build-dep package                            #安装相关的编译环境</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean              #清理无用的包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pip需要安装才能使用，配合virtualenvwrapper会锦上添花。安装过程如下（适用Ubuntu 10.10及以上版本），#使用格式为：pip install package。</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install python-pip python-dev build-essential</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo pip install --upgrade virtualenv</span><br></pre></td></tr></table></figure><h2 id="1-3-工具"><a href="#1-3-工具" class="headerlink" title="1.3 工具"></a>1.3 工具</h2><p>liunx 下载哪些:</p><ol><li><p>视频:vlc ,ffmepg</p></li><li><p>编程:      g++,    gcc,     clion ,   Go ,   goland,    pycharm,  qt,   vscode     cmake</p></li><li><p>工具:       meld(比较),     obs-studio(录屏),   typora  (md笔记),   teamviewer,   火狐浏览器,plank</p></li><li><p>交流:       Tim  ,Wechat</p></li><li><p>网易云音乐</p></li><li><p>apt-fast </p><p>注意:clion&#x2F;goland&#x2F;pycharm若build卡顿，找到安装文件clion.vmoptions更改-Xmx1024m 将数字改大一点就行</p></li></ol><p>最小化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock click-action &#x27;minimize&#x27;</span><br></pre></td></tr></table></figure><p>   apt-fast安装</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aria2    </span><br><span class="line">wget https://github.com/ilikenwf/apt-fast/archive/master.zip    </span><br><span class="line">unzip master.zip    </span><br><span class="line">cd apt-fast-master    </span><br><span class="line">sudo cp apt-fast /usr/bin    </span><br><span class="line">sudo cp apt-fast.conf /etc    </span><br><span class="line">sudo cp ./man/apt-fast.8 /usr/share/man/man8    </span><br><span class="line">sudo gzip /usr/share/man/man8/apt-fast.8   </span><br><span class="line">sudo cp ./man/apt-fast.conf.5 /usr/share/man/man5    </span><br><span class="line">sudo gzip /usr/share/man/man5/apt-fast.conf.5</span><br></pre></td></tr></table></figure><p>   安装wechat不能发送截图</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libjpeg62:i386</span><br></pre></td></tr></table></figure><p>画图工具：sudo apt-get install kolourpaint4</p><h1 id="2-python"><a href="#2-python" class="headerlink" title="2 python"></a>2 python</h1><p>sudo pip3 install安装软件的时候出现sudo: pip3找不到命令的解决方法如下图所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure><p>PIL 是一个 Python 图像处理库，是本课程使用的重要工具，使用下面的命令来安装 pillow（PIL）库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install --upgrade pip</span><br><span class="line">sudo pip3 install pillow</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install jieba</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir work &amp;&amp; cd work</span><br><span class="line">mkdir gephi &amp;&amp; cd gephi</span><br><span class="line">wget http://labfile.oss.aliyuncs.com/courses/677/gephi-0.9.1-linux.tar.gz                         #下载</span><br><span class="line">tar -zxvf gephi-0.9.1-linux.tar.gz     #解压 </span><br></pre></td></tr></table></figure><p>运行py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ascii.py ascii_dora.png</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;分析人物关系</p><h1 id="3-C"><a href="#3-C" class="headerlink" title="3 C++"></a>3 C++</h1><p>liunx下编译</p><p>g++ -o main main.cpp</p><h2 id="3-1-zlib"><a href="#3-1-zlib" class="headerlink" title="3.1 zlib"></a>3.1 zlib</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境:"></a>搭建环境:</h3><p>win10下有编译好的源码，直接添加lib和dll就能使用(cmakeGUI搭建vs项目build all,最后两个项目一个是动态库，一个是静态库)</p><p>liunx 下下载好zlib源码，进入源码目录执行以下操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装成功后，可以在&#x2F;usr&#x2F;local&#x2F;lib下找到libz.a</p><p>libz.a是一个静态库，为了使用zlib的接口，我们必须在连接我们的程序时，libz.a链接进来。  只需在 链接命令后加<code>-lz /usr/llocal/lib/libz.a</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-lz /usr/local/lib/libz.a</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//原始数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pchSrc[] = <span class="string">&quot;xxx....&quot;</span> ;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nSrcLen = <span class="built_in">sizeof</span>(pchSrc);</span><br><span class="line">    <span class="comment">//压缩之后的数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> achComp[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nCompLen = <span class="number">1024</span> ;</span><br><span class="line">    <span class="comment">//解压缩之后的数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> achUncomp[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nUncompLen = <span class="number">1024</span> ;</span><br><span class="line">    <span class="comment">//压缩</span></span><br><span class="line">    <span class="built_in">compress</span>(achComp,&amp;nCompLen, pchSrc,nSrcLen);</span><br><span class="line">    <span class="comment">//解压缩</span></span><br><span class="line">    <span class="built_in">uncompress</span>(achUncomp,&amp;nUncompLen, achComp,nCompLen);</span><br><span class="line">    <span class="comment">//显示原始数据信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数据(%d):\n%s\n\n&quot;</span>, nSrcLen,pchSrc);</span><br><span class="line">    <span class="comment">//显示压缩之后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;压缩数据(%d):\n%s\n\n&quot;</span>, nCompLen,achComp);</span><br><span class="line">    <span class="comment">//显示解压缩之后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解压数据(%d):\n%s\n\n&quot;</span>, nUncompLen,achUncomp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#clion配置中需要在CMakeLists.txt添加以下内容</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_EXE_LINKER_FLAGS</span><br><span class="line">        <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,-rpath -Wl,/usr/local/lib&quot;</span>)</span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(/usr/local/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(<span class="keyword">test</span> libz.a)<span class="comment">#test为项目名称</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基础压缩"><a href="#基础压缩" class="headerlink" title="基础压缩"></a>基础压缩</h4><p><strong>compress</strong>和<strong>uncompress</strong>是最基本的两个,分别用于压缩和解压</p><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEXTERN <span class="type">int</span> ZEXPORT compress <span class="title">OF</span><span class="params">((Bytef *dest, uLongf *destLen,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> Bytef *source, uLong sourceLen))</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEXTERN <span class="type">int</span> ZEXPORT uncompress <span class="title">OF</span><span class="params">((Bytef *dest, uLongf *destLen,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> Bytef *source, uLong sourceLen))</span></span>;</span><br></pre></td></tr></table></figure><p>参数类型<code>Bytef</code>表示字节流，它与字符串有所不同，字节流没有结束符，因而需要配备长度信息，处理字符串的时候需要把结束符也当成一个普通的字节。 而<code>uLongf</code>则用于指明长度信息了， 其实相当于<code>unsigned long</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原始数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pchSrc[] = <span class="string">&quot;xxx....&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nSrcLen = <span class="built_in">sizeof</span>(pchSrc);</span><br><span class="line">    <span class="comment">//压缩之后的数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> achComp[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nCompLen = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//解压缩之后的数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> achUncomp[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nUncompLen = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//压缩</span></span><br><span class="line">    <span class="built_in">compress</span>(achComp, &amp;nCompLen, pchSrc, nSrcLen);</span><br><span class="line">    <span class="comment">//解压缩</span></span><br><span class="line">    <span class="built_in">uncompress</span>(achUncomp, &amp;nUncompLen, achComp, nCompLen);</span><br><span class="line">    <span class="comment">//显示原始数据信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; pchSrc &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;压缩数据:&quot;</span> &lt;&lt; achComp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解压缩数据:&quot;</span> &lt;&lt; achUncomp &lt;&lt; endl;</span><br><span class="line"><span class="comment">//    printf(&quot;原始数据(%d):\n%s\n&quot;, nSrcLen,pchSrc);</span></span><br><span class="line"><span class="comment">//    //显示压缩之后的数据</span></span><br><span class="line"><span class="comment">//    printf(&quot;压缩数据(%d):\n%s\n&quot;, nCompLen,achComp);</span></span><br><span class="line"><span class="comment">//    //显示解压缩之后的数据</span></span><br><span class="line"><span class="comment">//    printf(&quot;解压数据(%d):\n%s\n&quot;, nUncompLen,achUncomp);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-cmake"><a href="#3-2-cmake" class="headerlink" title="3.2 cmake"></a>3.2 cmake</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>) <span class="comment">#cmkae最低版本</span></span><br><span class="line"><span class="keyword">project</span>(leetcode)<span class="comment">#项目名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)<span class="comment">#c++14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(leetcode main.cpp)<span class="comment">#往项目中添加文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定CMake编译最低要求版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="comment">#给项目命名</span></span><br><span class="line"><span class="keyword">PROJECT</span>(MYPRINT)</span><br><span class="line"><span class="comment">#收集c/c++文件并赋值给变量SRC_LIST_CPP  $&#123;PROJECT_SOURCE_DIR&#125;代表区当前项目录</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_CPP <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_C <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.c)</span><br><span class="line"><span class="comment">#指定头文件目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#指定生成库文件的目录</span></span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#去变量SRC_LIST_CPP 与SRC_LIST_C 指定生成libmyprint 动态库   默认生成静态库  SHARED指定生成库类型为动态库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(myprint SHARED <span class="variable">$&#123;SRC_LIST_CPP&#125;</span> <span class="variable">$&#123;SRC_LIST_C&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-3-thread"><a href="#3-3-thread" class="headerlink" title="3.3 thread"></a>3.3 thread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//liunx 下线程需要在cmake文件下添加库</span></span><br><span class="line"><span class="built_in">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Test1 Threads::Threads)</span><br></pre></td></tr></table></figure><p>测试代码：创建5个线程&#x2F;&#x2F;非11标准以上的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">say_hello</span><span class="params">(<span class="type">void</span>* args)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义线程的id变量，多个变量使用数组</span></span><br><span class="line">    <span class="type">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS ;++i)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">NULL</span>,say_hello, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret !=<span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="type">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">    <span class="type">int</span> tid = *((<span class="type">int</span>*)threadid);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello Runoob! 线程 ID, &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">int</span> indexes[NUM_THREADS];<span class="comment">// 用数组来保存i的值</span></span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main() : 创建线程, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line">        <span class="comment">// 传入的时候必须强制转换为void* 类型，即无类型指针</span></span><br><span class="line">        rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>,</span><br><span class="line">                            PrintHello, (<span class="type">void</span> *)&amp;(indexes[i]));</span><br><span class="line">        <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程传递信息:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">conts <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span> &#123;</span><br><span class="line">    <span class="type">int</span> thread_id;</span><br><span class="line">    <span class="type">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="type">void</span> *threadarg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_data</span> *my_data;</span><br><span class="line"></span><br><span class="line">    my_data = (<span class="keyword">struct</span> thread_data *) threadarg;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread ID : &quot;</span> &lt;&lt; my_data-&gt;thread_id;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Message : &quot;</span> &lt;&lt; my_data-&gt;message &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_data</span> td[NUM_THREADS];</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        td[i].thread_id = i;</span><br><span class="line">        td[i].message = (<span class="type">char</span> *) <span class="string">&quot;This is message&quot;</span>;</span><br><span class="line">        rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>,</span><br><span class="line">                            PrintHello, (<span class="type">void</span> *) &amp;td[i]);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-OpenGl"><a href="#4-OpenGl" class="headerlink" title="4 OpenGl"></a>4 OpenGl</h1><p>下载OpenGL需要的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libgl1-mesa-dev  </span><br><span class="line">sudo apt-get install freeglut3-dev  </span><br><span class="line">sudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev</span><br></pre></td></tr></table></figure><p>需要在cmake中添加如下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenGL REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(GLUT REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OPENGL_INCLUDE_DIRS&#125;</span> <span class="variable">$&#123;GLUT_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;OPENGL_LIBRARIES&#125;</span> <span class="variable">$&#123;GLUT_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure><p>demo代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glOrtho</span>(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">-5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_MODELVIEW);</span><br><span class="line">    <span class="built_in">gluLookAt</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glutWireTeapot</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glFlush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);</span><br><span class="line">    <span class="built_in">glutInitWindowPosition</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;OpenGL 3D View&quot;</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display);</span><br><span class="line">    <span class="built_in">glutMainLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-ncurses"><a href="#5-ncurses" class="headerlink" title="5 ncurses"></a>5 ncurses</h1><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>测试demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initscr</span>();</span><br><span class="line">    <span class="built_in">raw</span>();</span><br><span class="line">    <span class="built_in">noecho</span>();</span><br><span class="line">    <span class="built_in">curs_set</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* c = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">mvprintw</span>(LINES/<span class="number">2</span>,(COLS-<span class="built_in">strlen</span>(c))/<span class="number">2</span>,c);</span><br><span class="line">    <span class="built_in">refresh</span>();</span><br><span class="line">    <span class="built_in">getch</span>();</span><br><span class="line">    <span class="built_in">endwin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test -lncurses</span><br></pre></td></tr></table></figure><h1 id="6-Opencv"><a href="#6-Opencv" class="headerlink" title="6 Opencv"></a>6 Opencv</h1><h2 id="6-1-环境搭建"><a href="#6-1-环境搭建" class="headerlink" title="6.1 环境搭建"></a>6.1 环境搭建</h2><p>先装好依赖项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libdc1394-22-dev</span><br><span class="line">sudo apt-get install libopencv-dev</span><br></pre></td></tr></table></figure><p>下载好源码后进入到源码目录</p><p>创建一个目录编译opencv</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><p>cmake一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..</span><br></pre></td></tr></table></figure><p>执行编译过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j8</span><br></pre></td></tr></table></figure><p>将make生成的文件安装到系统目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>配置环境</p><p>打开文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br></pre></td></tr></table></figure><p>再打开的文件添加makefile安装路劲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>cmakelist.txt添加如下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(/usr/local/<span class="keyword">include</span>/opencv4/opencv2)</span><br><span class="line"><span class="keyword">set</span> (OpenCV_LIBS /usr/local/lib)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(helloCV <span class="variable">$&#123;OpenCV_LIBS&#125;</span>) <span class="comment">#helloCV 工程名字</span></span><br></pre></td></tr></table></figure><p>demon代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;../test.jpeg&quot;</span>);</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;img;</span></span><br><span class="line">    <span class="keyword">if</span>(img.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;My picture: &quot;</span>&lt;&lt; img.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>,img);</span><br><span class="line">    <span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果出现报错：<br>Gtk-Message: 21:57:35.293: Failed to load module “canberra-gtk-module”<br>则安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libcanberra-gtk-module</span><br></pre></td></tr></table></figure><p>查看opencv安装的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --libs</span><br></pre></td></tr></table></figure><p>查看opencv安装的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --modversion</span><br></pre></td></tr></table></figure><p>查看opencv安装路劲</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -iname &quot;*opencv*&quot; &gt; /home/xtt/Desktop/opencv_find.txt</span><br></pre></td></tr></table></figure><h1 id="7-SDL2"><a href="#7-SDL2" class="headerlink" title="7 SDL2"></a>7 SDL2</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sdl2</span></span><br><span class="line">sudo apt-get install libsdl2-2.0</span><br><span class="line">sudo apt-get install libsdl2-dev</span><br><span class="line">sudo apt-get install libsdl2-mixer-dev</span><br><span class="line">sudo apt-get install libsdl2-image-dev</span><br><span class="line">sudo apt-get install libsdl2-ttf-dev</span><br><span class="line">sudo apt-get install libsdl2-gfx-dev</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sdl1.1</span></span><br><span class="line">sudo apt-get install libsdl1.2-dev</span><br><span class="line">sudo apt-get install libsdl-image1.2-dev</span><br><span class="line">sudo apt-get install libsdl-mixer1.2-dev</span><br><span class="line">sudo apt-get install libsdl-ttf2.0-dev</span><br><span class="line">sudo apt-get install libsdl-gfx1.2-dev</span><br></pre></td></tr></table></figure><p>检测SDL装上了没有：</p><p>sdl-config –exec-prefix –version –cflag</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL/SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    res = <span class="built_in">SDL_Init</span>(SDL_INIT_EVENTTHREAD);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SDL init success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SDL init fail!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译  </p><p>-lSDL</p><h1 id="8-个人博客"><a href="#8-个人博客" class="headerlink" title="8 个人博客"></a>8 个人博客</h1><h2 id="8-1-下载nodejs"><a href="#8-1-下载nodejs" class="headerlink" title="8.1 下载nodejs"></a>8.1 下载nodejs</h2><p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>解压进入到bin文件夹下运行.&#x2F;node -v</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/xtt/nodejs/bin/npm /usr/local/bin/</span><br><span class="line">sudo ln -s /home/xtt/nodejs/bin/node /usr/local/bin/</span><br></pre></td></tr></table></figure><p>在别的目录下  确认是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载cnpm</span></span><br><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org</span><br><span class="line">sudo ln -s /home/xtt/nodejs/bin/cnpm /usr/local/bin/cnpm  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载cnpm</span></span><br></pre></td></tr></table></figure><p>hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/xtt/nodejs/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>hexo -v 验证</p><p>进入创建好的博客目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>需要退出后创建新</p><p>hexo n “第一篇博客”</p><p>博客的md文件会自动生产放在下面路劲</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd source/_posts/</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">sudo cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>设置_config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line"></span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/JoeNero/JoeNero.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>hexo d</p><p>创建博客md</p><p>hexo n “博客”</p><p>清空数据库</p><p>hexo clean</p><p>生产数据库</p><p>hexo g</p><p>推送</p><p>hexo d </p><h1 id="9-github"><a href="#9-github" class="headerlink" title="9 github"></a>9 github</h1><p>下载git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>检查下载版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><p>下载ssh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ssh  </span><br></pre></td></tr></table></figure><p>检查ssh服务状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示sshd的话表示ssh-server已经启动</span></span><br></pre></td></tr></table></figure><p>使用  命令查看 ssh key 是否存在，若存在则忽略这一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;526988861@qq.com&quot;</span><br></pre></td></tr></table></figure><p>clone</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 网址</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add readme.md #将文件添加到暂存区域</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;add readme file&quot; #提交本次修改</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master#推送到远程仓库</span><br></pre></td></tr></table></figure><h1 id="10-服务器"><a href="#10-服务器" class="headerlink" title="10 服务器"></a>10 服务器</h1><p>ssh 链接服务器<br>sudo ssh <a href="mailto:&#x77;&#101;&#x69;&#x62;&#111;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x2e;&#x31;&#x39;&#x31;&#x2e;&#50;&#x33;&#x31;">&#x77;&#101;&#x69;&#x62;&#111;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x2e;&#x31;&#x39;&#x31;&#x2e;&#50;&#x33;&#x31;</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@IP</span><br></pre></td></tr></table></figure><p>ssh <a href="mailto:&#x72;&#111;&#x6f;&#116;&#64;&#x31;&#x30;&#54;&#46;&#49;&#52;&#x2e;&#x32;&#x38;&#x2e;&#49;&#x33;&#55;">&#x72;&#111;&#x6f;&#116;&#64;&#x31;&#x30;&#54;&#46;&#49;&#52;&#x2e;&#x32;&#x38;&#x2e;&#49;&#x33;&#55;</a><br>客户端到服务器<br>scp .&#x2F;filename username@IP:&#x2F;home&#x2F;bio321&#x2F;Desktop<br>服务器到客户端<br>scp .&#x2F;filename username@IP:&#x2F;home&#x2F;bio321&#x2F;Desktop<br>&#x2F;&#x2F;客户端<br>scp -r Kail <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#x40;&#49;&#x30;&#54;&#46;&#49;&#52;&#x2e;&#50;&#56;&#46;&#x31;&#x33;&#x37;">&#x72;&#x6f;&#111;&#x74;&#x40;&#49;&#x30;&#54;&#46;&#49;&#52;&#x2e;&#50;&#56;&#46;&#x31;&#x33;&#x37;</a>:&#x2F;root&#x2F;liunx</p><p>teamviewer</p><p>1569607240</p><p>647emx</p><p>美化主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:numix/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install numix-gtk-theme numix-icon-theme-circle</span><br></pre></td></tr></table></figure><p>shell 美化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh #安装zsh</span><br><span class="line"></span><br><span class="line">zsh --version #确认是否安装成功</span><br><span class="line"></span><br><span class="line">sudo chsh -s $(which zsh)  #设置zsh为默认shell</span><br></pre></td></tr></table></figure><h1 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h1><p>右键添加运行终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCMDHere]</span><br><span class="line">&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCMDHere\command]</span><br><span class="line">@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt随笔【一】</title>
      <link href="/2024/11/10/Qt/Qt%E9%9A%8F%E7%AC%94_1/"/>
      <url>/2024/11/10/Qt/Qt%E9%9A%8F%E7%AC%94_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-linux-下注意点"><a href="#1-linux-下注意点" class="headerlink" title="1 linux 下注意点"></a>1 linux 下注意点</h1><p>找不到mysql.h文件</p><p>sudo apt-get install libmysqlclient-dev</p><p>编译太慢,更改</p><p>-j 4       4为线程 &lt;&#x3D; cpu的线程</p><p>缺少:-1: error: 找不到 -lGL<br>sudo apt-get install libgl1-mesa-dev</p><p>使用以下模块需要 实现下载这个 qt会自动查找</p><p>sudo apt-get install qtmultimedia5-dev</p><p>如果不行则加:</p><p>sudo apt-get install libpul se-dev</p><p>视频相关控件需要安装如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libpulse-dev</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT       += multimedia</span><br></pre></td></tr></table></figure><p>libusbzhic库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libusb-dev</span><br><span class="line">sudo apt-get install libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><h1 id="2-布局管理"><a href="#2-布局管理" class="headerlink" title="2 布局管理"></a>2 布局管理</h1><h2 id="2-1-QGridLayout网格布局"><a href="#2-1-QGridLayout网格布局" class="headerlink" title="2.1 QGridLayout网格布局"></a>2.1 QGridLayout网格布局</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout-&gt;<span class="built_in">setRowStretch</span>(<span class="type">int</span> row, <span class="type">int</span> stretch);<span class="comment">//设置行比例系数</span></span><br><span class="line">layout-&gt;<span class="built_in">setColumnStretch</span>(<span class="type">int</span> column, <span class="type">int</span> stretch);<span class="comment">//设置列比例系数</span></span><br></pre></td></tr></table></figure><p>布局示意如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout-&gt;<span class="built_in">addWidget</span>(&amp;TestBtn1, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//往网格的不同坐标添加不同的组件</span></span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(&amp;TestBtn2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(&amp;TestBtn3, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(&amp;TestBtn4, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="3-控件："><a href="#3-控件：" class="headerlink" title="3 控件："></a>3 控件：</h1><h2 id="QLable"><a href="#QLable" class="headerlink" title="QLable"></a>QLable</h2><p>显示数字</p><p>setText ( const QString &amp; )setText参数必须是QString类型才可以 你的变量如果是整形，可以直接转换，比如QString()::number( int num).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;labelTime-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(times));</span><br></pre></td></tr></table></figure><h2 id="QLCDNumber："><a href="#QLCDNumber：" class="headerlink" title="QLCDNumber："></a>QLCDNumber：</h2><p>lcd是直接通过方法value来获取当前显示的值，通过方法display来显示</p><p>QLCDNumber有以下几种模式：</p><p><a href="https://blog.csdn.net/xuancailinggan/article/details/qlcdnumber.html#setHexMode">setHexMode</a>()-十六进制</p><p><a href="https://blog.csdn.net/xuancailinggan/article/details/qlcdnumber.html#setDecMode">setDecMode</a>()-十进制</p><p><a href="https://blog.csdn.net/xuancailinggan/article/details/qlcdnumber.html#setOctMode">setOctMode</a>()-八进制</p><p><a href="https://blog.csdn.net/xuancailinggan/article/details/qlcdnumber.html#setBinMode">setBinMode</a>()-二进制</p><p>lcdNum-&gt;setDecMode();</p><h2 id="QTimer"><a href="#QTimer" class="headerlink" title="QTimer"></a>QTimer</h2><p>Q_DECL_OVERRIDE也就是c++的override</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define Q_DECL_OVERRIDE override</span><br></pre></td></tr></table></figure><p>在重写虚函数时会用到，</p><p>作用是防止写错虚函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void keyPressEvent(QKeyEvent *event) Q_DECL_OVERRIDE;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件在QTimer文件下</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QTimer *m_pTimer;</span><br><span class="line">m_pTimer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 设置超时间隔</span></span><br><span class="line">m_pTimer-&gt;<span class="built_in">setInterval</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">connect</span>(m_pTimer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateProgress</span>()));</span><br><span class="line">m_pTimer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);<span class="comment">//这一步会覆盖之前设置的时间间隔</span></span><br></pre></td></tr></table></figure><p>start()之后，每秒都会调用update()</p><p>可以通过设置setSingleShot(true)来让定时器只执行一次。也可以使用静态函数QTimer::singleShot()：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTimer::singleShot(200, this, SLOT(updateCaption()));</span><br></pre></td></tr></table></figure><p>QTimer和lable配合显示系统时间</p><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期/时间显示</span></span><br><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer,<span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">timerUpdate</span>()));</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>定义成员函数timerUpdate()实现用户界面显示时间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">userwindow::timerUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDateTime time = QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line"></span><br><span class="line">    QString str = time.<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss dddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;dateTime-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-QChart"><a href="#4-QChart" class="headerlink" title="4 QChart"></a>4 QChart</h1><p>.pro文件添加模块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT +=charts</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用charts模板需要加入命名控件或者宏</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Qtcharts</span><br><span class="line">或者一个宏 QT_CHARTS_USE_NAMESPACE</span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChart&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QChart *chart;</span><br><span class="line">QChartView *chartView;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坐标系</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QValueAxis&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QValueAxis *axisX;</span><br><span class="line">QValueAxis *axisY;</span><br><span class="line">...</span><br><span class="line">axisX-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">20</span>);    <span class="comment">//设置范围</span></span><br><span class="line">axisX-&gt;<span class="built_in">setLabelFormat</span>(<span class="string">&quot;%u&quot;</span>);   <span class="comment">//设置刻度的格式 y轴同理</span></span><br><span class="line">axisX-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;X&quot;</span>);           <span class="comment">//设置描述</span></span><br><span class="line">axisY-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line"><span class="comment">/************************************</span></span><br><span class="line"><span class="comment">    %u 无符号十进制整数</span></span><br><span class="line"><span class="comment">    %s 字符串</span></span><br><span class="line"><span class="comment">    %A 浮点数、十六进制数字和p-记法</span></span><br><span class="line"><span class="comment">    %c 一个字符</span></span><br><span class="line"><span class="comment">    %d 有符号十进制整数</span></span><br><span class="line"><span class="comment">    %e 浮点数、e-记数法</span></span><br><span class="line"><span class="comment">    %E 浮点数、E-记数法</span></span><br><span class="line"><span class="comment">    %f 浮点数、十进制记数法</span></span><br><span class="line"><span class="comment">    %g 根据数值不同自动选择％f或％e．</span></span><br><span class="line"><span class="comment">    %G 根据数值不同自动选择％f或％e.</span></span><br><span class="line"><span class="comment">    %i 有符号十进制数（与％d相同）</span></span><br><span class="line"><span class="comment">    %o 无符号八进制整数</span></span><br><span class="line"><span class="comment">    %p 指针</span></span><br><span class="line"><span class="comment">    %s 字符串</span></span><br><span class="line"><span class="comment">    %x/%X 使用十六进制数字0f的无符号十六进制整数</span></span><br><span class="line"><span class="comment">****************************************/</span></span><br><span class="line"><span class="comment">//标记的个数</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setTickCount</span>(<span class="number">11</span>);           </span><br><span class="line">    axisY-&gt;<span class="built_in">setTickCount</span>(<span class="number">11</span>);</span><br><span class="line"><span class="comment">//次标记的个数</span></span><br><span class="line">axisX-&gt;<span class="built_in">setMinorTickCount</span>(<span class="number">1</span>);        <span class="comment">//设置每个大格里面小刻度线的数目</span></span><br><span class="line"><span class="comment">//    axisY-&gt;setMinorTickCount(1);</span></span><br><span class="line">chart-&gt;<span class="built_in">createDefaultAxes</span>(); <span class="comment">//建立默认坐标轴，不需要QValueAxis 默认是4x4大格子</span></span><br><span class="line"><span class="comment">//chart-&gt;axisY()-&gt;setRange(0, 10);//默认坐标轴限定范围</span></span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom); <span class="comment">//下：Qt::AlignBottom  上：Qt::AlignTop</span></span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisY, Qt::AlignLeft);   <span class="comment">//左：Qt::AlignLeft    右：Qt::AlignRight</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chart-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;曲线图实例&quot;</span>);</span><br><span class="line">chart-&gt;<span class="built_in">setAnimationOptions</span>(QChart::SeriesAnimations);<span class="comment">//设置曲线动画模式</span></span><br><span class="line">chart-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">hide</span>(); <span class="comment">//隐藏图例</span></span><br><span class="line">chart-&gt;<span class="built_in">addSeries</span>(splineSeries);<span class="comment">//输入数据</span></span><br><span class="line">chart-&gt;<span class="built_in">setAxisX</span>(axisX, splineSeries);</span><br><span class="line">chart-&gt;<span class="built_in">setAxisY</span>(axisY, splineSeries);</span><br></pre></td></tr></table></figure><p>需要将chart添加到chartView</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chartView-&gt;<span class="built_in">show</span>();</span><br><span class="line">chartView-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line">chartView-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);<span class="comment">//防止图形走样</span></span><br></pre></td></tr></table></figure><h2 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h2><p>QSplineSeries</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSplineSeries&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">splineSeries = <span class="keyword">new</span> QSplineSeries;</span><br><span class="line"><span class="comment">//添加数据的两周方式</span></span><br><span class="line">splineSeries-&gt;<span class="built_in">append</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">*splineSeries &lt;&lt; <span class="built_in">QPointF</span>(<span class="number">11</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">QPointF</span>(<span class="number">13</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">QPointF</span>(<span class="number">17</span>, <span class="number">6</span>)&lt;&lt; <span class="built_in">QPointF</span>(<span class="number">20</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//源数据添加到图表上</span></span><br><span class="line">chart-&gt;<span class="built_in">addSeries</span>(splineSeries);<span class="comment">//输入数据</span></span><br><span class="line">chart-&gt;<span class="built_in">setAxisX</span>(axisX, splineSeries);</span><br><span class="line">chart-&gt;<span class="built_in">setAxisY</span>(axisY, splineSeries);</span><br></pre></td></tr></table></figure><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>先包含头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QBarSet&gt;</span> </span></span><br></pre></td></tr></table></figure><p>QBarSet类表示条形图中的一组条形。<br>一个bar集包含每个类别的一个数据值。<br>假设集合的第一个值属于第一个类别，<br>第二个属于第二个类别，依此类推。<br>如果集合的值小于类别的值，则假设缺失值位于集合的末尾。对于位于集合中间的缺失值，则使用0的数值。<br>没有显示零值集的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QBarSeries&gt;</span><br></pre></td></tr></table></figure><p>QBarSeries类表示的是柱状图数据，需要将相应的QBarSet添加进来</p><p>柱状图关系示意如下:</p><h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCharts/QPieSeries&gt;</span></span></span><br></pre></td></tr></table></figure><p>QPieSeries是一块饼图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCharts/QPieSlice&gt;</span></span></span><br></pre></td></tr></table></figure><p>QPieSlice是饼图上的碎片</p><h1 id="5-QCustomPlot"><a href="#5-QCustomPlot" class="headerlink" title="5 QCustomPlot"></a>5 QCustomPlot</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui printsupport</span><br></pre></td></tr></table></figure><p>选择项目的.pro文件，添加printsupport，如图，QCustomPlot包含了一些打印的东西，如果没有这一步，程序会报错</p><p>基类为QWidget：提升为<code>QCustomPlot</code></p><p>这里强调一下：Qt提升控件时，通常提升的类名称中，每个单词的首字母必须大写与Qt控件命名规则保持一致，各种第三方控件都采用这种命名格式，否则无法识别，如这里必须写成<code>QCustomPlot</code>而不能写成<code>Qcustomplot</code>或<code>qcustomplot</code></p><h1 id="动态库的调用"><a href="#动态库的调用" class="headerlink" title="动态库的调用"></a>动态库的调用</h1><h2 id="liunx"><a href="#liunx" class="headerlink" title="liunx"></a>liunx</h2><p>详细图例见dll文件</p><p>创建c++库，添加代码生成对应的.so文件</p><p>在debug文件下将.so文件后缀的复制到新建工程的debug文件下</p><p>并将相应的头文件添加到目标工程中</p><p>在.pro里面添加 如下 格式 -L.&#x2F;lib -l(文件名)  因为直接放在debug文件下所以直接 在该文件夹下找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS +=  -L -llibdll</span><br></pre></td></tr></table></figure><h1 id="Linux-下opencv的搭建"><a href="#Linux-下opencv的搭建" class="headerlink" title="Linux 下opencv的搭建"></a>Linux 下opencv的搭建</h1><p>在.pro文件中添加如下内容,根据个人情况,就是你opencv的安裝路勁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /usr/local/include \</span><br><span class="line">                /usr/local/include/opencv4 \</span><br><span class="line"></span><br><span class="line">LIBS += /usr/local/lib/libopencv*</span><br></pre></td></tr></table></figure><p>有的人是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /usr/local/include \</span><br><span class="line">                /usr/local/include/opencv \</span><br><span class="line">                /usr/local/include/opencv2</span><br><span class="line"></span><br><span class="line">LIBS += /usr/local/lib/lib*</span><br></pre></td></tr></table></figure><p>出现这个错误，只需要在对应的文件中添加头文件<br>#include &lt;opencv2&#x2F;highgui&#x2F;highgui_c.h&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/xtt/prj/Qt/pack/OpenNCC_View/OpenNCC_View/widget.cpp:330: error: ~~‘cvGetWindowHandle’~~ was not declared in this scope</span><br><span class="line">                 if (!cvGetWindowHandle(&quot;OpenNCC&quot;))</span><br><span class="line">                      ^~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><h1 id="Linux-下qt的打包"><a href="#Linux-下qt的打包" class="headerlink" title="Linux 下qt的打包"></a>Linux 下qt的打包</h1><p>将release 版本下的hi可执行文件拷到你新建的bin文件夹下</p><p>新建一个打包的脚本pack.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exe=&quot;OpenNCC_View&quot; #需发布的程序名称</span><br><span class="line">des=&quot;/home/xtt/Qt/OpenNCC_View/bin&quot; #新建目录的完整路径</span><br><span class="line">deplist=$(ldd $exe|awk &#x27;&#123;if (match($3,&quot;/&quot;))&#123;printf(&quot;%s &quot;),$3&#125;&#125;&#x27;)</span><br><span class="line">cp $deplist $des</span><br></pre></td></tr></table></figure><p>运行脚本 sh pack.sh会在该文件夹下添加一些.so动态库</p><p>然后编写一个部署脚本</p><p>文件名和你的项目名字一致，这里的项目名字是OpenNCC_View，所以部署脚本是OpenNCC_View.sh</p><p>以下是该脚本的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span>  </span><br><span class="line">appname=`basename $0 | sed s,\.sh$,,`  </span><br><span class="line">dirname=`dirname $0`  </span><br><span class="line">tmp=&quot;$&#123;dirname#?&#125;&quot;  </span><br><span class="line">if [ &quot;$&#123;dirname%$tmp&#125;&quot; != &quot;/&quot; ]; then  </span><br><span class="line">dirname=$PWD/$dirname  </span><br><span class="line">fi  </span><br><span class="line">LD_LIBRARY_PATH=$dirname  </span><br><span class="line">export LD_LIBRARY_PATH  </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">dirname</span>/<span class="variable">$appname</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用軟件打包</p><h1 id="Window下打包程序"><a href="#Window下打包程序" class="headerlink" title="Window下打包程序"></a>Window下打包程序</h1><p>Win+r 打开dos命令 cmd</p><p>输入命令：</p><p>cd &#x2F;d H:\QT\Test\release</p><p>必须要加&#x2F;d 不然没办法进入目录</p><p>Qt Quick Application版本:</p><p>windeployqt  Test.exe</p><p>Test.exe 为release版本的exe</p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andoird编译文件mk说明</title>
      <link href="/2024/11/10/Android/Andoird%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6mk%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/11/10/Android/Andoird%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6mk%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h1><p>Android.mk 文件必须先定义 LOCAL_PATH 变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH :=$(call my-dir)</span><br></pre></td></tr></table></figure><p>此变量表示源文件在开发树中的位置。<br>在这行代码中，编译系统提供的宏函数 my-dir 将返回当前目录（Android.mk 文件本身所在的目录）的路径。<br>下一行声明 <code>CLEAR_VARS</code> 变量，其值由编译系统提供。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(CLEAR_VARS)</span><br></pre></td></tr></table></figure><p>CLEAR_VARS 变量指向一个特殊的 GNU Makefile，后者会清除许多 LOCAL_XXX 变量，例如 LOCAL_MODULE、LOCAL_SRC_FILES 和 LOCAL_STATIC_LIBRARIES。请注意，GNU Makefile 不会清除 LOCAL_PATH。此变量必须保留其值，因为系统在单一 GNU Make 执行环境（其中的所有变量都是全局变量）中解析所有编译控制文件。在描述每个模块之前，必须声明（重新声明）此变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := hello-jni</span><br></pre></td></tr></table></figure><p>每个模块名称必须唯一，且不含任何空格。编译系统在生成最终共享库文件时，会对您分配给 LOCAL_MODULE 的名称自动添加正确的前缀和后缀。例如，上述示例会生成名为 libhello-jni.so的库。<br>注意：如果模块名称的开头已经是 lib，则编译系统不会附加额外的 lib 前缀；而是按原样采用模块名称，并添加 .so 扩展名。因此，比如原来名为 libfoo.c 的源文件仍会生成名为 libfoo.so 的共享对象文件。此行为是为了支持 Android 平台源文件根据 Android.mk 文件生成的库；所有这些库的名称都以 lib 开头。<br>下一行会列举源文件，以空格分隔多个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILED :=hello-jni.c</span><br></pre></td></tr></table></figure><p>LOCAL_SRC_FILES 变量必须包含要编译到模块中的 C 和&#x2F;或 C++ 源文件列表。<br>最后一行帮助系统将所有的内容连接到一起:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure><p>BUILD_SHARED_LIBRARY 变量指向一个 GNU Makefile 脚本，该脚本会收集您自最近 include 以来在 LOCAL_XXX 变量中定义的所有信息。此脚本确定要编译的内容以及编译方式</p><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h1><h2 id="2-1-CLEAR-VARS"><a href="#2-1-CLEAR-VARS" class="headerlink" title="2.1 CLEAR_VARS"></a>2.1 CLEAR_VARS</h2><p>此变量指向的编译脚本用于取消定义下文“开发者定义的变量”部分中列出的几乎所有 LOCAL_XXX 变量。在描述新模块之前，请使用此变量来包含此脚本。使用它的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(CLEAR_VARS)</span><br></pre></td></tr></table></figure><h2 id="2-2-BUILD-SHARED-LIBRARY"><a href="#2-2-BUILD-SHARED-LIBRARY" class="headerlink" title="2.2 BUILD_SHARED_LIBRARY"></a>2.2 BUILD_SHARED_LIBRARY</h2><p>此变量指向的编译脚本用于收集您在 LOCAL_XXX 变量中提供的模块的所有相关信息，以及确定如何根据您列出的源文件编译目标共享库。请注意，使用此脚本要求您至少已经为 LOCAL_MODULE 和 LOCAL_SRC_FILES 赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure><h2 id="2-3-BUILD-STATIC-LIBRARY"><a href="#2-3-BUILD-STATIC-LIBRARY" class="headerlink" title="2.3 BUILD_STATIC_LIBRARY"></a>2.3 BUILD_STATIC_LIBRARY</h2><p>用于编译静态库的 BUILD_SHARED_LIBRARY 的变体。编译系统不会将静态库复制到您的项目&#x2F;软件包中，但可以使用静态库编译共享库（请参阅下文的 LOCAL_STATIC_LIBRARIES 和 LOCAL_WHOLE_STATIC_LIBRARIES）。使用此变量的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(BUILD_STATIC_LIBRARY)</span><br></pre></td></tr></table></figure><p>静态库变量会导致编译系统生成扩展名为 .a 的库</p><h2 id="2-4-PREBUILT-SHARED-LIBRARY"><a href="#2-4-PREBUILT-SHARED-LIBRARY" class="headerlink" title="2.4 PREBUILT_SHARED_LIBRARY"></a>2.4 PREBUILT_SHARED_LIBRARY</h2><p>指向用于指定预编译共享库的编译脚本。与 BUILD_SHARED_LIBRARY 和 BUILD_STATIC_LIBRARY的情况不同，这里的 LOCAL_SRC_FILES 值不能是源文件，而必须是指向预编译共享库的一个路径，例如 foo&#x2F;libfoo.so。使用此变量的语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(PREBUILT_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure><h2 id="2-5-PREBUILT-STATIC-LIBRARY"><a href="#2-5-PREBUILT-STATIC-LIBRARY" class="headerlink" title="2.5 PREBUILT_STATIC_LIBRARY"></a>2.5 PREBUILT_STATIC_LIBRARY</h2><h1 id="3-目标信息变量"><a href="#3-目标信息变量" class="headerlink" title="3 目标信息变量"></a>3 目标信息变量</h1><h2 id="3-1-TARGET-ARCH"><a href="#3-1-TARGET-ARCH" class="headerlink" title="3.1 TARGET_ARCH"></a>3.1 TARGET_ARCH</h2><p>编译系统解析此 <code>Android.mk</code> 文件时面向的 CPU 系列。此变量是 <code>arm</code>、<code>arm64</code>、<code>x86</code> 或 <code>x86_64</code>之一。<br>编译系统解析此 Android.mk 文件时面向的 Android API 级别编号。例如，Android 5.1 系统映像对应于 Android API 级别 22：android-22。如需平台名称和对应 Android 系统映像的完整列表，请参阅 Android NDK 原生 API。以下示例演示了使用此变量的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(TARGET_PLATFORM),android-22)</span><br><span class="line">        # ... do something ...</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>编译系统解析此 Android.mk 文件时面向的 Android API 级别编号。例如，Android 5.1 系统映像对应于 Android API 级别 22：android-22。如需平台名称和对应 Android 系统映像的完整列表，请参阅 Android NDK 原生 API。以下示例演示了使用此变量的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(TARGET_ARCH_ABI),arm64-v8a)</span><br><span class="line">      # ... do something ...</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><table><thead><tr><th>CPU和架构</th><th>设置</th></tr></thead><tbody><tr><td>ARMv7</td><td>armeabi-v7a</td></tr><tr><td>ARMv8 AArch64</td><td>arm64-v8a</td></tr><tr><td>i686</td><td>x86</td></tr><tr><td>x86-64</td><td>x86_64</td></tr></tbody></table><h1 id="4-模块描述变量"><a href="#4-模块描述变量" class="headerlink" title="4 模块描述变量"></a>4 模块描述变量</h1><p>每个模块描述都应遵守以下基本流程：</p><ol><li>使用 CLEAR_VARS 变量初始化或取消定义与模块相关的变量。</li><li>   为用于描述模块的变量赋值。</li><li>   使用 BUILD_XXX 变量设置 NDK 编译系统，使其将适当的编译脚本用于该模块。</li></ol><p>LOCAL_PATH<br>此变量用于指定当前文件的路径，必须在Andorid.mk文件开头定义此变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH :=$(call my-dir)</span><br></pre></td></tr></table></figure><p>此变量用于存储模块名称。指定的名称必须唯一，并且不得包含任何空格。必须在包含任何脚本（CLEAR_VARS 的脚本除外）之前定义此变量。无需添加 lib 前缀或者 .so 或 .a 文件扩展名；编译系统会自动进行这些修改。在整个 Android.mk 和 Application.mk 文件中，请通过未经修改的名称引用模块。例如，以下行会导致生成名为 libfoo.so 的共享库模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := &quot;foo&quot;</span><br></pre></td></tr></table></figure><p>如果希望生成的模块使用除“lib + LOCAL_MODULE 的值”以外的名称，您可使用 LOCAL_MODULE_FILENAME 变量为生成的模块指定自己选择的名称。<br>此可选变量使您能够替换编译系统为其生成的文件默认使用的名称。例如，如果 LOCAL_MODULE 的名称为 foo，您可以强制系统将它生成的文件命名为 libnewfoo。以下示例演示了如何完成此操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := foo</span><br><span class="line">    LOCAL_MODULE_FILENAME := libnewfoo</span><br></pre></td></tr></table></figure><p>对于共享库模块，此示例将生成一个名为 libnewfoo.so 的文件。<br>注意：您无法替换文件路径或文件扩展名<br><strong>LOCAL_SRC_FILES</strong><br>此变量包含编译系统生成模块时所用的源文件列表。只列出编译系统实际传递到编译器的文件，因为编译系统会自动计算所有相关的依赖关系。请注意，您可以使用相对（相对于 LOCAL_PATH）和绝对文件路径。<br>注意：务必在编译文件中使用 Unix 样式的正斜杠 (&#x2F;)。编译系统无法正确处理 Windows 样式的反斜杠 ()。<br><strong>LOCAL_CPP_EXTENSION</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_EXTENSION := .cxx</span><br><span class="line">LOCAL_CPP_EXTENSION := .cxx .cpp .cc</span><br></pre></td></tr></table></figure><p>例如，要指明您的代码使用 RTTI（运行时类型信息），请输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_FEATURES := rtti</span><br></pre></td></tr></table></figure><p>要指明您的代码使用 C++ 异常，请输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_FEATURES := exceptions</span><br></pre></td></tr></table></figure><p>您还可以为此变量指定多个值。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您还可以为此变量指定多个值。例如：</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2024/11/10/%E6%90%AD%E5%BB%BA/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/11/10/%E6%90%AD%E5%BB%BA/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>hexo 博客的搭建要依赖nodejs的组件<br>直接去官网nodejs.org下载即可<br>在浏览器中输入<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a><br>下载添加到环境变量中即可<br>win10 用户的环境变量和系统变量都添加然后重启就行.<br>因为我也不知道怎么让win10的环境变量生效,对于linux来说只要bash一下就可以了.</p><p>下载完验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">v22.11.0</span><br><span class="line">npm -v</span><br><span class="line">10.9.0</span><br></pre></td></tr></table></figure><p>打印出来node的版本信息,然后更换镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>用cnpm代替npm安装hexo架构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli  </span><br></pre></td></tr></table></figure><p>查看hexo的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>准备工作做的差不多了,该开始搭建了<br>创建一个你自己的文件，我这边是直接创建了blog文件<br>然后进入到这个文件中做初始化即可,这个要等等,不一定能拉全或者拉下来，可能还要改host文件.忘了以后再说</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>基础操作<br>启动默认端口是本地的4000端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问即可<a href="http://localhost:4000/">http://localhost:4000/</a><br>hexo init的时候回创建一个默认的markdown文件.<br>最常用的就是hexo g 生成静态文件<br>在hexo g之前先hexo clean一下,清除静态文件<br>然后hexo s查看改动后的效果</p><h1 id="托管"><a href="#托管" class="headerlink" title="托管"></a>托管</h1><p>github pages 托管<br>自检一个githu仓库，然后命名为username.github.io<br>hexo d 部署<br>要用hexo d部署的话,需要配置_config.yml文件,并且<br>要安装hexo-deployer-git<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件<br>这样子后我们再去配置_config.yml文件<br>在如下的位置添加自己部署的仓库和分支,然后hexo d部署即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span>  <span class="string">https://github.com/JoeForkYou/JoeForkYou.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>hexo d部署后,需要等待一段时间才能生效.<br>要访问的话直接输入类似我这种格式:<br><a href="https://joeforkyou.github.io/">https://joeforkyou.github.io/</a><br>自此一个简单的静态博客就搭建好了<br>搭建完后续的工作就是建立分类和搜索索引,这个我打算单独写一篇文章</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mtk_fd参数说明</title>
      <link href="/2024/11/10/Android/mtk-fd%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/11/10/Android/mtk-fd%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参数说明"><a href="#1-参数说明" class="headerlink" title="1 参数说明"></a>1 参数说明</h1><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;custom&#x2F;mt6765&#x2F;hal&#x2F;camera&#x2F;camera_custom_fd.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera_custom_fd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fd_CustomizeData</span><span class="params">(FD_Customize_PARA  *FDDataOut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FDDataOut-&gt;FDThreadNum = <span class="number">1</span>;</span><br><span class="line">    FDDataOut-&gt;FDThreshold = <span class="number">256</span>;</span><br><span class="line">    FDDataOut-&gt;MajorFaceDecision = <span class="number">1</span>;</span><br><span class="line">    FDDataOut-&gt;OTRatio = <span class="number">1088</span>;</span><br><span class="line">    FDDataOut-&gt;SmoothLevel = <span class="number">8</span>;</span><br><span class="line">    FDDataOut-&gt;Momentum = <span class="number">0</span>;</span><br><span class="line">    FDDataOut-&gt;MaxTrackCount = <span class="number">10</span>;</span><br><span class="line">    FDDataOut-&gt;FDSkipStep = <span class="number">2</span>;</span><br><span class="line">    FDDataOut-&gt;FDRectify = <span class="number">10</span>;</span><br><span class="line">    FDDataOut-&gt;FDRefresh = <span class="number">3</span>;</span><br><span class="line">    FDDataOut-&gt;SDThreshold = <span class="number">69</span>;</span><br><span class="line">    FDDataOut-&gt;SDMainFaceMust = <span class="number">1</span>;</span><br><span class="line">    FDDataOut-&gt;SDMaxSmileNum = <span class="number">3</span>;</span><br><span class="line">    FDDataOut-&gt;GSensor = <span class="number">1</span>;</span><br><span class="line">    FDDataOut-&gt;FDModel = <span class="number">1</span>;</span><br><span class="line">    FDDataOut-&gt;OTFlow = <span class="number">1</span>;  <span class="comment">//0:Original Flow (FDRefresh:60)  , 1:New Flow (FDRefresh:3)</span></span><br><span class="line">    FDDataOut-&gt;UseCustomScale = <span class="number">1</span>;</span><br><span class="line">    FDDataOut-&gt;FDSizeRatio = <span class="number">0.0</span>;  <span class="comment">// float:0~1</span></span><br><span class="line">    FDDataOut-&gt;SkipPartialFD = <span class="number">0</span>;</span><br><span class="line">    FDDataOut-&gt;SkipAllFD = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较常客制化的一些值及其意义：</p><p><strong>FDThreshold</strong> ： tune FD detection rate and false positive rate 。值越大代表检测的越严格。</p><p><strong>MajorFaceDecision</strong> ： 决定 face 排列方式。 value &#x3D; 0 or 1，value &#x3D; 0，则以Face Size的大小作为检测标准，也就是优先检测最大的人脸。value &#x3D; 1，优先检测在画面中心的人脸。Face AE,AF会参考Major Face资讯 。</p><p><strong>SmoothLevel</strong>：  决定人脸框的移动速度。value: 8~16 。值越大，跟随感越慢。 会把前面value的值平均作为下一次移动的参考。value值越大，人脸框移动会smooth，若人脸移动速度太快，则会出现人脸框跳动的情形。</p><p><strong>MaxTrackCount</strong>： 当人脸 lose 时，会用 tracking 机制继续 keep 的帧数。 </p><p><strong>GSensor</strong>： 是否使用 GSensor 资讯(AP带下来)。如果为0，则会做四个角度轮流侦测，initial detection time 会变慢。</p><p><strong>OTFlow</strong>： 只能是 1 且必须是 1 。</p><p><strong>FDSizeRatio</strong>： 用来设置过滤图中某个比例 以下的人脸。</p><p><strong>FDThreadNum</strong>：value 值增大时时会加大cpuloading，相对的检测Face的速度也快，该Thread主要跑的是FD Algo 。</p><p><strong>OTRatio</strong>:value越大，当周围环境change时，人脸框越不容易fail，缺点是可能追踪到不是人脸的物体 。</p><p><strong>Momentum</strong>:值可以是 0~3 。 0 &#x3D; force to project direction ；3 &#x3D; no reference project direction</p><p><strong>FDSkipStep</strong>:跳点，为了提高SW FD的performance 。</p><p><strong>FDRefresh</strong>:不是每一帧都做FD，若检测到Face后，接下来会做Face Tracking，若value &#x3D; 3，则做3次FaceTracking（几毫秒可以做</p><p>一次）。</p><p><strong>SDMainFaceMust</strong> :value &#x3D; 0 or 1，为0则会检测前面三张Face；为1，则需要根据MajorFaceDecision 的值确定，可能不会起作用 。</p><p><strong>FDModel</strong> :FD的核心是用某种算法training出来的model，不同的database或参数就会training出不同的model，也可以理解为侧重点不同。 </p><p>建议不要修改 OTRatio 、SmoothLevel 、FDRectify ，会影响 tracking。</p>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyton基础速通</title>
      <link href="/2024/11/10/Python/pyton%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A/"/>
      <url>/2024/11/10/Python/pyton%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h1><h2 id="1-1-输出"><a href="#1-1-输出" class="headerlink" title="1.1 输出"></a>1.1 输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字是%s,我的国籍是%s&quot;</span>%(<span class="string">&quot;JoeNero&quot;</span>,<span class="string">&quot;中国&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=%d&quot;</span>%age)</span><br></pre></td></tr></table></figure><h2 id="1-2-输入"><a href="#1-2-输入" class="headerlink" title="1.2 输入"></a>1.2 输入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您刚才输入的密码是&quot;</span>,password)</span><br></pre></td></tr></table></figure><h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#单行注释</span></span><br></pre></td></tr></table></figure><h2 id="1-4-流程控制"><a href="#1-4-流程控制" class="headerlink" title="1.4 流程控制"></a>1.4 流程控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">  执行语句</span><br><span class="line"><span class="keyword">elif</span> 条件:</span><br><span class="line">  执行语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> 执行语句</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">10</span></span><br><span class="line">  a++</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line">  a = [<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>]</span><br><span class="line"> <span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        <span class="built_in">print</span>(i,a[i])</span><br></pre></td></tr></table></figure><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_str = <span class="string">&quot;I said \&quot;I like you \&quot;&quot;</span> <span class="comment">#   \&quot;转义输出&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_str)</span><br></pre></td></tr></table></figure><p>输出打印字符串的片段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;chengdu&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">7</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">6</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>+<span class="string">&quot;123&quot;</span>) <span class="comment">#字符串链接</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cheng</span><br><span class="line">cheng</span><br><span class="line">hnd</span><br><span class="line">u</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\n&quot;</span>)  <span class="comment">#\n转义字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;hello\n&quot;</span>) <span class="comment">#加r使转义字符失效</span></span><br></pre></td></tr></table></figure><h1 id="3-元组"><a href="#3-元组" class="headerlink" title="3 元组"></a>3 元组</h1><p>元组是不允许修改的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = () <span class="comment">#创建空的元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup1))</span><br><span class="line"></span><br><span class="line">tup2 =(<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup2))</span><br></pre></td></tr></table></figure><h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h1 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h1><h2 id="5-1-打开"><a href="#5-1-打开" class="headerlink" title="5.1 打开"></a>5.1 打开</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;test.txt&quot;,&quot;w&quot;) #打开文件.w模式，写模式</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello world JoeNero&quot;)  #将字符串写入文件中哦</span><br><span class="line"></span><br><span class="line">f = open(&quot;test.txt&quot;,&quot;r&quot;) #打开文件.r模式，</span><br><span class="line">content = f.read(5) #读取五个字符</span><br><span class="line">print(content)</span><br><span class="line">f.close() #关闭文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th></th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件.文件的指针会放在文件的开头。这是默认模式</td></tr><tr><td>w</td><td>打开一个文件只用于写入.如果该文件已存在则将其覆盖.如果该文件不存在.则创建新文件</td></tr><tr><td>a</td><td>打开一个文件用于追加.如果该文件已经存在.文件指针会放在文件的结尾<br>如果该文件不存在,创建新文件进行写入</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于写入.文件指针会放在文件的开头.这是默认模式</td></tr><tr><td>wb</td><td>以二进制的格式打开一个文件只用于写入.如果该文件存在，则会将其覆盖.如果文件不存在，创建新文件</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加.<br>如果该文件存在，文件指针将会放在文件的结尾.也就是说新的内容会被写入到以有内容之后.如果文件不存在,创建新文件进行写入</td></tr><tr><td>r+</td><td>打开一个文件用于读写.文件指针将会放在文件的开头</td></tr><tr><td>w+</td><td>打开一个文件用于读写.如果该文件已经存在，则覆盖.如果该文件不存在.创建新文件</td></tr><tr><td>a+</td><td>打开一个文件用于读写.如果该文件已经存在.文件指针将会放在文件的结尾.<br>文件打开时会追加模式.如果该文件不存在,创建新文件用于读写</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写.文件指针将会放在文件的开头</td></tr></tbody></table><h2 id="5-2-读取"><a href="#5-2-读取" class="headerlink" title="5.2 读取"></a>5.2 读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readlines() <span class="comment">#一次性读取全部文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(content)</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> content:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d:%s&quot;</span>%(i,temp))</span><br><span class="line">    i +=<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;test1.txt&quot;</span>) <span class="comment">#重命名</span></span><br></pre></td></tr></table></figure><h1 id="6-错误和异常"><a href="#6-错误和异常" class="headerlink" title="6 错误和异常"></a>6 错误和异常</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> IOErrpr:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> IOErrpr:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件关闭&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用基础命令</title>
      <link href="/2024/11/10/Linux/linux%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/11/10/Linux/linux%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>这个文件为系统apt 管理软件包的文件.图形化界面操作多了,就差不多忘记终端的以下基础.</p><p>知道这个文件就好,可以更改,也可以图形界面更改.</p><p>我们所使用的ubuntu系统是有自带的系统终端的. 我们平时操作都是在其中的桌面终端上操作的.一般是GNOME和KDA这种.</p><pre><code>/etc/apt/sources.list</code></pre><h1 id="1-内存"><a href="#1-内存" class="headerlink" title="1 内存"></a>1 内存</h1><pre><code>df -h #查看系统各个磁盘的占用情况</code></pre><p>du 是disk usage 的简称 用来显示目录或文件的大小,查找文件和目录的磁盘使用情况的命令.</p><pre><code>du -sh 查看当前文件所占用的空间du -sh * 查看当前文件夹下所有文件夹所占用的空间</code></pre><h1 id="2-adb"><a href="#2-adb" class="headerlink" title="2 adb"></a>2 adb</h1><p>adb (Android Debug Bridge)是一种允许模拟器或已经连接的Android设备进行通信的命令行共军,它可以为各种设备操作提供便利.如安装和调试应用.</p><p>查询已经连接的设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>adb 调佣图片命令。 前提要在此路径下存在对应的图. 不然会调用起损坏的图片</p><pre><code>adb shell am start -a android.intent.action.VIEW -t image/png -d file://mnt/sdcard/Download/scene1_1.png</code></pre><p>拍照,拍照时间的keyevent 为27,所以 输入以下的命令就可以实现拍照.</p><pre><code>adb shell input keyevent 27</code></pre><p>adb 查看当前包名和activity.  这个可以配合调apk来使用.我们一般要先确定调用的是哪个apk和activity</p><pre><code>adb shell dumpsys window |grep mCurrentFocus</code></pre><p>输出打出以下的信息</p><pre><code>  mCurrentFocus=Window&#123;90dd2d3 u0 com.sec.android.app.camera/com.sec.android.app.camera.Camera&#125;</code></pre><p>那么adb 启动apk的方式</p><pre><code>adb shell am start -n com.sec.android.app.camera/com.sec.android.app.camera.Camera</code></pre><p>adb 回到home</p><pre><code>adb shell input keyevent 3</code></pre><p>查看设备安装的第三方应用</p><pre><code>adb shell pm list packages -3</code></pre><p>查看系统安装的应用</p><pre><code>adb shell pm list packages -s</code></pre><p>adb install</p><pre><code>-l 将应用安装到保护目录/mnt/asec-r 允许覆盖安装-t 允许安装AndroidManifest.xml里application 指定android:testOnly=&quot;true&quot;的应用-s 将应用安装到sdcard-d 允许降级覆盖安装</code></pre><p>adb install 实际分三步完成:<br>1.push apk 文件到&#x2F;data&#x2F;local&#x2F;tmp<br>2.调用pm install 安装<br>3.删除&#x2F;data&#x2F;local&#x2F;tmp 下的对应apk文件</p><p>与install 相反的是uninstall</p><p>adb uninstall  -k package-name</p><p>清楚应用缓存</p><p>adb shell pm clear &lt;package-name&gt;</p><p>查看应用安装路径</p><p>adb shell pm path &lt;package-name&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 26 #控制电源键，一般来控制息屏和亮屏</span><br><span class="line">adb shell input keyevent 82 #菜单键,用户版本才用到</span><br><span class="line">adb shell input keyevent 4 #返回键</span><br><span class="line">adb shell input keyevent 24 #增加音量</span><br><span class="line">adb shell input keyevent 25 #降低音量</span><br><span class="line">adb shell input keyevent 164 #静音</span><br><span class="line">adb shell input keyevent 224 #亮屏</span><br><span class="line">adb shell input keyevent 223 #熄屏</span><br></pre></td></tr></table></figure><p>查看屏幕分辨率</p><pre><code>adb shell wm size</code></pre><p>查看屏幕设备密度</p><pre><code>adb shell wm density</code></pre><h1 id="3-CP"><a href="#3-CP" class="headerlink" title="3 CP"></a>3 CP</h1><p>cp 是拷贝命令.</p><p>要是要拷贝文件只要加cp -r 即可</p><h1 id="4-VIM"><a href="#4-VIM" class="headerlink" title="4 VIM"></a>4 VIM</h1><p>vim 是一个比较好用的文本编辑器</p><p>正常调用vim 就即可. vim 后面接对应的文件,并且vim 打开文件时会在本地创建一个bak文件,用于奔溃的时候的备份.</p><p>而且vim 可以更改到系统级别的文件.意味着 什么文件都能改,</p><p>vim 的模式有很多种</p><p>一般我们用到插入(可编辑)模式和命令模式</p><p>输入i 就进去插入模式,可以进行文本编辑</p><p>输入o 插入到当前光标下行并且进入到插入模式.</p><p>输入esc就退出当前的模式，回到命令模式</p><p>在命令模式下直接输入,就会查找对应的文本. 按n 即可查找下一个  ,以下是一些常用的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/文本内容</span><br><span class="line">:wq  #保存并退出</span><br><span class="line">:w!  #强制保存</span><br><span class="line">:q   #退出</span><br><span class="line">:q!  #强制退出</span><br><span class="line">:w ! sudo tee # 保存只读文件</span><br><span class="line">:u  #撤掉当前的修改</span><br><span class="line">:行数 #跳转到对应的行数</span><br><span class="line">dd #删除当前行的内容</span><br></pre></td></tr></table></figure><h1 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5 快捷键"></a>5 快捷键</h1><p>快捷键可以自己定义</p><p>当然系统默认好用快捷键如下:</p><pre><code>ctrl + shift +c #复制ctrl + shift +v #粘贴ctrl + shift + t #在当前终端栏边上打开终端  一般我不用ctrl +alt + t  那样打开的终端 很乱 ctrl + c #中断终端操作ctrl + d #退出当前窗口ctrl + q #关ctrl + r #查询调用历史输入的命令</code></pre><h1 id="6-shell"><a href="#6-shell" class="headerlink" title="6 shell"></a>6 shell</h1><p>我们这边提到的是<strong>命令行式shell</strong>,不是gnome KDE那种桌面式终端.</p><p>shell类似于DOS下的COMMAND.COM和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序.</p><p>创建后缀为.sh</p><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p><p>业界所说的 shell 通常都是指 shell 脚本，但要知道，shell 和 shell script 是两个不同的概念。</p><p>由于习惯的原因，简洁起见，都是指 shell 脚本编程，不是指开发 shell 自身。</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;</code></pre><p>#!  是一个约定的标记,它告诉系统这个脚本需要用什么解释器来执行,即使用哪一种shell</p><p>echo 命令用于向窗口输出文本.</p><p>作为可执行程序运行</p><pre><code>chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本</code></pre><h2 id="6-1-变量"><a href="#6-1-变量" class="headerlink" title="6.1 变量"></a>6.1 变量</h2><pre><code>your_name=&quot;somethings&quot;echo $your_nameecho$&#123;your_name&#125;</code></pre><p>循环打印变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for skill in JOJO nONONONO AMAZON java;do</span><br><span class="line">echo &quot;I am good at $&#123;skill&#125; Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="6-2-字符"><a href="#6-2-字符" class="headerlink" title="6.2 字符"></a>6.2 字符</h2><p>单引号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure><p>双引号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;JoeNero&quot;</span><br><span class="line">str=&quot;hello ,I know you are \&quot;$your_name\&quot;! \n&quot;</span><br><span class="line">echo -e $str</span><br></pre></td></tr></table></figure><p>拼接字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用双引号拼接</span></span><br><span class="line">your_name=&#x27;JoeNero&#x27;</span><br><span class="line">greeting=&quot;hello ,&quot;$your_name&quot;!&quot;</span><br><span class="line">greeting_1=&quot;hello,$&#123;your_name&#125;!&quot;</span><br><span class="line">echo $greeting $greeting_1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用单引号拼接</span></span><br><span class="line">greeting_2=&#x27;hello ,&#x27;$your_name&#x27;!&#x27;</span><br><span class="line">greeting_3=&#x27;hello,$&#123;your_name&#125;!&#x27;</span><br><span class="line">echo $greeting_2 $greeting_3</span><br></pre></td></tr></table></figure><p>获取字符串长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line"><span class="meta prompt_">echo$</span><span class="language-bash">&#123;#string&#125;</span></span><br></pre></td></tr></table></figure><p>提取子字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125;#输出unoo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意第一个字符的索引值为0</span></span><br></pre></td></tr></table></figure><p>查找字字符串</p><p>查找字符i或o的位置(哪个字母先出现就计算哪个)</p><pre><code>string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io`</code></pre><h2 id="6-3-数组"><a href="#6-3-数组" class="headerlink" title="6.3 数组"></a>6.3 数组</h2><p>用括号来表示数组,数组元素用空格符号来分割.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">array_name=(1 2 3 4 5 6)</span><br><span class="line">array_name1=(</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">)</span><br><span class="line">array_name[0]=0</span><br><span class="line">array_name[1]=1</span><br><span class="line">array_name[2]=2</span><br></pre></td></tr></table></figure><p>读取数组的格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;数组名[下标]&#125;</span></span><br><span class="line">echo $&#123;array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-流控制"><a href="#6-4-流控制" class="headerlink" title="6.4 流控制"></a>6.4 流控制</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>for 循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>while语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>无线循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while:</span><br><span class="line">do </span><br><span class="line">command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><pre><code>while truedo     commanddone</code></pre><p>输入输出重定向文件在此不赘述</p><h1 id="7-LS"><a href="#7-LS" class="headerlink" title="7 LS"></a>7 LS</h1><p>ls 是list files的缩写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll -t # 按照时间排序呈现当前目录下的文件内容</span><br><span class="line">ll -a # 显示隐藏文件</span><br><span class="line">ll -Sh # 按照文件大小排序显示当前目录下的文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XTS基础汇总</title>
      <link href="/2024/11/10/GMS/XTS%E6%B1%87%E6%80%BB%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/10/GMS/XTS%E6%B1%87%E6%80%BB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>参考谷歌官网：<br><a href="https://source.android.google.cn/compatibility/tests/development">https://source.android.google.cn/compatibility/tests/development</a></p><h1 id="1-XTS-概述"><a href="#1-XTS-概述" class="headerlink" title="1 XTS 概述"></a>1 XTS 概述</h1><p>GMS全称为GoogleMobile Service，即谷歌移动服务。我们常说的XTS其实就谷歌认证<br>GMS是Google所提供的一系列移动服务，包括开发用的一系列服务和用户所用的Google Apps。<br>Maps与Location：地理位置相关服务，AOSP也包括一个简易的Location服务，这是升级版，有用但并非必要，国内也有百度、高德等提供了类似的API；<br>Games、Play Services、In-app Billing、Play Distribution：与Google Play相关的服务，毫无疑问这个在国内是用不到的，但如果要在Google Play上发布应用，则非常有用；**(GL和IN做大量测试的原因)** （GL 国外发型的版本: IN :印度发型的版本  有的项目是发往欧美或者东南亚的，都需要经过认证）<br>Google+、Drive、Cloud Platform、Cloud Messaging：与Google的社交网络和云平台相关的服务，前三个在国内也基本上用不到，第四个是推送服务对开发者非常有用，但国内有很多类似的第三方服务可替代；<br>Cast、Wallet、Ads：这里是Google推出的与Android平台关系不大的服务，Ads广告对开发者有用，但国内也有很多的移动广告平台和服务。<br>这些服务不是构建一个Android App所必需的，也可以使用其他的服务替代，因此，没有GMS对国内手机厂商影响没有想象那么大。**(CN少测的原因)**<br>Google Apps则包括Gmail、Google Maps等Google官方应用，这些系统应用对于一个完善的Android设备是很重要的，但是手机厂商也可以使用自己的或者第三方应用替代。<br>整个Android平台可以看成是：AOSP+GMS，AOSP（安卓开源项目）是所有手机厂商可以免费获得的开源代码，但GMS则需要Google同意授权才行。<br>Google给GMS认证设置了比较高的门槛。首先要通过CTS兼容性测试（Compatible Test Suite），一般而言所有的Android厂商都必须通过这个认证，否则会出现兼容性问题。这个认证一般由手机厂商自己做，然后提交结果给Google。<br><strong>AOSP是工具，GMS则是服务</strong></p><h2 id="1-1-CTS"><a href="#1-1-CTS" class="headerlink" title="1.1 CTS"></a>1.1 CTS</h2><p>谷歌官网:<br><a href="https://source.android.google.cn/compatibility/cts">https://source.android.google.cn/compatibility/cts</a></p><p>CTS是Compatibility Test Suite的缩写,即兼容测试，是Google为Android设备制造商免费提供的兼容性测试套件。</p><p>CTS 是一个自动化测试套件，包括两个主要的软件组件：</p><p>1.CTS Trade Federation</p><p>自动化测试框架会在桌面设备上运行，并管理测试执行情况。此框架可实现对多个被测设备 (DUT) 进行分片测试。您还可以利用套件重试功能仅重试失败的测试而不是完整的套件，从而大大减少重新运行所花的时间。</p><p>2.单独的测试用例会在 DUT 上执行。</p><p>测试用例采用 Java 语言编写为 JUnit 测试，并打包为 Android .apk 文件，以在实际目标设备上运行。</p><p>APP层跟Framework层在设计上是分开的，但通过CTS测试，确保了APP无Android Framework之间有一致的调用接口（API），这使得APP开发者编写的同一款程序可以运行在不同系统版本（向前兼容）、不同硬件平台、不同产商制造的不同设备上。<strong>如这个示例图.</strong></p><p><img src="https://i.loli.net/2021/11/13/UbfqzP8gvRhTpOy.png" alt="1.png"></p><p>CTS定义了众多Android设备必须满足的技术指标，以确保每台通过CTS认证的设备，都可以顺利运行Google Play中出售的软件。（并不是每个软件都可以在所有Android设备上运行，Google Play仅显示可以运行在该Android设备上的应用，并且还受到当地法律法规的限制。）<br><strong>CTS的目的就是让Android设备开发商能够开发出兼容性更好的Android设备。</strong></p><p>通过以上概述可以知道这些认证的本意是：</p><p>1.让APP提供更好的用户体验。用户可以选择更多的适合自己设备的APP。让APP更稳定。</p><p>2.让开发者设计更高质量的APP。</p><h2 id="1-2-GTS"><a href="#1-2-GTS" class="headerlink" title="1.2 GTS"></a>1.2 GTS</h2><p>GTS的全称是Google Mobile Services Test Suite，所谓的Google Mobile Services即谷歌移动服务<br>谷歌移动服务提供了Search、 Search by Voice、Gmail、Contact Sync、 Calendar Sync、Talk、 Maps、 Steet View、 YouTube、 Android Market (Play store)等服务，当用户使用谷歌时，谷歌可以把各种广告嵌入到谷歌的服务中。<br>这些服务依赖于网络.</p><h2 id="1-3-VTS"><a href="#1-3-VTS" class="headerlink" title="1.3 VTS"></a>1.3 VTS</h2><p>Android 目前有一个比较明显的缺点是<strong>设备升级到新版本系统所要花费的时间太长（比如从 Android 6.0 升级到 Android 7.0）</strong>。通常在由 Google 发布新版本的 AOSP 之后，还需要 SoC 厂商对 HAL 进行升级，以及 OEM 厂商对 HAL 和 Framework  进行升级后，用户才能在设备上收到 OTA 升级包的推送。低端一点的产品甚至在出厂后就不会再进行系统升级了。用户对此抱怨良多。反观竞争对手 iOS 在这方面就做得比较好（但这不代表我支持 iOS)<br> <strong>为了解决这个问题，于是 Google 发起了 Project  Treble 项目</strong>2017 年 5 月 12 日，官方在”Developers Blog”上向公众介绍了这一项目并宣布 Android  8.0 中将引入它，但从目前我拿到的描述 Project Treble 的相关文档的修订记录来看，这些文档最早的起草时间可以追溯到 2015 年 10 月 30 日。<br> 　　<strong>而 Project Treble 中最重要的就是新增了 Vendor Interface 这一概念，以及相应的 Vendor Test Suite (VTS) 测试。</strong></p><hr><p>Project Treble 中引入 Vendor Interface 的目的是将 Android Framework 与 HAL 分开，通过对Vendor Interface进行测试，确保同一个版本的Android Framework可以运行在不同的HAL上，或者Android Framework可以运行在同一个HAL，即保证HAL的向前兼容性。通过这样的Framework&#x2F;HAL分离设计和接口一致性保证，这就使得8.0版本之后的Android系统在进行升级时，可以直接对Framework进行升级而不用考虑HAL层的改动，从而缩短了用户手上设备得到系统升级OTA推送的时间。</p><h2 id="1-4-GSI"><a href="#1-4-GSI" class="headerlink" title="1.4 GSI"></a>1.4 GSI</h2><p>GSI是在VTS环境下用google img测试CTS用例,从andorid 11版本后面迁移道cts环境下跑测，是替换掉自己framework相关的内容，用谷歌原生的system.img</p><h2 id="1-5-CTS-V"><a href="#1-5-CTS-V" class="headerlink" title="1.5 CTS-V"></a>1.5 CTS-V</h2><p>CTS Verifier是CTS兼容性测试的补充。CTS检查的是可以自动化的API和功能，而CTS Verifier是测试在没有手动输入的静态设备上测试这些API和功能，例如音频质量，触摸屏，加速度计，相机等等.这边可以重点关注FOV和尺寸video相关的测试项.</p><h2 id="1-6-ITS"><a href="#1-6-ITS" class="headerlink" title="1.6 ITS"></a>1.6 ITS</h2><p>Android 相机图像测试套件 (ITS) 是 Android 兼容性测试套件 (CTS) 验证程序的一部分，其中包含用于验证图像内容的测试</p><p><code>scenes=sensor_fusion</code> </p><p>在传感器融合测试中，将分别针对 AR 和 VR 应用，测试相机和陀螺仪之间的时间戳差异，因此需要按特定轨迹移动相机。<br><code>REALTIME</code> 功能标记和 VR&#x2F;AR 应用要求相机&#x2F;陀螺仪的定时偏差小于 1 毫秒</p><p>ITS测试输出:</p><p>PASS：测试通过</p><p>FAIL：测试失败，必须修复</p><p>SKIP：跳过测试项</p><p>FAIL*：测试失败，目前可以不修复，但可能在未来的测试中变为强制性</p><p>注意:另外还有STS安全补丁包相关的测试,因为和camera无关,就没有提及,GTS大部分依赖的是服务，camera相关性低，也与我们无关,但是有camera测试项目,就顺带一提.</p><p>its测试的图表可以用另外一台平板电脑来提供</p><p><img src="https://i.loli.net/2021/11/29/JcXSDagpFMtvYfn.png" alt="平板要求.png"></p><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2 环境搭建"></a>2 环境搭建</h1><h2 id="2-1-CTS"><a href="#2-1-CTS" class="headerlink" title="2.1 CTS"></a>2.1 CTS</h2><p>CTS环境搭建只需要一个jdk和aapt</p><p>前者这个比较大问相关人员拿吧.<br>或者直接去官网拿对应的jdk:</p><p>这里放一个11版本的下载链接</p><p><a href="https://www.oracle.com/java/technologies/javase/javase11-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase11-archive-downloads.html</a></p><p>andorid 11后面要求的jdk&gt;&#x3D;11  </p><p>然后vim ~&#x2F;.bashrc 把对应的路径配置写入后:wq保存退出,source ~&#x2F;.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">jdk</span></span><br><span class="line">export JAVA_HOME=/home/ubuntu/Jdk11</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>然后用以下命令检查jdk版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>输出打印</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;11&quot; 2018-09-25</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11+28)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure><p>说明jdk配置成功</p><p>cts包下载路径:</p><p><a href="https://source.android.google.cn/compatibility/cts/downloads">https://source.android.google.cn/compatibility/cts/downloads</a></p><p>CTS会使用aapt工具,如下命令安装aapt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install aapt</span><br></pre></td></tr></table></figure><p>aapt 是什么？谷歌官网有很详细的介绍.</p><p><a href="https://developer.android.google.cn/studio/command-line/aapt2?hl=zh-cn">https://developer.android.google.cn/studio/command-line/aapt2?hl=zh-cn</a></p><p>AAPT2（Android 资源打包工具）是一种构建工具. 这里理解下输出的报告就是通过这个工具构建的,当然不仅仅是报告.</p><p>两种皆可以直接命令装.检查是否搭建成功直接看基本操作命令中CTS单跑一项即可</p><h2 id="2-2-ITS-VTS"><a href="#2-2-ITS-VTS" class="headerlink" title="2.2 ITS&#x2F;VTS"></a>2.2 ITS&#x2F;VTS</h2><p>its和vts同样依赖python包.具体另外有个XTS基础有单独的操作说明.还有GTS需要连接外网,<br>VTS 不依赖网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install python-protobuf</span><br><span class="line">sudo apt-get install protobuf-compiler</span><br><span class="line">sudo apt-get install python-virtualenv</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo apt-get install python-numpy</span><br><span class="line">sudo apt-get install python-scipy</span><br><span class="line">sudo apt-get install python-matplotlib</span><br><span class="line">sudo apt-get install python-opencv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pip install pyserial</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pip install serial <span class="comment">#如果这两个命令不行就用下面这两个命令.</span></span></span><br><span class="line">sudo apt install python-pyudev</span><br><span class="line">sudo apt install python-serial</span><br></pre></td></tr></table></figure><p>因为ubuntu16和18以及其他系统默认带的python包不一致，请根据实际情况下载其他相关的python</p><p>以上完成后直接看基本操作命令ITS部分</p><p>其他测试项不依赖任何环境.</p><h1 id="3-基本操作命令"><a href="#3-基本操作命令" class="headerlink" title="3 基本操作命令"></a>3 基本操作命令</h1><p>谷歌官网：</p><p><a href="https://source.android.google.cn/compatibility/cts/command-console-v2#ctsv2_reference">https://source.android.google.cn/compatibility/cts/command-console-v2#ctsv2_reference</a></p><p>手机开发者选项打开，永不锁屏，充电不休眠这些打开.因为测试过程中长时间未操作会影响测试结果的</p><h2 id="3-1-CTS"><a href="#3-1-CTS" class="headerlink" title="3.1 CTS"></a>3.1 CTS</h2><p>进入到cts的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd android-cts/tools/</span><br><span class="line">./cts-tradefed   #进入到cts的终端命令里</span><br></pre></td></tr></table></figure><p>相关的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run cts -m CtsCameraTestCases #cts整跑三个abi的命令</span><br></pre></td></tr></table></figure><p>我们一般debug只要跑一个abi,使用的cts-dev,会跑测当前设备对应的abi.</p><p>上述命令会直接跑侧当前环境下所有相关的abi.</p><p>出报告还是要整跑三个abi的</p><p>谷歌原话是:<br><strong>On 64-bit devices, run the test against only the 32-bit or 64-bit ABI</strong></p><p><strong>运行默认的 CTS 计划（即完整的 CTS 调用），但跳过前提条件以缩减运行时间，从而对新测试执行迭代开发。这会绕过对设备配置的验证和设置（例如推送媒体文件或检查 Wi-Fi 连接），就如同使用了 –skip-preconditions 选项。此命令还会跳过设备信息收集和所有系统状态检查工具。它还仅在单个 ABI 上运行测试。对于设备验证，请忽略此优化操作并添加所有前提条件和检查。有关要排除的内容，请参阅 cts-dev.xml。</strong></p><p>在测试过程中，CTS 控制台可以接受其他命令。</p><p>如果没有连接任何设备，CTS 台式机（或主机）会等到设备连接后再启动测试。如果连接了多台设备，则 CTS 主机将自动选择一台设备。</p><p>它还仅在单个 ABI 上运行测试<br>cts-dev 是跑测当前设备默认abi.</p><p>abi(Application Binary Interface，ABI)：<br>应用程序二进制接口<br>默认情况下，CTS 会为设备支持的每个 ABI 运行一次测试。</p><p>只跑一个命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run cts-dev -m CtsCameraTestCases#单跑当前设备默认Module命令</span><br><span class="line">run cts-dev -m CtsCameraTestCase --shard-count 3 -s sn1 -s sn2 -s sn3 #多台设备跑测一个报告</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Android12 以后建议用subplan的方式创建计划表 去跑测试，别用cts-dev的方式.</span></span><br></pre></td></tr></table></figure><p>单跑一个测试项命令.加参数-t -s -m 还有list(l d) 这些相关的命令其他XTS测试是一样的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run cts-dev -m CtsCameraTestCases -t</span><br><span class="line">android.hardware.camera2.cts.RecordingTest#testVideoSnapshot</span><br></pre></td></tr></table></figure><p>如果有多个设备挂跑的时候, 用以下命令 加-s 设备序列号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run cts-dev -m CtsCameraTestCases -s 141190ce0312</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb device #查看设备序列号</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l r #list result查看报告结果状态,如下图能看到session 为O(记住要考)</span><br><span class="line">Pass测试项为569</span><br><span class="line">Fail项目为0 </span><br><span class="line">完成测试Module为1</span><br><span class="line">报告结果时间和名字以及其他一些相关信息.</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/15/ZifKRjmh5V7pa6r.png" alt="ITS.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l d #list device列举设备信息，主要关注Allocation 下设备的状态Available为可以使用的状态.</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/15/PQeURF45zWOZxEw.png" alt="ld.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l c #查看运行的command命令</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/15/4NfjRGVbmiqvDtW.png" alt="lc.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l i #查看当前命令运行的时间</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/15/G7Pbes18xp3vKqC.png" alt="li.png"></p><p>一般跑测没有那么快一下子全PASS,很有可能受到环境或者其他因素影响导致Fail,所以需要retry</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run retry --retry &lt;session-number&gt; #retry 格式</span><br><span class="line">run retry --retry 0 #这个就是l r 里面报告里面的session,重跑你fail的报告即可，注意版本和机器设备必须是之前出报告的同一个，不然重跑不起来.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当然你有了这个报告,也可以在其他电脑上重跑</span></span><br></pre></td></tr></table></figure><p>生成的报告路径在android-cts&#x2F;results</p><p>subplan的方式进行跑测:</p><p>什么是subplan? 是自己创建的跑测计划,一般用于跑测.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add subplan --session 10 -n cts_dev --result-type failed #创建一个名未cts_dev的 session10中跑测失败的计划表</span><br></pre></td></tr></table></figure><pre><code>#这是参数说明add s[ubplan]: create a subplan from a previous session    Available Options:        --session &lt;session_id&gt;: The session used to create a subplan        --name/-n &lt;subplan_name&gt;: The name of the new subplan        --result-type &lt;status&gt;: Which results to include in the subplan. One of passed, failed, not_executed. Repeatable</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run cts --subplan cts_dev -s 81926A8J00072 #这是subplan的使用说明,在上述已经创建了一个名未cts_dev的计划，跑测该计划中的内容</span><br></pre></td></tr></table></figure><p>打开test_result.html即可,其他测试项除ITS外都是在相似的文件路劲下</p><p>一般cts debug都是到这个路劲android-cts&#x2F;testcases</p><p>-t -g 强制下载并且打开相关权限.打开这个可以不用去操作打开apk的权限了.可以直接运行相关的命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -t -g CtsCameraTestCases.apk</span><br></pre></td></tr></table></figure><p>然后需要进入到setting里面</p><p><img src="https://i.loli.net/2021/07/15/lEU6eTQmrWdApjN.png" alt="01.png"></p><p>选择app&amp;notifications</p><img src="https://i.loli.net/2021/07/16/CE4vAgwNjIbLpSR.png" alt="01.png" style="zoom: 66%;" />选择App info<img src="https://i.loli.net/2021/07/16/UKrLbaGpwHCf5XO.png" alt="01.png" style="zoom:67%;" /><p>找到我们cts 测试apk,  android.camera.cts<br><img src="https://i.loli.net/2021/07/16/iAgW2XIExwnlsmz.png" alt="01.png" style="zoom:67%;" /></p><p>把所有的权限都打开</p><img src="https://i.loli.net/2021/07/16/d6lYgqXWzbNLv2a.png" alt="01.png" style="zoom:67%;" /><p>然后在终端上运行以下类似格式的命令就可以了.  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell am instrument -e class android.hardware.camera2.cts.RecordingTest#testVideoSnapshot --abi arm64-v8a -w android.camera.cts/androidx.test.runner.AndroidJUnitRunner</span><br><span class="line"></span><br><span class="line">adb shell am instrument -e class 对应的测试项目 --abi arm64-v8a -w android.camera.cts/androidx.test.runner.AndroidJUnitRunner</span><br></pre></td></tr></table></figure><p>运行结果如下即便就是PASS,否则为Fail</p><p><img src="https://i.loli.net/2021/07/16/vtLFJ5Ec73OlX4Z.png" alt="01.png"></p><h2 id="3-2-VTS"><a href="#3-2-VTS" class="headerlink" title="3.2 VTS"></a>3.2 VTS</h2><p>vts需要连接外网,再一次强调.<br>查看gsi版本日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings system.img | grep ro.build.version.security_patch</span><br><span class="line">adb shell getprop ro.build.version.security_patch</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/15/Srp6vI2cX3RAb1O.png" alt="补丁包的时间.png"><br>预备准备好对应的system.img 和boot-debug.img</p><p>要刷入这两个镜像要先解锁设备.一般默认是上锁的无法烧录镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader # 进入fastboot模式</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有的项目解锁方式</span></span><br><span class="line">fastboot oem unlock</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有的项目解锁方式</span></span><br><span class="line">fastboot flashing unlock</span><br></pre></td></tr></table></figure><p>解锁完就能烧录对应的镜像,以下命令往下跑就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot fastboot</span><br><span class="line">fastboot flash system system.img # 需要进入fastboot 下烧录.bootloader下没有system的分区</span><br><span class="line">fastboot reboot bootloader</span><br><span class="line">fastboot flash boot boot-debug.img #boot 分区在bootloader模式下.</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p>进入到vts的tool目录下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vts-tradefed</span><br></pre></td></tr></table></figure><p>vts整跑命令,vts 我们就关注这三个模块的部分</p><p>注意，并不是三个都一定存在的项目.需要根据实际项目来看.</p><p>比如展讯平台上没有2_5的接口，所以实际无法跑测.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run vts --include-filter VtsHalCameraProviderV2_4Target --include-filter VtsHalCameraProviderV2_5Target --include-filter VtsHalCameraServiceV2_0Target --skip-preconditions</span><br><span class="line"></span><br><span class="line">run vts --skip-preconditions  --include-filter -m VtsHalCameraServiceV2_0TargetTest VtsHalCameraServiceV2_0Target</span><br></pre></td></tr></table></figure><p>单跑对应的模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run vts -m VtsHalCameraProviderV2_4Target -s 1769E47E</span><br><span class="line">run vts -m VtsHalCameraProviderV2_5Target -s 1769E47E</span><br><span class="line">run vts -m VtsHalCameraServiceV2_0Target -s 1769E47E</span><br></pre></td></tr></table></figure><p>单跑单个测试项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vts -m VtsHalCameraProviderV2_4Target -t CameraHidlTest.processCaptureRequestBurstISO(legacy/0)_64bit</span><br></pre></td></tr></table></figure><p>其他操作命令和CTS一样</p><h2 id="3-3-GSI"><a href="#3-3-GSI" class="headerlink" title="3.3 GSI"></a>3.3 GSI</h2><p>GSI也是要刷入system.img.但是不用刷boot.img.&#x2F;(andorid11后都要刷.)</p><p>一般system分区会做在fastboot 模式下，但是后来有的项目好像是得进bootloader刷system.这个要确定好，不然刷进去就无法<br>进入系统了.</p><p>GSI刷镜像按照如下的操作即可.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader #刷入对应的谷歌镜像system.img</span><br><span class="line">fastboot devices</span><br><span class="line">fastboot flashing unlock</span><br><span class="line">fastboot reboot fastboot</span><br><span class="line">fastboot erase system</span><br><span class="line">fastboot flash system system.img #谷歌官网获取</span><br><span class="line">fastboot -w</span><br><span class="line">fastboot reboot bootloader</span><br><span class="line">fastboot flashing unlock</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按音量上键</span></span><br><span class="line">fastboot flashing lock </span><br><span class="line">fastboot flashing unlock</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p>打开开发者选项 , 打开 stay awake 和 USB debugging<br>andorid 11 后 gsi 在 cts&#x2F;vts 的运行环境中跑测。</p><p>android10以前以及10版本都是在vts的运行环境中跑测试.11以及11以后谷歌将测试挪到了11中</p><p>GSI整跑命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run cts-on-gsi -m CtsCameraTestCases</span><br></pre></td></tr></table></figure><h2 id="3-4-ITS"><a href="#3-4-ITS" class="headerlink" title="3.4 ITS"></a>3.4 ITS</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1 准备"></a>1 准备</h3><p>我们可以编译对应的项目生成CtsVerifier.apk或者直接在ITS包里面把测试apk下载到手机中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mk -p 项目名字 -s -v userdebug -m mma -o cts/apps/CtsVerifier</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install CtsVerifier.apk</span><br></pre></td></tr></table></figure><p>进入到手机apk，所有的权限都打开.</p><p>操作步骤如下:</p><p><img src="https://i.loli.net/2021/07/15/lEU6eTQmrWdApjN.png" alt="01.png"></p><p>选择app&amp;notifications</p><img src="https://i.loli.net/2021/07/16/CE4vAgwNjIbLpSR.png" alt="01.png" style="zoom: 66%;" /><img src="https://i.loli.net/2021/07/16/UKrLbaGpwHCf5XO.png" alt="01.png" style="zoom:67%;" /><p>找到CTS Verifer 测试apk,</p><p><img src="https://i.loli.net/2021/07/16/2BM7Imz5KJV8pH1.png" alt="01.png"></p><p>打开其所有的权限即可<br><img src="https://i.loli.net/2021/07/16/ZsL7hkT2zERSu1v.png" alt="01.png"></p><h3 id="2-场景说明"><a href="#2-场景说明" class="headerlink" title="2 场景说明"></a>2 场景说明</h3><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>场景0</td><td>无任何要求</td></tr><tr><td>场景1</td><td>相机位于三脚架上, 指向一个静态场景, 其中包含灰色卡和白色背景, 在恒定 (稳定) 相对明亮的光照源下。这是 CTS 验证程序物理设置上面描述的场景。镜头视野中，灰卡大致放在中间，周围为白色背景</td></tr><tr><td>场景 2</td><td>这是测试人脸检测的场景。相机位于三脚架上, 指向一张包含3人脸的静态图片, 在恒定 (稳定) 相对明亮的照明光源下。</td></tr><tr><td>场景3</td><td>这是测试图像清晰度的场景。相机位于三脚架上, 指向包含某些边缘的静态图片, 如打印的 ISO 12233 图表。现场应在一个恒定 (稳定) 相对明亮的照明源。</td></tr><tr><td>场景4</td><td>这是测试纵横比的场景。相机位于三脚架上, 指向一个静态测试页, 其中包含一个黑色圆圈和一个方块。现场应在一个恒定 (稳定) 相对明亮的照明源</td></tr><tr><td>场景5</td><td>这是测试镜头着色和颜色均匀性的场景。在摄像机前放置一个扩散器(毛玻璃)。相机位于三脚架上，指向恒定的 (稳定) 相对地明亮的照明源。<br/>我们这边就用的一张白色餐巾纸(A4纸也可以，只要白色)代替了扩散器，将镜头对着光源，用餐巾纸挡住镜头即可。</td></tr><tr><td>sensor_fusion</td><td>马达灯箱</td></tr></tbody></table><p>注意，在andorid 11后这些场景会进一步细分和增加，具体看对应的CTSVerfier的包里面,路劲如下,这个路劲下面也有对应场景的图片.pdf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/GMS/r4/CameraITS/tests</span><br></pre></td></tr></table></figure><h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3 命令"></a>3 命令</h3><p>终端需要source its的环境.只要source一次，终端没有关闭不用再次source.新开终端要重新source</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh </span><br></pre></td></tr></table></figure><p>ITS 整跑命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python tools/run_all_tests.py device=008bcdcf0405   camera=1 scenes=5 #更改成对应的camera和场景即可</span><br><span class="line">python tools/run_all_tests.py device=008bcdcf0405   camera=1 scenes=scenes_fusion #如果只有一台机器可以不加device参数</span><br><span class="line">python tools/run_all_tests.py camera=0 scenes=sensor_fusion rot_rig=04d8:fc73:1 #rot_rig后面加马达相关的参数，这个用默认即可不用更改</span><br><span class="line"></span><br><span class="line">python tools/run_all_tests.py camera=0 scenes=0 tmp_dir=~/XTS/CtsVerifier_r6/CameraITS/outfile/ </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置输出的路径</span></span><br></pre></td></tr></table></figure><p>整跑会在&#x2F;tmp&#x2F;xxx 目录下创建对应的跑测相关的文件.其中summary.txt文件记录了整跑的结果，如果没有则PASS，如果有fail项目,需要单跑检查</p><p>单跑命令,python 运行对应的场景，对应的测试项即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tests/scene1_1/test_ev_compensation_advanced.py camera=0</span><br></pre></td></tr></table></figure><p>关于sensor_fusion 场景，如果马达不会转动，则需要赋予马达权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /dev/ttyACM0</span><br></pre></td></tr></table></figure><h3 id="4-创建报告"><a href="#4-创建报告" class="headerlink" title="4 创建报告"></a>4 创建报告</h3><p>单跑是空的,显示在终端上。创建报告需要全 pass ,有一项没跑或者 fail, 报告出来都是 fail ,并且没有详<br>细的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">its 跑测全部PASS后要点击绿色√后往下操作</span></span><br><span class="line">adb shell settings put global hidden_api_policy 1</span><br><span class="line">adb shell appops set com.android.cts.verifier android:read_device_identifiers allow</span><br><span class="line">adb shell appops set com.android.cts.verifier MANAGE_EXTERNAL_STORAGE 0 (保存报告之前)</span><br><span class="line">在cts界面点击右上角保存报告</span><br><span class="line">adb pull /storage/emulated/0/verifierReports ~/桌面/</span><br></pre></td></tr></table></figure><p>注意这个报告的结果只能用ie浏览器打开.</p><h2 id="3-5-GTS"><a href="#3-5-GTS" class="headerlink" title="3.5 GTS"></a>3.5 GTS</h2><p>GTS需要电脑和手机都连接外部的网络.</p><p>GTS 跑测命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run gts -m GtsCameraTestCases -s xxx</span><br><span class="line">run gts -m GtsCameraTestCases -s 008bcdcf0405</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> GMS </category>
          
          <category> cts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> GMS </tag>
            
            <tag> cts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>testAfRegions</title>
      <link href="/2024/11/10/GMS/testAfRegions/"/>
      <url>/2024/11/10/GMS/testAfRegions/</url>
      
        <content type="html"><![CDATA[<h1 id="1-测试流程"><a href="#1-测试流程" class="headerlink" title="1 测试流程"></a>1 测试流程</h1><p>测试命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am instrument -e class android.hardware.camera2.cts.StillCaptureTest#testAfRegions[1] --abi arm64-v8a  -w android.camera.cts/androidx.test.runner.AndroidJUnitRunner </span><br></pre></td></tr></table></figure><p>测试代码的位置如下:</p><p>cts&#x2F;tests&#x2F;camera&#x2F;src&#x2F;android&#x2F;hardware&#x2F;camera2&#x2F;cts&#x2F;StillCaptureTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test Af region for still capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAfRegions</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (String id : mCameraIdsUnderTest) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Testing AF regions for Camera &quot;</span> + id);</span><br><span class="line">            openDevice(id);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">afRegionsSupported</span> <span class="operator">=</span> isRegionsSupportedFor3A(MAX_REGIONS_AF_INDEX);</span><br><span class="line">            Log.i(TAG,<span class="string">&quot;afRegionsSupported=&quot;</span>+afRegionsSupported); <span class="comment">//可以加这个log. true则继续往下测试,反之直接跳过这个camera</span></span><br><span class="line">            <span class="keyword">if</span> (!afRegionsSupported) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;MeteringRectangle[]&gt; afRegionTestCases = get3ARegionTestCasesForCamera();<span class="comment">//看下述这个函数的说明</span></span><br><span class="line">            <span class="keyword">for</span> (MeteringRectangle[] afRegions : afRegionTestCases) &#123; <span class="comment">//遍历afRegionTestCases的内容去测试</span></span><br><span class="line">                takePictureTestByCamera(<span class="comment">/*aeRegions*/</span><span class="literal">null</span>, <span class="comment">/*awbRegions*/</span><span class="literal">null</span>, afRegions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeDevice();</span><br><span class="line">            closeImageReader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get 5 3A region test cases, each with one square region in it.</span></span><br><span class="line"><span class="comment">    * The first one is at center, the other four are at corners of</span></span><br><span class="line"><span class="comment">    * active array rectangle.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> array of test 3A regions</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;MeteringRectangle[]&gt; get3ARegionTestCasesForCamera() </span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       Log.v(TAG, <span class="string">&quot;Generated test regions are: &quot;</span> + sb.toString()); <span class="comment">//这边可以把这个log打开看这五个区域的坐标分别是多少. 这五个区域的坐标会返回到上述afRegionTestCases,然后遍历去测试takePictureTestByCamera</span></span><br></pre></td></tr></table></figure><p>主要执行的测试内容在这个函数takePictureTestByCamera</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 1: trigger an auto focus run, and wait for AF locked.</span><br><span class="line">Step 2: AF is already locked, wait for AWB converged, then lock it.</span><br><span class="line">Step 3: trigger an AE precapture metering sequence and wait for AE converged.</span><br><span class="line">Step 4: take a picture when all 3A are in good state</span><br></pre></td></tr></table></figure><p>我们遇到的报错内容如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mCollector.expectMeteringRegionsAreSimilar(</span><br><span class="line">                    <span class="string">&quot;AF regions in result and request should be similar&quot;</span>,</span><br><span class="line">                    afRegions,</span><br><span class="line">                    resultAfRegions,</span><br><span class="line">                    METERING_REGION_ERROR_PERCENT_DELTA);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>afRegions和resultAfRegions内容不一致.</p><p>resultAfRegions是重新下发上报的: afRegions则上述遍历中传递过来的值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MeteringRectangle[] resultAfRegions =</span><br><span class="line">                    getValueNotNull(result, CaptureResult.CONTROL_AF_REGIONS);</span><br></pre></td></tr></table></figure><h1 id="2-hal-上报"><a href="#2-hal-上报" class="headerlink" title="2 hal 上报"></a>2 hal 上报</h1><p>上报路径:</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;aaa&#x2F;source&#x2F;common&#x2F;hal3a&#x2F;v1.0&#x2F;Hal3AAdapter3.cpp</p><p>关注这个值的下发:CaptureResult.CONTROL_AF_REGIONS, mtk平台对andorid 机制的处理都会映射转成对应的mtk标准.</p><p>这个值对应的就是MTK_CONTROL_AF_REGIONS.</p><p>详细的内容见如下的文件:</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;include&#x2F;mtkcam&#x2F;utils&#x2F;metadata&#x2F;client&#x2F;TagMap.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IMP_TAGCONVERT_(    ANDROID_CONTROL_AF_MODE,    MTK_CONTROL_AF_MODE)\</span><br><span class="line">_IMP_TAGCONVERT_(    ANDROID_CONTROL_AF_REGIONS,    MTK_CONTROL_AF_REGIONS)\</span><br></pre></td></tr></table></figure><p>看文件Hal3AAdapter3.cpp内容:这是解析meta的内容.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MUINT8</span><br><span class="line">Hal3AAdapter3::</span><br><span class="line"><span class="built_in">parseMeta</span>(<span class="type">const</span> vector&lt;MetaSet_T*&gt;&amp; requestQ)&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> ( (!u1RepeatTag) || ReparseMetaForDummy) <span class="comment">// not repeating tag, parse app meta</span></span><br><span class="line">    ...</span><br><span class="line">            <span class="keyword">case</span> MTK_CONTROL_AF_REGIONS:</span><br><span class="line">    ...</span><br><span class="line">        mUpdateMetaResult.<span class="built_in">push</span>(&#123;MTK_CONTROL_AF_REGIONS, entryNew&#125;); <span class="comment">//这里是上报上去的位置.将entryNew的内容上报上去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往上翻看entryNew的内容从哪里来,从rArea处获取.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entryNew.<span class="built_in">push_back</span>(rArea.i4Left,   <span class="built_in">Type2Type</span>&lt;MINT32&gt;());</span><br><span class="line">entryNew.<span class="built_in">push_back</span>(rArea.i4Top,    <span class="built_in">Type2Type</span>&lt;MINT32&gt;());</span><br><span class="line">entryNew.<span class="built_in">push_back</span>(rArea.i4Right,  <span class="built_in">Type2Type</span>&lt;MINT32&gt;());</span><br><span class="line">entryNew.<span class="built_in">push_back</span>(rArea.i4Bottom, <span class="built_in">Type2Type</span>&lt;MINT32&gt;());</span><br><span class="line">entryNew.<span class="built_in">push_back</span>(rArea.i4Weight, <span class="built_in">Type2Type</span>&lt;MINT32&gt;());</span><br></pre></td></tr></table></figure><p>rArea又是根据rArea和rSclCrop存在以下的逻辑关系.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rArea.i4Left   = <span class="built_in">MIN</span>(<span class="built_in">MAX</span>(rArea.i4Left, rSclCrop[<span class="number">0</span>]), rSclCrop[<span class="number">2</span>]);</span><br><span class="line">rArea.i4Top    = <span class="built_in">MIN</span>(<span class="built_in">MAX</span>(rArea.i4Top, rSclCrop[<span class="number">1</span>]), rSclCrop[<span class="number">3</span>]);</span><br><span class="line">rArea.i4Right  = <span class="built_in">MAX</span>(<span class="built_in">MIN</span>(rArea.i4Right, rSclCrop[<span class="number">2</span>]), rSclCrop[<span class="number">0</span>]);</span><br><span class="line">rArea.i4Bottom = <span class="built_in">MAX</span>(<span class="built_in">MIN</span>(rArea.i4Bottom, rSclCrop[<span class="number">3</span>]), rSclCrop[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>检查rSclCrop的内容.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mi4AppfgCrop = <span class="built_in">QUERY_ENTRY_SINGLE</span>(_appmeta, MTK_SCALER_CROP_REGION, rSclCropRect);</span><br><span class="line">fgCrop = mi4AppfgCrop;</span><br><span class="line"></span><br><span class="line">mAppCropRegion.p.x = rSclCropRect.p.x;</span><br><span class="line">mAppCropRegion.p.y = rSclCropRect.p.y;</span><br><span class="line">mAppCropRegion.s.w = rSclCropRect.s.w;</span><br><span class="line">mAppCropRegion.s.h = rSclCropRect.s.h;</span><br><span class="line">rSclCrop[<span class="number">0</span>] = rSclCropRect.p.x;</span><br><span class="line">rSclCrop[<span class="number">1</span>] = rSclCropRect.p.y;</span><br><span class="line">rSclCrop[<span class="number">2</span>] = rSclCropRect.p.x + rSclCropRect.s.w;</span><br><span class="line">rSclCrop[<span class="number">3</span>] = rSclCropRect.p.y + rSclCropRect.s.h;</span><br></pre></td></tr></table></figure><p>该问题出现的原因是有人误删了 rSclCrop相关的内容导致该相关内容呈现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mi4AppfgCrop = <span class="built_in">QUERY_ENTRY_SINGLE</span>(_appmeta, MTK_SCALER_CROP_REGION, rSclCropRect);</span><br><span class="line">fgCrop = mi4AppfgCrop;</span><br><span class="line">rSclCrop[<span class="number">3</span>] = rSclCropRect.p.y + rSclCropRect.s.h;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> GMS </category>
          
          <category> cts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> GMS </tag>
            
            <tag> cts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷启动</title>
      <link href="/2024/11/10/Android/hal/%E5%86%B7%E5%90%AF%E5%8A%A8/"/>
      <url>/2024/11/10/Android/hal/%E5%86%B7%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>冷启动大致可以分成以下几块内容:</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>S0</td><td>(system)</td><td>主要是 Activity 的创建耗时（从 Touch up，即 <code>ptr:up</code> 开始）</td><td>ptr:up</td></tr><tr><td>S1</td><td>App</td><td>从 Activity 创建成功，到下 open camera 的时间（对应 <code>CameraService::connect</code>）； Note：我习惯把 S0 和 S1 算成一大阶段；</td><td></td></tr><tr><td>S2</td><td>HAL</td><td>open camera 到 <code>onOpened</code>（即 connect 调用完成）回调上去的时间；</td><td></td></tr><tr><td>S3</td><td>App</td><td><code>onOpened</code> 回调后，到 App 去 <code>creatSession</code> 的时间；</td><td></td></tr><tr><td>S4</td><td>HAL</td><td><code>creatSession</code> 的耗时（对应整个endConfigure);</td><td></td></tr><tr><td>S5</td><td>App</td><td><code>creatSession</code> 完成到 <code>setRepeatingRequest</code> 的时间；</td><td></td></tr><tr><td>S6</td><td>HAL</td><td><code>setRepeatingRequest</code> 后到底层抛出第一帧（cameraserver 会有一个 <code>first full buffer</code> 的记录）的时间；</td><td></td></tr><tr><td>S7</td><td><strong>App+MultiMedia</strong></td><td>底层出第一帧后，到 App 真正第一次开始 draw 数据，数据送到 surfaceFlinger 显示出来（第二次 <code>onMessageReceived</code> 完成）的时间。</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop service.adb.root 1</span><br><span class="line">开发者模式关闭再打开</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sched/freq/idle  #这三个tag是cpu　信息,无论如何必须带上</span><br><span class="line">gfx/view/input 　#测试列表滑动.桌面滑动.这种流畅性问题</span><br><span class="line">gfx/view/imput/hwui  #绘图问题</span><br><span class="line">gfx/view/input/res/am/wm #测试app启动</span><br><span class="line">gfx/view/input/dalvik/disk  #GC或者IO导致卡顿</span><br><span class="line">gfx/view/input/res/am/wm/power #亮屏,电量相关</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx camera view input sched freq video disk dalvik res am wm -b 20480 -t 5 -o trace.html</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S0：Touch Up → ActivityStart</span><br><span class="line"></span><br><span class="line">S1：ActivityStart → open camera | start</span><br><span class="line"></span><br><span class="line">S2：Open camera</span><br><span class="line"></span><br><span class="line">S3：Open camera | end → Configure streams | start</span><br><span class="line"></span><br><span class="line">S4：Configure streams</span><br><span class="line"></span><br><span class="line">S5：Configure streams | end → SetRepeatingRequests</span><br><span class="line"></span><br><span class="line">S6：SetRepeatingRequests → 1st frame out from hal</span><br><span class="line"></span><br><span class="line">S7：1st frame out from hal → Display show 1st frame</span><br></pre></td></tr></table></figure><h1 id="2-S0-S1"><a href="#2-S0-S1" class="headerlink" title="2 S0+S1"></a>2 S0+S1</h1><p>system+app耗时<br>搜索关键字ptr:up<br><img src="https://i.loli.net/2021/02/05/yK8TitEbIUNgmuW.png" alt="1.png"></p><p>可以看到如下的内容:这是按下相机按钮并且抬起的操作<br><img src="https://i.loli.net/2021/02/05/DCQZysUbLd5njHB.png" alt="2.png"><br>从 这里开始计时到connectDevice结束是S0+S1的时间.</p><p>S1的主要时间是activityStart到connectDevice</p><p>S0: AppLaunch_dispatchPtr:Up –&gt; activityStart</p><p>S1: activityStart –&gt; connectDevice</p><p><img src="https://i.loli.net/2021/02/13/vJPn9CIAjFhYcKe.png" alt="1.png"></p><h1 id="3-S2"><a href="#3-S2" class="headerlink" title="3 S2"></a>3 S2</h1><p>hal耗时</p><p>搜索connectDevice<br><img src="https://i.loli.net/2021/02/07/oNEQFBJ8z1tYHLi.png" alt="微信图片_20210207161216.png"></p><p>可以看到 connectDevice的持续时间.这就是S2的耗时<br><img src="https://i.loli.net/2021/02/07/Z5B3GHkUhon2cyj.png" alt="微信图片_20210207161216.png"></p><h1 id="4-S3"><a href="#4-S3" class="headerlink" title="4 S3"></a>4 S3</h1><p>app耗时</p><p>从下图可以看到是从connectDevice的结尾到endConfigure的开始</p><p><img src="https://i.loli.net/2021/02/13/C5EvmfbHDwYlUus.png" alt="1.png"></p><h1 id="5-S4"><a href="#5-S4" class="headerlink" title="5 S4"></a>5 S4</h1><p>hal 耗时<br>endConfigure的持续时间</p><p><img src="https://i.loli.net/2021/02/13/rKZuInyARo9pzmL.png" alt="3.png"></p><h1 id="6-S5"><a href="#6-S5" class="headerlink" title="6 S5"></a>6 S5</h1><p>app耗时</p><p>从endConfigure的结尾到setRepeatingRequest返回完成</p><p><img src="https://i.loli.net/2021/02/13/LRqojJPDYcwM9lB.png" alt="1.png"><br><img src="https://i.loli.net/2021/02/13/7iDupNsqbwOlQnG.png" alt="3.png"></p><h1 id="7-S6"><a href="#7-S6" class="headerlink" title="7 S6"></a>7 S6</h1><p>hal耗时</p><p>直接搜索first full buffer .有的apk会返回多个.一般都是以最后一个收尾为主.<br>这个一般都是和captureRequest返回在一起的.</p><p>耗时是从setRepeatingRequest 计算到first full buffer返回</p><h1 id="8-S7"><a href="#8-S7" class="headerlink" title="8 S7"></a>8 S7</h1><p>app和多媒体耗时</p>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式切换</title>
      <link href="/2024/11/10/Android/hal/%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2/"/>
      <url>/2024/11/10/Android/hal/%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p>这里提到的mode切换主要是拍照切换到video，或者切换到超夜之类</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>S0(App)</td><td>从点击事件到调用 <code>flush</code> 的间隔；</td></tr><tr><td>S1(HAL)</td><td>flush的总耗时</td></tr><tr><td>S2(App)</td><td><code>flush</code> 结束后，到 <code>createSession</code> 的间隔；</td></tr><tr><td>S3(Hal)</td><td><code>createSession</code> 的耗时；</td></tr><tr><td>S4(App)</td><td><code>createSession</code> 结束到 <code>setRepeatingRequests</code> 的间隔；</td></tr><tr><td>S5(HAL)</td><td><code>setRepeatingRequests</code> 到底层出第一帧的时间；</td></tr><tr><td>S6(<strong>App + Multimedia</strong>)</td><td>底层第一帧到真正显示出第一帧的间隔。</td></tr></tbody></table><h1 id="2-S0"><a href="#2-S0" class="headerlink" title="2 S0"></a>2 S0</h1><p>从点击事件到调用 <code>flush</code> 的间隔；</p><p>搜索ptr:up<br>这个是按下抬起的动作<br><img src="https://i.loli.net/2021/04/09/B8yZztXA1hR7urT.png" alt="选区_003.png"><br><img src="https://i.loli.net/2021/04/09/RYChKUed5HTM1IA.png" alt="选区_004.png"><br>然后搜索CameraHal::flush</p><p><img src="https://i.loli.net/2021/04/09/2oaSdCM1zYVxg48.png" alt="选区_006.png"></p><p>上面的间隔时间56.958ms就是s0</p><h1 id="3-S1"><a href="#3-S1" class="headerlink" title="3 S1"></a>3 S1</h1><p>  flush的总耗时,</p><p>搜索CameraHal::flush,这个持续时间就是S1的耗时</p><p><img src="https://i.loli.net/2021/04/09/FiMa7me4VRK2H1h.png" alt="选区_005.png"></p><h1 id="4-S2"><a href="#4-S2" class="headerlink" title="4 S2"></a>4 S2</h1><p><code>flush</code> 结束后，到 <code>createSession</code> 的间隔；</p><p>如下图：</p><p><img src="https://i.loli.net/2021/04/09/Kcr9st7LDgWNmOJ.png"></p><h1 id="5-S3"><a href="#5-S3" class="headerlink" title="5 S3"></a>5 S3</h1><p><code>endConfigure</code> 的总耗时</p><p><img src="https://i.loli.net/2021/04/09/6t3oGNqIkuDz58Z.png" alt="选区_001.png"></p><h1 id="6-S4"><a href="#6-S4" class="headerlink" title="6 S4"></a>6 S4</h1><p>即 <code>endConfigure</code> 结束到下 <code>setRepeatingRequests</code> 的间隔<br><img src="https://i.loli.net/2021/04/09/jg6okQ9WwcMBPLX.png" alt="选区_002.png"></p><h1 id="7-S5"><a href="#7-S5" class="headerlink" title="7 S5"></a>7 S5</h1><p>则是 <code>setRepeatingRequests</code> 到底层出第一帧（cameraserver 收到 <code>first full buffer</code>）的间隔<br><img src="https://i.loli.net/2021/04/09/ZFn2C75TaGAI9ib.png" alt="2021-04-09 09-49-19屏幕截图.png"></p><h1 id="8-S7"><a href="#8-S7" class="headerlink" title="8 S7"></a>8 S7</h1><p>是底层第一帧上传后，到真正显示的第一帧的间隔：</p><p>根据 <code>first full buffer</code> 时间，找到 SurfaceTexture 收到第一帧的时间点，再找到 APP 第一次取用帧数据去 <code>Draw</code> 的时间点</p><p>多媒体画图日后研究，每个项目的机制不一样，需要根据实际去研究</p>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后摄切换</title>
      <link href="/2024/11/10/Android/hal/%E5%89%8D%E5%90%8E%E6%91%84%E5%88%87%E6%8D%A2/"/>
      <url>/2024/11/10/Android/hal/%E5%89%8D%E5%90%8E%E6%91%84%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p>这里提到的切换主要是前摄&lt;-&gt;后摄的切换<br>总的来说可以分成以下的内容:</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>S0(App)</td><td>从点击事件到调用 <code>flush</code> 的间隔</td></tr><tr><td>S1(Hal)</td><td><code>flush</code> + <code>disconnect</code> 的总耗时，即关闭前一个摄像头的整个流程</td></tr><tr><td>S2(App)</td><td><code>disconnect</code> 完成后，到下 open camera 指令的间隔</td></tr><tr><td>S3(Hal)</td><td>open camera 到 <code>onOpened</code> 回调的耗时</td></tr><tr><td>S4(App)</td><td>onOpened<code>回调上来后，间隔多久才开始</code>createSession</td></tr><tr><td>S5(Hal)</td><td><code>createSession</code> 完成的时间，对应 <code>endConfigure</code> 的耗时</td></tr><tr><td>S6(App)</td><td><code>createSession</code> 完成后，到下 <code>setRepeatingRequests</code> 的间隔；</td></tr><tr><td>S7(Hal)</td><td><code>setRepeatingRequests</code> 指令下来后，底层要多久才准备好第一帧上抛</td></tr><tr><td>S8(App + Multimedia)</td><td>第一帧送给 App 后，多久后才真正第一次显示出数据帧</td></tr></tbody></table><h1 id="2-拆解"><a href="#2-拆解" class="headerlink" title="2 拆解"></a>2 拆解</h1><h2 id="2-1-S0-App"><a href="#2-1-S0-App" class="headerlink" title="2.1 S0(App)"></a>2.1 S0(App)</h2><p>App管辖<br>S0:从点击事件到调用 <code>flush</code> 的间隔<br>搜索ptr:up，找到如下的内容:这是按下切换释放的操作.<br>按下和释放分别对应:</p><p>AppLaunch_dispatchPtr:Down</p><p>AppLaunch_dispatchPtr:Up</p><p>我们拆解S0的时候关注up的操作.从这个start开始记录.</p><p><img src="https://img-blog.csdnimg.cn/20210320220203593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">搜索CameraHal::flush<img src="https://img-blog.csdnimg.cn/20210320220715608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>S0的时间就是AppLaunch_dispatchPtr:Up的开始到CameraHal::flush的开始</p><h2 id="2-2-S1-Hal"><a href="#2-2-S1-Hal" class="headerlink" title="2.2 S1(Hal)"></a>2.2 S1(Hal)</h2><p>Hal 管辖<br>closeStart-&gt;CloseDone的过程.<br><img src="https://img-blog.csdnimg.cn/20210320221536995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-3-S2-App"><a href="#2-3-S2-App" class="headerlink" title="2.3 S2(App)"></a>2.3 S2(App)</h2><p>App管辖<br>disconnect 完成后，到下 open camera 指令的间隔<br>关键字:connectDevice</p><p><img src="https://img-blog.csdnimg.cn/2021032022190832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-4-S3-Hal"><a href="#2-4-S3-Hal" class="headerlink" title="2.4 S3(Hal)"></a>2.4 S3(Hal)</h2><p>Hal管辖<br>open camera 到 <code>onOpened</code> 回调的耗时<br>关键字connectDevices<br><img src="https://img-blog.csdnimg.cn/2021032022235337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-5-S4-App"><a href="#2-5-S4-App" class="headerlink" title="2.5 S4(App)"></a>2.5 S4(App)</h2><p>App管辖<br>onOpened<code>回调上来后，间隔多久才开始</code>createSession<br><img src="https://img-blog.csdnimg.cn/20210320222831820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-6-S5-Hal"><a href="#2-6-S5-Hal" class="headerlink" title="2.6 S5(Hal)"></a>2.6 S5(Hal)</h2><p><code>createSession</code> 完成的时间，对应 <code>endConfigure</code> 的耗时<br>内容如下:<br><img src="https://img-blog.csdnimg.cn/20210320223348459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-7-S6-App"><a href="#2-7-S6-App" class="headerlink" title="2.7 S6(App)"></a>2.7 S6(App)</h2><p> <code>createSession</code> 完成后，到下 <code>setRepeatingRequests</code> 的间隔<br> <img src="https://img-blog.csdnimg.cn/20210320224052997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-8-S7-Hal"><a href="#2-8-S7-Hal" class="headerlink" title="2.8 S7(Hal)"></a>2.8 S7(Hal)</h2><p><code>setRepeatingRequests</code> 指令下来后，底层要准备好第一帧上抛<br>搜索关键字:first full buffer<br><img src="https://img-blog.csdnimg.cn/20210320224431766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzUzNzQ5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-9-S8-App-Multimedia"><a href="#2-9-S8-App-Multimedia" class="headerlink" title="2.9 S8(App + Multimedia)"></a>2.9 S8(App + Multimedia)</h2><p>每个手机的绘画机制不一样，有待研究.</p>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cif</title>
      <link href="/2024/11/10/Android/cif/"/>
      <url>/2024/11/10/Android/cif/</url>
      
        <content type="html"><![CDATA[<h1 id="CIF概述"><a href="#CIF概述" class="headerlink" title="CIF概述"></a>CIF概述</h1><p>cif的给我的感觉就是一个光敏电阻，就是要单独供电，当一个单独的设备看即可。</p><p>我们当前的项目都是通过去读cif的gpio口的状态，然后根据实际情况是否把这个tag上传给app端，在此基础上完成其相关的需求开发.</p><h1 id="1-DTS"><a href="#1-DTS" class="headerlink" title="1 DTS"></a>1 DTS</h1><p>和正常的设备一样都是需要供电的.</p><p>只不过cif模组只要一个io口供电即可.</p><p>拿我做过的项目来举例:</p><p>我做的项目是供电是借在vddcama1上的.</p><p>读取状态的io是接在gpio41上的.所以在对应的dts上需要配置如下相关的内容.</p><p>至于这部分内容可以挂在某些camera上暂时未使用的io口.</p><p>比如我看到前摄马达这个供电没用，我就顺带映射到马达供电，(如果是gpio 供电，建议招gpio定义的mipi switch io或者其他不占用的io使用)而不是单独做一个。虽然不规范，但是很实用.</p><p>同理映射io也建议使用未占用的口. 我读取的io的脚挂在后摄的power-down脚上.</p><pre><code>vddcammot-supply = &lt;&amp;vddcama1&gt;;/*cif power*/power-down-gpios = &lt;&amp;ap_gpio 41 0&gt;;/*cif read io*/</code></pre><p>dts示例代码位置</p><p>bsp&#x2F;kernel5.15&#x2F;kernel5.15&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;sprd&#x2F;ums9230-6h10-overlay.dts</p><h1 id="2-供电"><a href="#2-供电" class="headerlink" title="2 供电"></a>2 供电</h1><h2 id="2-1-hal"><a href="#2-1-hal" class="headerlink" title="2.1 hal"></a>2.1 hal</h2><p>基本配电搞定了,下来要分别上kernel里做读取的操作.还有对应的hal部分做下ioctrl读取的操作.</p><p>由于cif是挂载其他camera上的,当然可以单独做一个设备做，但是我感觉也没啥功能，挂就挂吧，多大点事.</p><p>在对应的sensor 上电和下点的位置做cif的上电和下电.</p><pre><code>hw_sensor_power_down_cif(sns_drv_cxt-&gt;hw_handle,!power_down); //上电hw_sensor_power_down_cif(sns_drv_cxt-&gt;hw_handle,power_down);  //下电//这个power_down=的值随便设置，反正到kernel也是根据读出来的值进行上下电操作的.</code></pre><p>vendor&#x2F;sprd&#x2F;modules&#x2F;libcamera&#x2F;sensor&#x2F;hw_drv&#x2F;hw_sensor_drv.h</p><p>这个文件里做申明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cmr_int <span class="title">hw_sensor_power_down_cif</span><span class="params">(cmr_handle hw_handle, cmr_u32 power_level)</span></span>;</span><br></pre></td></tr></table></figure><p>vendor&#x2F;sprd&#x2F;modules&#x2F;libcamera&#x2F;sensor&#x2F;hw_drv&#x2F;hw_sensor_drv.c</p><p>这个文件里面实现.这个实现会直接通过ioctrl调用到kernel里面.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cmr_int <span class="title">hw_sensor_power_down_cif</span><span class="params">(cmr_handle hw_handle, cmr_u32 power_level)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_BEGIN</span>(__FUNCTION__);</span><br><span class="line">    cmr_int ret = HW_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK_HANDLE</span>(hw_handle);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hw_drv_cxt</span> *hw_drv_cxt = (<span class="keyword">struct</span> hw_drv_cxt *)hw_handle;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HW_LOGE</span>(<span class="string">&quot;cif power_level %d&quot;</span>, power_level);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">ioctl</span>(hw_drv_cxt-&gt;fd_sensor, SENSOR_IO_PD_CIF, &amp;power_level); <span class="comment">//这里ioctrl</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret) &#123;</span><br><span class="line">        <span class="built_in">HW_LOGE</span>(<span class="string">&quot;cif failed,  power_level = %d, ret=%ld &quot;</span>, power_level, ret);</span><br><span class="line">        ret = HW_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_END</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-kernel"><a href="#2-2-kernel" class="headerlink" title="2.2 kernel"></a>2.2 kernel</h2><p>在此文件内定义</p><p>bsp&#x2F;modules&#x2F;common&#x2F;camera&#x2F;interface&#x2F;sprd_sensor.h</p><p>往上补一个就行了.</p><pre><code>#define SENSOR_IO_PD_CIF       \        _IOW(SENSOR_IOC_MAGIC,  29, uint8_t)</code></pre><p>在这个文件中对应函数中补充下发</p><p>bsp\modules\common\camera\sensor\sprd_sensor_core.c</p><pre><code>static long sprd_sensor_file_ioctl(struct file *file, unsigned int cmd,......    case SENSOR_IO_PD_CIF:        ret = sprd_sensor_io_set_pd_cif(arg);        break;</code></pre><p>实现也在这里一并实现了吧.因为我这边是直接 用cam mot的位置去映射，就没有继续封装了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sprd_sensor_io_set_pd_cif</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> power_level;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vdd_val = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> sensor_id = <span class="number">1</span>; <span class="comment">//front sensor id = 1 由于我是挂在前摄上的供电，所以要通过前摄的配电节点来访问我下面的供电配置.</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">copy_from_user</span>(&amp;power_level, (<span class="type">unsigned</span> <span class="type">char</span> *)arg,</span><br><span class="line">                            <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vdd_val = <span class="built_in">sprd_sensor_get_voltage_value</span>(power_level);</span><br><span class="line">            <span class="keyword">if</span>(power_level == <span class="number">1</span>)   <span class="comment">//这个和sensor驱动中对应. 看实际上1/0 分别对应的是上电和下电.</span></span><br><span class="line">            &#123;</span><br><span class="line">                vdd_val = <span class="number">2800000</span>; <span class="comment">//CIF供电2.8v 后续记得改. 这个影响功耗</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vdd_val = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pr_info</span>(<span class="string">&quot;cif vdd_val=%d power_level=%d&quot;</span>,vdd_val,power_level);</span><br><span class="line">            ret = <span class="built_in">sprd_sensor_set_voltage</span>(sensor_id, vdd_val,SENSOR_REGULATOR_CAMMOT_ID_E); <span class="comment">//实际上下的电压操作</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pr_info</span>(<span class="string">&quot;cif set cammot successfully\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pr_info</span>(<span class="string">&quot;cif set cammot fail\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述我加的log只是为了我方便debug，实际过程都可以直接删点多余的log.</p><p>到此供电已经完成了.</p><p>接下来梳理下读取io口电平的操作</p><h1 id="3-读取"><a href="#3-读取" class="headerlink" title="3 读取"></a>3 读取</h1><h2 id="3-1-hal"><a href="#3-1-hal" class="headerlink" title="3.1 hal"></a>3.1 hal</h2><p>这边我也是从梳理sensor驱动开始，因为这样好理解.</p><p>gc13a0_drv_access_val 中做如下操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cmr_int ret = SENSOR_FAIL;</span><br><span class="line">   SENSOR_VAL_T *param_ptr = (SENSOR_VAL_T *)param;</span><br><span class="line">   <span class="type">int</span> cif_value = <span class="number">0</span>;</span><br><span class="line">   <span class="type">char</span> test[PROPERTY_VALUE_MAX] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">SENSOR_IC_CHECK_HANDLE</span>(handle);</span><br><span class="line"><span class="built_in">SENSOR_IC_CHECK_PTR</span>(param_ptr);</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">sensor_ic_drv_cxt</span> * sns_drv_cxt = (<span class="keyword">struct</span> sensor_ic_drv_cxt *)handle; </span><br><span class="line">   cif_value = <span class="built_in">hw_sensor_read_cif</span>(sns_drv_cxt-&gt;hw_handle); <span class="comment">//这个是主要的操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SENSOR_LOGI</span>(<span class="string">&quot;sensor gc13a0: param_ptr-&gt;type=%x&quot;</span>, param_ptr-&gt;type);</span><br><span class="line">   <span class="keyword">if</span>(cif_value == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">property_set</span>(<span class="string">&quot;persist.vendor.cam.back.cif&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       <span class="built_in">SENSOR_LOGI</span>(<span class="string">&quot;set cif 1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">property_set</span>(<span class="string">&quot;persist.vendor.cam.back.cif&quot;</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">       <span class="built_in">SENSOR_LOGI</span>(<span class="string">&quot;set cif 0&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">property_get</span>(<span class="string">&quot;persist.vendor.cam.back.cif&quot;</span>, test, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">   <span class="built_in">SENSOR_LOGI</span>(<span class="string">&quot;test cif:%s&quot;</span>,test);</span><br></pre></td></tr></table></figure><p>hw_sensor_read_cif在如下位置声明</p><p>vendor&#x2F;sprd&#x2F;modules&#x2F;libcamera&#x2F;sensor&#x2F;hw_drv&#x2F;hw_sensor_drv.h</p><pre><code>cmr_int hw_sensor_read_cif(cmr_handle hw_handle);</code></pre><p>跟供电一样在另外一个位置实现ioctrl下发到kernel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cmr_int <span class="title">hw_sensor_read_cif</span><span class="params">(cmr_handle hw_handle)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_BEGIN</span>(__FUNCTION__);</span><br><span class="line">    cmr_int ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK_HANDLE</span>(hw_handle);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hw_drv_cxt</span> *hw_drv_cxt = (<span class="keyword">struct</span> hw_drv_cxt *)hw_handle; <span class="comment">//ioctrl下发到kernel上</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">ioctl</span>(hw_drv_cxt-&gt;fd_sensor, SENSOR_IO_READ_CIF, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ATRACE_END</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-kernel"><a href="#3-2-kernel" class="headerlink" title="3.2 kernel"></a>3.2 kernel</h2><p>kernel这部分的逻辑和上述的供电的相似.只不过一个是下电压，一个是读电压.</p><p>bsp&#x2F;modules&#x2F;common&#x2F;camera&#x2F;interface&#x2F;sprd_sensor.h 中补充id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SENSOR_IO_READ_CIF\</span></span><br><span class="line"><span class="meta">_IOW(SENSOR_IOC_MAGIC,28, uint32_t)</span></span><br></pre></td></tr></table></figure><p>bsp&#x2F;modules&#x2F;common&#x2F;camera&#x2F;sensor&#x2F;sprd_sensor_core.c 中实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SENSOR_IO_READ_CIF:</span><br><span class="line">        ret = <span class="built_in">sprd_sensor_io_read_cif</span>(); <span class="comment">//通过id下发</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sprd_sensor_io_read_cif</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = <span class="built_in">sprd_sensor_read_cif_value</span>();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pr_info</span>(<span class="string">&quot;read cif successfully\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;read cif fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看</p><p>sprd_sensor_read_cif_value</p><p>具体实现在:</p><p>bsp&#x2F;modules&#x2F;common&#x2F;camera&#x2F;sensor&#x2F;sprd_sensor_drv.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprd_sensor_read_cif_value</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> gpio_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sprd_sensor_dev_info_tag</span> *p_dev;</span><br><span class="line">    p_dev = <span class="built_in">sprd_sensor_get_dev_context</span>(<span class="number">0</span>); <span class="comment">//映射挂在后主摄的dts上.</span></span><br><span class="line">    gpio_id = p_dev-&gt;gpio_tab[SPRD_SENSOR_PWN_GPIO_TAG_E];</span><br><span class="line">    <span class="built_in">pr_err</span>(<span class="string">&quot;CIF0309:gpio id =%d&quot;</span>,gpio_id);</span><br><span class="line">    ret = <span class="built_in">gpio_direction_input</span>(gpio_id); </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;CIF0309: set gpio in successful&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;CIF0309:set gpio_value fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">gpio_get_value</span>(gpio_id);<span class="comment">// 直接读gpio电压的值</span></span><br><span class="line">    <span class="keyword">if</span>(ret &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;CIF0309:cif_value = %d&quot;</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;CIF0309:get gpio_value fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的流程图如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">sensor_drv -&gt; hw_sensor_drv: hw_sensor_power_down_cif</span><br><span class="line"></span><br><span class="line">hw_sensor_drv-&gt;sprd_sensor_core:SENSOR_IO_PD_CIF</span><br><span class="line"></span><br><span class="line">sprd_sensor_core-&gt;sprd_sensor_core:sprd_sensor_io_set_pd_cif</span><br><span class="line"></span><br><span class="line">sensor_drv -&gt; hw_sensor_drv: hw_sensor_read_cif</span><br><span class="line"></span><br><span class="line">hw_sensor_drv-&gt;sprd_sensor_core:SENSOR_IO_READ_CIF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sprd_sensor_core-&gt;sprd_sensor_core:sprd_sensor_read_cif_value</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sensor控制另外一个sensor上下电</title>
      <link href="/2024/11/10/Android/hal/sensor%E6%8E%A7%E5%88%B6%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AAsensor%E4%B8%8A%E4%B8%8B%E7%94%B5/"/>
      <url>/2024/11/10/Android/hal/sensor%E6%8E%A7%E5%88%B6%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AAsensor%E4%B8%8A%E4%B8%8B%E7%94%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1 描述"></a>1 描述</h1><p>在另外一个sensor驱动中控制另外一个sensor的上电</p><h1 id="2-打开so"><a href="#2-打开so" class="headerlink" title="2 打开so"></a>2 打开so</h1><p>vendor&#x2F;sprd&#x2F;modules&#x2F;libcamera&#x2F;sensor&#x2F;sensor_drv_u.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> cmr_int <span class="title">sensor_drv_ic_identify</span><span class="params">(<span class="keyword">struct</span> sensor_drv_context *sensor_cxt,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      cmr_u32 sensor_id, cmr_u32 identify_off)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sensor_drv_lib</span> libPtrsc500cs;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sensor_drv_lib</span> *libPtr = &amp;libPtrsc500cs;</span><br><span class="line">    <span class="type">void</span> *(*sc500cs_power_sequence_for_creepage)(<span class="type">void</span>) = <span class="literal">NULL</span>;   </span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">        <span class="keyword">if</span>((sensor_id == <span class="number">2</span>) &amp;&amp; (<span class="number">0</span> == <span class="built_in">strcmp</span>(slot_sensor_info_list[<span class="number">1</span>].sensor_name, <span class="string">&quot;sc500cs_frontdd&quot;</span>))) &#123;</span><br><span class="line">        libPtr-&gt;drv_lib_handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libsensor_sc500cs_frontdd.so&quot;</span>, RTLD_NOW);</span><br><span class="line">        <span class="keyword">if</span> (!libPtr-&gt;drv_lib_handle) &#123;</span><br><span class="line">            <span class="built_in">SENSOR_LOGE</span>(<span class="string">&quot;sc500cs sensor lib handle failed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *(<span class="type">void</span> **)&amp;sc500cs_power_sequence_for_creepage = <span class="built_in">dlsym</span>(libPtr-&gt;drv_lib_handle, <span class="string">&quot;sc500cs_power_sequence_for_creepage&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!sc500cs_power_sequence_for_creepage) &#123;</span><br><span class="line">                <span class="built_in">SENSOR_LOGE</span>(<span class="string">&quot;sc500cs_power_sequence_for_creepage open lib function failed&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">SENSOR_LOGD</span>(<span class="string">&quot;sc500cs_power_sequence_for_creepage before&quot;</span>);</span><br><span class="line">                <span class="built_in">sc500cs_power_sequence_for_creepage</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dlclose</span>(libPtr-&gt;drv_lib_handle);</span><br><span class="line">        libPtr-&gt;drv_lib_handle = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-调用"><a href="#3-调用" class="headerlink" title="3 调用"></a>3 调用</h1><p>在打开的so中调用对应的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sc500cs_power_sequence_for_creepage</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SENSOR_LOGD</span>(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sensor_drv_context</span> sns_cxt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sensor_drv_context</span> *sensor_cxt = &amp;sns_cxt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sensor_ic_drv_cxt</span> sensor_drv_cxt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sensor_ic_drv_cxt</span> *sns_drv_cxt = &amp;sensor_drv_cxt;</span><br><span class="line">    cmr_handle hw_drv_handle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hw_drv_init_para</span> input_ptr;</span><br><span class="line">    cmr_int fd_sensor = SENSOR_FD_INIT;</span><br><span class="line"></span><br><span class="line">    SENSOR_AVDD_VAL_E dvdd_val = SENSOR_AVDD_1200MV;</span><br><span class="line">    SENSOR_AVDD_VAL_E avdd_val = SENSOR_AVDD_2800MV;</span><br><span class="line">    SENSOR_AVDD_VAL_E iovdd_val = SENSOR_AVDD_1800MV;</span><br><span class="line">    BOOLEAN reset_level = SENSOR_LOW_PULSE_RESET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sensor_clean_info(sensor_cxt);</span></span><br><span class="line">    input_ptr.sensor_id = <span class="number">1</span>;</span><br><span class="line">    input_ptr.caller_handle = sensor_cxt;</span><br><span class="line">    fd_sensor = <span class="built_in">hw_sensor_drv_create</span>(&amp;input_ptr, &amp;hw_drv_handle);</span><br><span class="line">    <span class="built_in">SENSOR_LOGD</span>(<span class="string">&quot;fd sensor=%d, hw_drv_handle-&gt;fd_sensor=%d&quot;</span>, fd_sensor, hw_drv_handle-&gt;fd_sensor);</span><br><span class="line">    <span class="keyword">if</span> ((SENSOR_FD_INIT == fd_sensor) || (<span class="literal">NULL</span> == hw_drv_handle)) &#123;</span><br><span class="line">        <span class="built_in">SENSOR_LOGE</span>(<span class="string">&quot;sc500cs hw sensor drv create error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sensor_cxt-&gt;fd_sensor = fd_sensor;</span><br><span class="line">        sensor_cxt-&gt;hw_drv_handle = hw_drv_handle;</span><br><span class="line">        sensor_cxt-&gt;sensor_hw_handler = hw_drv_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sns_drv_cxt-&gt;hw_handle = (<span class="keyword">struct</span> sensor_ic_drv_cxt *)hw_drv_handle;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hw_sensor_set_reset_level</span>(sns_drv_cxt-&gt;hw_handle, reset_level);</span><br><span class="line">    <span class="built_in">hw_sensor_set_avdd_val</span>(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED);</span><br><span class="line">    <span class="built_in">hw_sensor_set_dvdd_val</span>(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED);</span><br><span class="line">    <span class="built_in">hw_sensor_set_iovdd_val</span>(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">hw_sensor_set_iovdd_val</span>(sns_drv_cxt-&gt;hw_handle, iovdd_val);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">hw_sensor_set_dvdd_val</span>(sns_drv_cxt-&gt;hw_handle, dvdd_val);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">hw_sensor_set_reset_level</span>(sns_drv_cxt-&gt;hw_handle, !reset_level);</span><br><span class="line">    <span class="built_in">hw_sensor_set_avdd_val</span>(sns_drv_cxt-&gt;hw_handle, avdd_val);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hw_sensor_set_reset_level</span>(sns_drv_cxt-&gt;hw_handle, reset_level);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">hw_sensor_set_dvdd_val</span>(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">hw_sensor_set_iovdd_val</span>(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hw_sensor_drv_delete</span>(hw_drv_handle);</span><br><span class="line">    <span class="built_in">SENSOR_LOGD</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-说明"><a href="#4-说明" class="headerlink" title="4 说明"></a>4 说明</h1><p>这种方式可以直接cat 对应gpio的高低电平以及PMIC的电位变化</p><p>(GPIO 实际对应GPIO+偏移64)</p><p>例如检查GPIO41则要grep  GPIO 105的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while true ;do</span><br><span class="line">&#123;</span><br><span class="line">adb shell cat /sys/kernel/debug/gpio |grep 105</span><br><span class="line">sleep 1</span><br><span class="line">adb shell cat /sys/kernel/debug/LDO_VDDCAMD1/enable</span><br><span class="line">&#125;</span><br><span class="line">done</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hal </category>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
            <tag> hal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>meta工具acdk获取camera</title>
      <link href="/2024/11/10/Android/hal/meta%E5%B7%A5%E5%85%B7acdk%E8%8E%B7%E5%8F%96camera/"/>
      <url>/2024/11/10/Android/hal/meta%E5%B7%A5%E5%85%B7acdk%E8%8E%B7%E5%8F%96camera/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>meta工具需要获取到cameraModuleInfo,然后把这个信息给到工具，工具需要字符串匹配检查.(<strong>meta这个工具自检就应该被废弃，太没有用了</strong>)</p><p>对于我们camera驱动来说，要完成的工作无非两点，一个就是创建节点，给予hal和上层ap的权限(selinux),其二就是把这个信息存好给返回给工具.</p><p>对于这个需求的难点.如果对我来说就是camerahalserver要在关机状态下先自启一遍，保证把相关的Camera info先拷贝给节点.因为关机状态下的cameraProvider是不启动的.</p><p>关机下init.rc 去启动cameraProvider的流程，我到现在都懒得去整理，没有好一点的项目练手这部分，找机会再说.</p><h1 id="2-流程"><a href="#2-流程" class="headerlink" title="2 流程"></a>2 流程</h1><p>节点的创建，我这边不想再说了，这边做的节点就是一坨屎.</p><p>老子要是有空就全部删了 重做.</p><p>下面主要描述下meta的工作流程和camera的资源获取.</p><p>meta的路径:</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;meta</p><p>我这边主要先关注这个文件<strong>FtModule.cpp</strong></p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;meta&#x2F;common&#x2F;src&#x2F;FtModule.cpp</p><p>获取节点信息的代码非常简单，打开这个节点，获取copy过来就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAM_INFO_PATH  <span class="string">&quot;/proc/cameraModuleInfo&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title">read_cam_info</span><span class="params">(<span class="type">char</span>* peer_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">255</span>];</span><br><span class="line"><span class="type">ssize_t</span> byte_read = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> inode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (peer_buf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> META_FAILED;</span><br><span class="line"></span><br><span class="line">inode = <span class="built_in">open</span>(CAM_INFO_PATH, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (inode &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">META_LOG</span>(<span class="string">&quot;[Meta][FT] read_cam_info open %s fail!&quot;</span>, CAM_INFO_PATH);</span><br><span class="line"><span class="keyword">return</span> META_FAILED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">byte_read = <span class="built_in">read</span>(inode, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">META_LOG</span>(<span class="string">&quot;[Meta][FT] read_cam_info: %s&quot;</span>, buf);</span><br><span class="line"><span class="built_in">close</span>(inode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(peer_buf, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"><span class="keyword">return</span> META_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在这个函数执行对应cmd</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FtModCustomer::exec</span><span class="params">(Frame **pFrm*)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">    <span class="title">switch</span><span class="params">(req-&gt;cmd.m_u1Dummy)</span></span></span><br><span class="line"><span class="function">        ...</span></span><br><span class="line"><span class="function">            <span class="keyword">case</span> 4:</span></span><br><span class="line"><span class="function">META_LOG(<span class="string">&quot;[Meta][FT] read cam info&quot;</span>);</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">acdkIFInit</span>())&#123; <span class="comment">//跟踪这个 </span></span><br><span class="line">    ft_cnf.status = <span class="built_in">read_cam_info</span>(peer_buf); <span class="comment">//获取节点信息</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ft_cnf.status = META_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acdkIFInit 中使用了ioctrl 我自定义的ACDK_CMD_SET_HAL_INIT 来完成camerahal 的信息自启动获取.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">acdkIFInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ACDK_FEATURE_INFO_STRUCT rAcdkFeatureInfo;</span><br><span class="line">    <span class="type">bool</span> bRet;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u4RetLen;</span><br><span class="line">    <span class="type">int</span> srcDev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//====== Create ACDK Object ======</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Mdk_Open</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">META_LOG</span>(<span class="string">&quot;Mdk_Open() Fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//====== Select Camera Sensor ======</span></span><br><span class="line">    rAcdkFeatureInfo.puParaIn = (MUINT8 *)&amp;srcDev;</span><br><span class="line">    rAcdkFeatureInfo.u4ParaInLen = <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    rAcdkFeatureInfo.puParaOut = <span class="literal">NULL</span>;</span><br><span class="line">    rAcdkFeatureInfo.u4ParaOutLen = <span class="number">0</span>;</span><br><span class="line">    rAcdkFeatureInfo.pu4RealParaOutLen = &amp;u4RetLen;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">META_LOG</span>(<span class="string">&quot;%s : srcDev:%d\n&quot;</span>,__FUNCTION__,srcDev);</span><br><span class="line">    bRet = <span class="built_in">Mdk_IOControl</span>(ACDK_CMD_SET_SRC_DEV, &amp;rAcdkFeatureInfo);</span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">META_LOG</span>(<span class="string">&quot;ACDK_FEATURE_SET_SRC_DEV Fail: %d\n&quot;</span>,srcDev);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">Mdk_IOControl</span>(ACDK_CMD_SET_HAL_INIT, &amp;rAcdkFeatureInfo); <span class="comment">//主要是跟踪这个位置的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">META_LOG</span>(<span class="string">&quot;ACDK_CMD_SET_HAL_INIT Fail: %d\n&quot;</span>,srcDev);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">META_LOG</span>(<span class="string">&quot;ACDK_CMD_SET_HAL_INIT ok: srcDev%d\n&quot;</span>,srcDev);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个文件中新添加对应的cmd(<strong>ACDK_COMMAND_END</strong>)</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;include&#x2F;mtkcam&#x2F;main&#x2F;acdk&#x2F;AcdkCommon.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    ++ACDK_CMD_SET_HAL_INIT,</span><br><span class="line">    ACDK_COMMAND_END</span><br><span class="line">&#125;eACDK_COMMAND;</span><br></pre></td></tr></table></figure><p>好了 到这部基本就可以使用这个cmd.</p><p>接下来就是通过这个cmd 做对应的操作了</p><p>这个ioctrl 的cmd的</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;main&#x2F;acdk&#x2F;v4.0&#x2F;src&#x2F;acdk&#x2F;AcdkMain.cpp</p><p><strong>Mdk_IOControl</strong>的实际实现是通过一下的这个函数.直接在里面加我需要的camera hal的操作即可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">AcdkMain::sendcommand</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+    <span class="keyword">else</span> <span class="keyword">if</span>(a_u4Ioctl == ACDK_CMD_SET_HAL_INIT)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] ioctrl a_u4Ioctl=%d&quot;</span>,a_u4Ioctl);</span><br><span class="line">+        err = <span class="built_in">sensorInit</span>();</span><br><span class="line">+        <span class="keyword">if</span> (err != ACDK_RETURN_NO_ERROR)</span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] Sensor setting Fail. err(0x%x)&quot;</span>,err);</span><br><span class="line">+            err = ACDK_RETURN_API_FAIL;</span><br><span class="line">+        &#125;</span><br><span class="line">+        <span class="keyword">else</span></span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] Sensor setting ok&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        err = <span class="built_in">getSensorInfo</span>();</span><br><span class="line">+        <span class="keyword">if</span>(err != ACDK_RETURN_NO_ERROR)</span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] getSensorInfo error(0x%x)&quot;</span>,err);</span><br><span class="line">+            err = ACDK_RETURN_API_FAIL;</span><br><span class="line">+        &#125;</span><br><span class="line">+        <span class="keyword">else</span></span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] getSensorInfo ok&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">//====== Initialize AcdkMhal ======</span></span><br><span class="line">+        err = m_pAcdkMhalObj-&gt;<span class="built_in">acdkMhalInit</span>();</span><br><span class="line">+        <span class="keyword">if</span>(err != ACDK_RETURN_NO_ERROR)</span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] acdkMhalInit Fail(0x%x)&quot;</span>, err);</span><br><span class="line">+        &#125;</span><br><span class="line">+        <span class="keyword">else</span></span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] acdkMhalInit ok&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        err = m_pAcdkMhalObjEng-&gt;<span class="built_in">acdkMhalInit</span>();</span><br><span class="line">+        <span class="keyword">if</span>(err != ACDK_RETURN_NO_ERROR)</span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] acdkMhalInit eng Fail(0x%x)&quot;</span>, err);</span><br><span class="line">+        &#125;</span><br><span class="line">+        <span class="keyword">else</span></span><br><span class="line">+        &#123;</span><br><span class="line">+            <span class="built_in">ACDK_LOGE</span>(<span class="string">&quot;[meta] acdkMhalInit eng ok&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(a_u4Ioctl == ACDK_CMD_SET_OPERATION_MODE)</span><br><span class="line">     &#123;</span><br><span class="line">         eACDK_OPERA_MODE eOpMode = ACDK_OPT_NONE_MODE;</span><br></pre></td></tr></table></figure><h1 id="3-编译debug"><a href="#3-编译debug" class="headerlink" title="3 编译debug"></a>3 编译debug</h1><h2 id="3-1-meta"><a href="#3-1-meta" class="headerlink" title="3.1 meta"></a>3.1 meta</h2><p>对于meta部分:直接看这个Android.mk</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;meta&#x2F;common&#x2F;Android.mk</p><pre><code>LOCAL_MODULE:=meta_tst</code></pre><p>目标模块名字是这个.我本来以为是编译出来so或者a文件，结果编译出来一个二进制文件就叫meta_tst.</p><p>直接push到vendor&#x2F;bin&#x2F;中就可以. meta的工具是直接通过这个bin 来下cmd交互的.我也不想研究，早该弃用的东西没什么软用.这一套和车机ais_server和ais_be_server的交互倒是很相似的.</p><pre><code>adb push  meta_tst vendor/bin/meta_tst</code></pre><p>理论上这个meta_tst可以直接在手机上运行. 当然是直接运行其main函数.而不是通过工具来操作的.</p><p>这个我不想梳理，没啥用. 知道改meta路径下的文件push  meta_tst到 vendor&#x2F;bin&#x2F;即可.</p><h2 id="3-2-acdk"><a href="#3-2-acdk" class="headerlink" title="3.2 acdk"></a>3.2 acdk</h2><p>我们本质上是通过acdk已经写好的函数来完成操作的.</p><p>acdk代码路径:</p><p>外部接口头文件说明:</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;include&#x2F;mtkcam&#x2F;main&#x2F;acdk</p><p>该so库主要实现代码:</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;main&#x2F;acdk</p><p>这边主要用到v4.0(<strong>能观察到mtk源码和很多其他的acdk，那些都是针对单独模块做的.我这个是最源生的</strong>.)</p><p>然后我们看到对应的mk文件:</p><p>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;main&#x2F;acdk&#x2F;v4.0&#x2F;src&#x2F;Android.mk</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := libacdk</span><br></pre></td></tr></table></figure><p>从这里就能知道编译生成的文件是libacdk.so</p><p>push路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push libacdk.so vendor/lib64/</span><br></pre></td></tr></table></figure><p>同理需要杀掉cameraProvider才能生效.</p><p>mtk对cameraProvider进行了封装,是camerahalserver.所以杀掉camerahalserver即可</p><p>从上述内容基本了解到如何编译，但是怎么debug呢？这是关机的状态.如果一直拿meta工具去debug,要不停地重启和抓log.效率极其低下。因为进meta模式机器经常卡死，要好久才能开机.</p><p>于是乎，这边就用到mtk自己编写的测试文件.平台的专业就专业在每个模块都是可以做单独的测试，都写好了对应的接口，push到vendor&#x2F;bin下运行即可.</p><p>对应的test文件路径也在其对应的模块下.</p><p>示例如下:</p><p><strong>vendor&#x2F;mediatek&#x2F;proprietary&#x2F;hardware&#x2F;mtkcam&#x2F;main&#x2F;acdk&#x2F;v4.0&#x2F;src&#x2F;test</strong></p><p>main.cpp 函数入口，我自己debug的时候基本删的很干净，一来是方便debug，二来是跑得快.只跑我要的代码块即可.</p><p>main中其他的我不关注.只要关注这个</p><pre><code>ret *=* main_testMdk(argc, argv, &amp;(crcResults[loop]));</code></pre><p>main_testMdk在test_mdk.cpp中实现</p><p>这个编译是生成acdk_camshottest  然后push到vendor&#x2F;bin&#x2F;</p><p>直接在手机里运行即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vendor/bin/acdk_camshottest  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hal </category>
          
          <category> camera </category>
          
          <category> meta </category>
          
          <category> acdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> camera </tag>
            
            <tag> hal </tag>
            
            <tag> meta </tag>
            
            <tag> acdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lightroomv</title>
      <link href="/2024/11/10/Android/3rd/lightroomv/"/>
      <url>/2024/11/10/Android/3rd/lightroomv/</url>
      
        <content type="html"><![CDATA[<h1 id="1-lightroomv"><a href="#1-lightroomv" class="headerlink" title="1 lightroomv"></a>1 lightroomv</h1><p>三方apk lightroomv 拍照. 一次性只能拍照4张，无法生成第5张图片.</p><p>很明显能看到异常的时候会有如下的报错log,到这里hal就没有收到任何拍照请求.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上一张拍照请求到hal,下述<span class="built_in">log</span>. pic_req =1 ，拍照请求到hal 查收了</span></span><br><span class="line">05-13 17:32:18.966   560 12747 D Cam3HWI : 2317, processCaptureRequest: camId=0, bufs_num=2, frame_num=49, cap_intent=2, pic_req=1, first_regular_req=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">已经报错</span></span><br><span class="line">05-13 16:53:39.869  8798 12489 W ImageReader_JNI: Unable to acquire a buffer item, very likely client tried to acquire more than maxImages buffers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面就无法打印出对应的拍照请求.</span></span><br></pre></td></tr></table></figure><h1 id="2-JNI"><a href="#2-JNI" class="headerlink" title="2 JNI"></a>2 JNI</h1><p>我们camera相关的会涉及如下路径的JNI<br>frameworks&#x2F;base&#x2F;media&#x2F;jni      (这个是多媒体相关的，主要涉及到拍照的image相关的内容)</p><p>编译的so 为libmedia_jni.so</p><p>frameworks&#x2F;base&#x2F;core&#x2F;jni</p><p>编译的so为libandroid_runtime.so</p><p>具体查看编译什么可以去看对应目录文件下Android.bp文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cc_library_shared &#123;</span><br><span class="line">    name: <span class="string">&quot;libandroid_runtime&quot;</span>,</span><br><span class="line">    host_supported: true,</span><br><span class="line">    cflags: [</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc_library_shared &#123;</span><br><span class="line">    name: <span class="string">&quot;libmedia_jni&quot;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举个例子<br>1.android_hardware_Camera.cpp 这个文件中如下的内容:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod camMethods[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;getNumberOfCameras&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()I&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)android_hardware_Camera_getNumberOfCameras &#125;,</span><br></pre></td></tr></table></figure><p>对于java hardware 中的虚函数  getNumberOfCameras使用的实际方法是通过这个JNI的方法映射过来. 实际使用函数是这个文件中的android_hardware_Camera_getNumberOfCameras</p><ol start="2"><li></li></ol><p><code>ImageReader</code>允许应用程序直接获取渲染到<code>surface</code>的图形数据，并转换为图片</p><p>更为详细的内容可以查阅<a href="https://developer.android.google.cn/reference/android/media/ImageReader.html">https://developer.android.google.cn/reference/android/media/ImageReader.html</a></p><p>frameworks&#x2F;base&#x2F;media&#x2F;java&#x2F;android&#x2F;media&#x2F;ImageReader.java中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">nativeImageSetup</span><span class="params">(Image i)</span>;</span><br></pre></td></tr></table></figure><p>实际上调用的是如下位置的内容.下述是其映射关系.</p><p>frameworks&#x2F;base&#x2F;media&#x2F;jni&#x2F;android_media_ImageReader.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gImageReaderMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;nativeClassInit&quot;</span>,        <span class="string">&quot;()V&quot;</span>,                        (<span class="type">void</span>*)ImageReader_classInit &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeInit&quot;</span>,             <span class="string">&quot;(Ljava/lang/Object;IIIIJ)V&quot;</span>,  (<span class="type">void</span>*)ImageReader_init &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeClose&quot;</span>,            <span class="string">&quot;()V&quot;</span>,                        (<span class="type">void</span>*)ImageReader_close &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeReleaseImage&quot;</span>,     <span class="string">&quot;(Landroid/media/Image;)V&quot;</span>,   (<span class="type">void</span>*)ImageReader_imageRelease &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeImageSetup&quot;</span>,       <span class="string">&quot;(Landroid/media/Image;)I&quot;</span>,   (<span class="type">void</span>*)ImageReader_imageSetup &#125;, </span><br><span class="line">    &#123;<span class="string">&quot;nativeGetSurface&quot;</span>,       <span class="string">&quot;()Landroid/view/Surface;&quot;</span>,   (<span class="type">void</span>*)ImageReader_getSurface &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeDetachImage&quot;</span>,      <span class="string">&quot;(Landroid/media/Image;)I&quot;</span>,   (<span class="type">void</span>*)ImageReader_detachImage &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeDiscardFreeBuffers&quot;</span>, <span class="string">&quot;()V&quot;</span>,                      (<span class="type">void</span>*)ImageReader_discardFreeBuffers &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/13/13qiodPny2csMCW.png" alt="JNI.png"></p><h1 id="3-追溯原因"><a href="#3-追溯原因" class="headerlink" title="3 追溯原因"></a>3 追溯原因</h1><p>报错内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">05-13 16:53:39.869  8798 12489 W ImageReader_JNI: Unable to acquire a buffer item, very likely client tried to acquire more than maxImages buffers</span><br></pre></td></tr></table></figure><p>报错位置:frameworks&#x2F;base&#x2F;media&#x2F;jni&#x2F;android_media_ImageReader.cpp.我们可以把相关的logv 都改成可以打印出的loge看具体的差异.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jint <span class="title">ImageReader_imageSetup</span><span class="params">(JNIEnv* env, jobject thiz, jobject image)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;%s:&quot;</span>, __FUNCTION__);</span><br><span class="line">    JNIImageReaderContext* ctx = <span class="built_in">ImageReader_getContext</span>(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>,</span><br><span class="line">                <span class="string">&quot;ImageReader is not initialized or was already closed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferItemConsumer* bufferConsumer = ctx-&gt;<span class="built_in">getBufferConsumer</span>();</span><br><span class="line">    BufferItem* buffer = ctx-&gt;<span class="built_in">getBufferItem</span>();<span class="comment">//看这个函数的调用</span></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Unable to acquire a buffer item, very likely client tried to acquire more than&quot;</span></span><br><span class="line">            <span class="string">&quot; maxImages buffers&quot;</span>); <span class="comment">//这是报错的位置.我们看buffer 为NULL,打印了这个log</span></span><br><span class="line">        <span class="keyword">return</span> ACQUIRE_MAX_IMAGES;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BufferItem* <span class="title">JNIImageReaderContext::getBufferItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBuffers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//&lt;==== 这是实际返回的NULL,说明mBuffers.empty()是为空了.然后往下面的内容看构造函数.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return a BufferItem pointer and remove it from the list</span></span><br><span class="line">    List&lt;BufferItem*&gt;::iterator it = mBuffers.<span class="built_in">begin</span>();   <span class="comment">//用一块，擦一块</span></span><br><span class="line">    BufferItem* buffer = *it;</span><br><span class="line">    mBuffers.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JNIImageReaderContext::<span class="built_in">JNIImageReaderContext</span>(JNIEnv* env,</span><br><span class="line">        jobject weakThiz, jclass clazz, <span class="type">int</span> maxImages) :</span><br><span class="line">    <span class="built_in">mWeakThiz</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(weakThiz)),</span><br><span class="line">    <span class="built_in">mClazz</span>((jclass)env-&gt;<span class="built_in">NewGlobalRef</span>(clazz)),</span><br><span class="line">    <span class="built_in">mFormat</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">mDataSpace</span>(HAL_DATASPACE_UNKNOWN),</span><br><span class="line">    <span class="built_in">mWidth</span>(<span class="number">-1</span>),</span><br><span class="line">    <span class="built_in">mHeight</span>(<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxImages; i++) &#123;   <span class="comment">//这是构造上述BufferItem的内容,只申请了4块空间.</span></span><br><span class="line">        BufferItem* buffer = <span class="keyword">new</span> BufferItem;</span><br><span class="line">        mBuffers.<span class="built_in">push_back</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关路径:frameworks&#x2F;base&#x2F;media&#x2F;java&#x2F;android&#x2F;media&#x2F;ImageReader.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to acquire the next image from the underlying native implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that unexpected failures will throw at the JNI level.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> si A blank SurfaceImage.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> One of the &#123;<span class="doctag">@code</span> ACQUIRE_*&#125; codes that determine success or failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ACQUIRE_MAX_IMAGES</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ACQUIRE_NO_BUFS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ACQUIRE_SUCCESS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">acquireNextSurfaceImage</span><span class="params">(SurfaceImage si)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mCloseLock) &#123;</span><br><span class="line">        <span class="comment">// A null image will eventually be returned if ImageReader is already closed.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> ACQUIRE_NO_BUFS;</span><br><span class="line">        <span class="keyword">if</span> (mIsReaderValid) &#123;</span><br><span class="line">            status = nativeImageSetup(si);<span class="comment">//这边会对应到JNI android_media_ImageReader的对应方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE_SUCCESS:</span><br><span class="line">                si.mIsImageValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE_NO_BUFS:</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE_MAX_IMAGES: <span class="comment">//这是JNI 上报的最大值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Unknown nativeImageSetup return code &quot;</span> + status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only keep track the successfully acquired image, as the native buffer is only mapped</span></span><br><span class="line">        <span class="comment">// for such case.</span></span><br><span class="line">        <span class="keyword">if</span> (status == ACQUIRE_SUCCESS) &#123;</span><br><span class="line">            mAcquiredImages.add(si);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/16/EXj5iBuNPFo3cy4.png" alt="JNI.png"></p><p>相关log 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CameraService: CameraService::connect call</span><br><span class="line">Camera2ClientBase: Camera 0: Opened</span><br><span class="line">CameraDeviceClient: CameraDeviceClient</span><br><span class="line">open_: open camera</span><br><span class="line">hal3: Constructor</span><br><span class="line">cap_intent=2</span><br><span class="line">ImageReader_JNI</span><br></pre></td></tr></table></figure><p>这是三方打开相机JNI的相关log.这里我们能清楚看到maxImages的值为4. 这也解释通这个三方apk只能拍4张照片的原因.一旦超过4张照片就不再申请新的buffer去拍照存第5张图片.而我们正常apk  有的设置拍照8张后会立马清空缓冲，然后重新拍照,所以不存在这个问题.也有平台专门对JNI进行更好的兼容,所以也不存在这个问题.但是目前看来这个apk 在mtk 和高通不同的项目上也存在拍照4张后无法拍第5张的情况.说明这个apk 确定很拉胯.而且平板项目这个apk没有拍照的功能.</p><p><img src="https://s2.loli.net/2022/05/16/NLPwStgWZJ1hRi5.png" alt="2022-05-16 14-21-45 的屏幕截图.png"></p><h1 id="4-修改方案"><a href="#4-修改方案" class="headerlink" title="4 修改方案"></a>4 修改方案</h1><p>在acquireNextSurfaceImage拿buffer 满的时候.给它逐一释放关闭.image.close();</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/media/java/android/media/ImageReader.java b/media/java/android/media/ImageReader.java</span></span><br><span class="line"><span class="comment">index 87c3bb9..8b7f8d0 100644</span></span><br><span class="line"><span class="comment">--- a/media/java/android/media/ImageReader.java</span></span><br><span class="line"><span class="comment">+++ b/media/java/android/media/ImageReader.java</span></span><br><span class="line"><span class="meta">@@ -36,6 +36,7 @@</span></span><br><span class="line"> import java.util.List;</span><br><span class="line"> import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"> import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="addition">+import android.util.Log;</span></span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line">  * &lt;p&gt;The ImageReader class allows direct application access to image data</span><br><span class="line"><span class="meta">@@ -58,7 +59,7 @@</span></span><br><span class="line">  * production rate.&lt;/p&gt;</span><br><span class="line">  */</span><br><span class="line"> public class ImageReader implements AutoCloseable &#123;</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+    private final static String TAG = &quot;qtf&quot;;</span></span><br><span class="line">     /**</span><br><span class="line">      * Returned by nativeImageSetup when acquiring the image was successful.</span><br><span class="line">      */</span><br><span class="line"><span class="meta">@@ -469,6 +470,10 @@</span></span><br><span class="line">                     si.mIsImageValid = true;</span><br><span class="line">                 case ACQUIRE_NO_BUFS:</span><br><span class="line">                 case ACQUIRE_MAX_IMAGES:</span><br><span class="line"><span class="addition">+                    for(Image image : mAcquiredImages)&#123;  //sprd_qtf</span></span><br><span class="line"><span class="addition">+                        image.close();</span></span><br><span class="line"><span class="addition">+                        &#125;</span></span><br><span class="line"><span class="addition">+                    Log.i(TAG, &quot;imageBuffer has been clear!&quot;);</span></span><br><span class="line">                     break;</span><br><span class="line">                 default:</span><br><span class="line">                     throw new AssertionError(&quot;Unknown nativeImageSetup return code &quot; + status);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3rd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3rd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下openCV搭建</title>
      <link href="/2024/11/10/%E6%90%AD%E5%BB%BA/linux%E4%B8%8BopenCV%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/11/10/%E6%90%AD%E5%BB%BA/linux%E4%B8%8BopenCV%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-依赖项"><a href="#1-依赖项" class="headerlink" title="1 依赖项"></a>1 依赖项</h1><p>先下载好相关的依赖项目.确保编译成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libdc1394-22-dev</span><br><span class="line">sudo apt-get install libopencv-dev</span><br></pre></td></tr></table></figure><h1 id="2-源码编译"><a href="#2-源码编译" class="headerlink" title="2 源码编译"></a>2 源码编译</h1><p>clone 源码,我在gitee上放了一份。但是呢，实际上cmake的时候,部分内容还是会链接到github上。如果某些同学连接不到github的网站,那也没辙。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/joenero/opencv.git</span><br></pre></td></tr></table></figure><p>进入源码目录,创建一个单独文件build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd opencv</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><p>cmake 一下到&#x2F;usr&#x2F;local&#x2F;目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..</span><br></pre></td></tr></table></figure><p>执行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j8</span><br></pre></td></tr></table></figure><p>将make生成的文件下载到系统目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h1><p>用vim打开这个文件。因为这些只读文件。有些文本编辑器可能无法强制修改。但是vim是万能的。强制保存命令为 : w ! sudo tee %</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br></pre></td></tr></table></figure><p>在打开的文件添加makefile安装路劲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h1 id="4示例代码"><a href="#4示例代码" class="headerlink" title="4示例代码"></a>4示例代码</h1><h2 id="4-1-cmake"><a href="#4-1-cmake" class="headerlink" title="4.1 cmake"></a>4.1 cmake</h2><p>cmakelist.txt添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include_directories(/usr/local/include/opencv4/opencv2)</span><br><span class="line">set (OpenCV_LIBS /usr/local/lib)</span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">target_link_libraries(helloCV $&#123;OpenCV_LIBS&#125;) #helloCV 工程名字</span><br></pre></td></tr></table></figure><p>完整的cmakelist.txt如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(myTool)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/local/<span class="keyword">include</span>/opencv4/opencv2)</span><br><span class="line"><span class="keyword">set</span> (OpenCV_LIBS /usr/local/lib)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(myTool main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myTool <span class="variable">$&#123;OpenCV_LIBS&#125;</span>) <span class="comment">#helloCV 工程名字</span></span><br></pre></td></tr></table></figure><p>demon代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;../test.jpeg&quot;</span>);</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;img;</span></span><br><span class="line">    <span class="keyword">if</span>(img.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;My picture: &quot;</span>&lt;&lt; img.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>,img);</span><br><span class="line">    <span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果出现报错： Gtk-Message: 21:57:35.293: Failed to load module “canberra-gtk-module” 则安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libcanberra-gtk-module</span><br></pre></td></tr></table></figure><h2 id="4-2-Qt使用"><a href="#4-2-Qt使用" class="headerlink" title="4.2 Qt使用"></a>4.2 Qt使用</h2><p>在.pro文件中添加如下内容,根据个人情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /usr/local/include \</span><br><span class="line">                /usr/local/include/opencv4 \</span><br><span class="line"></span><br><span class="line">LIBS += /usr/local/lib/libopencv*</span><br></pre></td></tr></table></figure><p>出现这个错误，只需要在对应的文件中添加头文件<br>#include &lt;opencv2&#x2F;highgui&#x2F;highgui_c.h&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OpenNCC_View/widget.cpp:330: error: ~~‘cvGetWindowHandle’~~ was not declared in this scope</span><br><span class="line">                 if (!cvGetWindowHandle(&quot;OpenNCC&quot;))</span><br><span class="line">                      ^~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令之AWK过滤提取需要的信息</title>
      <link href="/2024/11/10/Linux/Linux-%E5%91%BD%E4%BB%A4%E4%B9%8BAWK%E8%BF%87%E6%BB%A4%E6%8F%90%E5%8F%96%E9%9C%80%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/11/10/Linux/Linux-%E5%91%BD%E4%BB%A4%E4%B9%8BAWK%E8%BF%87%E6%BB%A4%E6%8F%90%E5%8F%96%E9%9C%80%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>AWK是一个优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人阿尔佛雷德·艾侯、彼得·温伯格和布莱恩·柯林汉姓氏的首个字母）的最大功能取决于一个人所拥有的知识。awk经过改进生成的新的版本nawk,gawk，现在默认linux系统下日常使用的是gawk，用命令可以查看正在应用的awk的来源（ls -l &#x2F;bin&#x2F;awk ）</p><h1 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2 基本用法"></a>2 基本用法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;pattern + action&#125;&#x27;</span> &lt;file&gt;</span><br></pre></td></tr></table></figure><p>pattern表示在数据中要查找的内容</p><p>action是要执行的一系列的命令</p><p>awk 通过指定分隔符，将一行分为多个字段，依次用 $1、$2 … $n 表示第一个字段、第二个字段… 第n个字段。</p><p>举例有以下一个文件。我们已经知道的格式如下。想过滤的PSS和RSS之后的文件，对应的字段是3和6。通过以下命令即可过滤出第3个字段和第6个字段的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TOTAL PSS:   102206            TOTAL RSS:   127132      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102438            TOTAL RSS:   127364      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102494            TOTAL RSS:   127420      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102578            TOTAL RSS:   127504      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102610            TOTAL RSS:   127536      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102558            TOTAL RSS:   127484      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102378            TOTAL RSS:   127304      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102594            TOTAL RSS:   127520      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102554            TOTAL RSS:   127480      TOTAL SWAP (KB):        0</span><br><span class="line">TOTAL PSS:   102262            TOTAL RSS:   127188      TOTAL SWAP (KB):        0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $3, $6&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure><h2 id="2-1-分隔符"><a href="#2-1-分隔符" class="headerlink" title="2.1 分隔符"></a>2.1 分隔符</h2><p>awk默认分割符是空格和制表符,上面的例子中,若希望把逗号去掉则加 -F即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &#x27;:|,&#x27; &#x27;&#123;print $3 $6&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure><p>这里制定冒号（:）和逗号（,）作为作为分割符号</p><h2 id="2-2-条件判断"><a href="#2-2-条件判断" class="headerlink" title="2.2 条件判断"></a>2.2 条件判断</h2><p>将第三个字段满足小于102262的数字真与否打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $3&lt;102262&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>将第三个字段满足小于102262的那一行的信息打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;$3 &lt;102262 &#123;print $0&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure><p>打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOTAL PSS:   102206            TOTAL RSS:   127132      TOTAL SWAP (KB):        0</span><br></pre></td></tr></table></figure><h2 id="2-3-统计计算"><a href="#2-3-统计计算" class="headerlink" title="2.3 统计计算"></a>2.3 统计计算</h2><h3 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;max=0&#125; &#123;if($3&gt;max) max=$3&#125; END &#123;print &quot;max PSS:&quot;, max&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure><h3 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;min=102262&#125; &#123;if($3&lt;min) min=$3&#125; END &#123;print &quot;min PSS:&quot;, min&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure><h3 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;sum=0&#125; &#123;sum+=$3&#125; END &#123;print &quot;mean steer:&quot;, sum/NR&#125;&#x27; hal_PSS.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火焰图抓取</title>
      <link href="/2024/11/10/Android/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%8A%93%E5%8F%96/"/>
      <url>/2024/11/10/Android/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%8A%93%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>Simpleperf 是 Android 的原生 CPU 分析工具。 它可用于分析 Android 应用程序和在 Android 上运行的本机进程。 它可以在 Android 上分析 Java 和 C++ 代码。 simpleperf 可执行文件可以在 Android &gt;&#x3D;L 上运行，而 Python 脚本可以在 Android &gt;&#x3D; N 上使用。</p><p>火焰图是基于 perf 结果产生的 SVG 图片，用来展示进程在一段时间 CPU 的调用栈。</p><p>现代的CPU具有一个硬件组件，称为性能监控单元(PMU)。PMU具有一些硬件计数器，计数一些诸如 经历了多少次CPU周期，执行了多少条指令，或发生了多少次缓存未命中 等的事件。</p><p>Linux内核将这些硬件计数器包装到硬件perf事件 (hardware perf events)中。此外，Linux内核还提供了独立于硬件的软件事件和跟踪点事件。Linux内核通过 perf_event_open 系统调用将这些都暴露给了用户空间，这正是simpleperf所使用的机制。</p><p>Simpleperf具有三个主要的功能：stat,record 和 report。</p><p>Stat命令给出了在一个时间段内被分析的进程中发生了多少事件的摘要。以下是它的工作原理：</p><pre><code>给定用户选项，simpleperf通过对linux内核进行系统调用来启用分析。Linux 内核在调度到被分析进程时启用计数器。分析之后，simpleperf从内核读取计数器，并报告计数器摘要。</code></pre><p>Record 命令在一段时间内记录剖析进程的样本。它的工作原理如下：</p><pre><code>给定用户选项，simpleperf通过对linux内核进行系统调用来启用分析。Simpleperf 在simpleperf 和 linux 内核之间创建映射缓冲区。Linux 内核在调度到被分析进程时启用计数器。每次给定数量的事件发生时，linux 内核将样本转储到映射缓冲区。Simpleperf 从映射缓冲区读取样本并生成 perf.data。</code></pre><p>Report 命令读取 “perf.data” 文件及所有被剖析进程用到的共享库，并输出一份报告，展示时间消耗在了哪里。</p><h1 id="2-抓取火焰图"><a href="#2-抓取火焰图" class="headerlink" title="2 抓取火焰图"></a>2 抓取火焰图</h1><p>simpleperf是集成在谷歌内部.直接使用即可</p><p>抓取30s的perf.data 路径随便你. 我一般放在data&#x2F;vendor&#x2F;camera_dump</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb shell simpleperf record -p 13248 -g --duration 30 -o /sdcard/perf.data</span><br><span class="line"></span><br><span class="line">adb shell simpleperf record -p 1791 -g --duration 30 -o /data/vendor/camera_dump/simpleperf_mcu.data</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">adb shell 进入到手机:</span><br><span class="line">simpleperf record -g -p `pidof cameraserver` --duration 60 -o /sdcard/perf.data</span><br><span class="line">simpleperf record -g -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data</span><br><span class="line">//示例中的 &quot; -p 13248 &quot; 指的是需要分析的进程号 </span><br><span class="line">//示例中的 &quot; -p 1791 &quot; 指的是需要分析的进程号 </span><br></pre></td></tr></table></figure><h1 id="3-SDK火焰图"><a href="#3-SDK火焰图" class="headerlink" title="3 SDK火焰图"></a>3 SDK火焰图</h1><p>谷歌官网下载Android NDK： <a href="https://developer.android.google.cn/ndk/downloads/">https://developer.android.google.cn/ndk/downloads/</a></p><p>进入到android-ndk-r25b-linux&#x2F;android-ndk-r25b&#x2F;simpleperf<br>将上述生产的perf.data文件拉取出来放到这个同级目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/perf.data</span><br></pre></td></tr></table></figure><p>直接运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python report_html.py</span><br></pre></td></tr></table></figure><p>会生成对应的火焰图.这个火焰图有三种呈现方式.呈现的偏重点不一样.</p><p>以下都是进入到adb shell中执行操作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MCPS每秒百万个时钟</span><br><span class="line">（Million Clocks Per Second）</span><br><span class="line">simpleperf record -g -e cpu-cycles -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data --call-graph dward</span><br><span class="line"></span><br><span class="line">MIPS每秒数百万条指令</span><br><span class="line">（Million Instructions Per Second）</span><br><span class="line">simpleperf record -g -e instructions -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data --call-graph dward</span><br><span class="line"></span><br><span class="line">MCPS_MIPS:</span><br><span class="line">simpleperf record -g -e cpu-cycles,instructions -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data --call-graph dward</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以将相关线程合入到一个报告表中</span></span><br><span class="line">simpleperf record -g -e cpu-cycles,instructions -p `pidof camerahalserver`,`pidof cameraserver`,`pidof com.sec.android.app.camera` --duration 60 -o /sdcard/perf.data --call-graph dward</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">simpleperf record -g --exclude-pid 813 880 11872 --duration 60 -o /sdcard/perf.data --call-graph dwarf</span><br><span class="line"></span><br><span class="line">-e cpu-cycles</span><br><span class="line"></span><br><span class="line">python report_html.py</span><br></pre></td></tr></table></figure><h1 id="4-分析火焰图"><a href="#4-分析火焰图" class="headerlink" title="4 分析火焰图"></a>4 分析火焰图</h1><p>火焰图x-y轴代表</p><ul><li><p>x轴代表的不是时间,而是采样总量</p></li><li><p>y轴代表方法的调用栈深度,倘若方法调用用的越多,火焰越高,顶部的栈就是当前正在执行的方法</p></li></ul><p>栈宽含义(cpu时间)</p><ul><li>宽度可以理解为CPU采样率的占比,越宽代表当前栈在采样数中占比高,其可能为三种含义:<ol><li>函数运行时间较长</li><li>该函数被调用次数多</li></ol></li></ul><p>平顶现象：</p><ul><li>平顶现象是由于当前程序的采样数在总采样数中占用过高导致的,出现这种现象需要特意关注一下程序具体的调用栈,采样比例占用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章入门python去写shell</title>
      <link href="/2024/11/10/Python/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A5%E9%97%A8python%E5%8E%BB%E5%86%99shell/"/>
      <url>/2024/11/10/Python/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A5%E9%97%A8python%E5%8E%BB%E5%86%99shell/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h1><p>有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（比如 Windows 下的 .exe 文件），比如C语言、<a href="http://c.biancheng.net/cplus/">C++</a>、Golang、<a href="http://c.biancheng.net/asm/">汇编语言</a>等，它们都属于<strong>编译型语言</strong>，使用的转换工具称为<strong>编译器</strong>。</p><p>有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 <a href="http://c.biancheng.net/python/">Python</a>、<a href="http://c.biancheng.net/js/">JavaScript</a>、<a href="http://c.biancheng.net/php/">PHP</a>、Shell 等，这类编程语言称为<strong>解释型语言</strong>，使用的转换工具称为<strong>解释器</strong></p><p>注意:python使用的是对其方式来区分同一级的逻辑控制。不使用分号(；)所以设置的时候，一定要设置好一个tab对4个空格，不要使用tab,不然换到其他编辑器中，容易报语法错误。tab和空格不要混用。</p><p>python 中都是通过import去导入一些系统包或者自己写的包。这个和java的操作很相似,也和c中的#include &lt;某些.h&gt;相似。</p><p>毕竟市面上绝大多数的python的底层逻辑都是用c去写的。</p><p>加减乘除取余就不赘述了。所有编程的语法都是大同小异的。</p><p>python在linux的环境下不需要安装，我们使用的图形化界面都是以python和一些桌面管理为基础的。</p><p>一般存在的路径在&#x2F;usr&#x2F;bin&#x2F;python, 查看python 默认的版本,直接python -v</p><p>python文件开头解释器说明。我是用python3版本的。编码格式为utf-8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p>函数入口我一般是这样定义的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后在定义出main函数的运行内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">执行语句</span><br></pre></td></tr></table></figure><h2 id="1-1-流程控制"><a href="#1-1-流程控制" class="headerlink" title="1.1 流程控制"></a>1.1 流程控制</h2><p>选择控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ifTest</span>():</span><br><span class="line">    i = random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;随机生成的数字为&quot;</span>,i)</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;是个偶数&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;是个奇数&quot;</span>)</span><br></pre></td></tr></table></figure><p>选择控制的格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">执行命令</span><br><span class="line"><span class="keyword">elif</span> 条件:</span><br><span class="line">执行命令</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">执行命令</span><br></pre></td></tr></table></figure><p>循环控制 while循环和for循环的示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">whileTest</span>(<span class="params">i</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> :</span><br><span class="line">        i -=<span class="number">1</span></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;循环的第&quot;</span>,count,<span class="string">&quot;次&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forTest</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;循环的第&quot;</span>,count,<span class="string">&quot;次&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,i,<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;步进循环的第&quot;</span>,count,<span class="string">&quot;次&quot;</span>)</span><br></pre></td></tr></table></figure><p>python不提供switch语句。虽然可以自己实现，但是我觉得没啥必要的。</p><h2 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h2><p>python中有6个标准的数据类型:</p><ul><li>Number(数字型号)</li><li>String(字符串型号)</li><li>List(列表)</li><li>Tuple(元组)</li><li>Sets(集合)</li><li>Dictionaries(字典)</li></ul><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>int(x) 将x转换为一个整数。</p><p>float(x) 将x转换到一个浮点数。</p><p>complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。</p><p>complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>字符串直接拿引号包起来就可以了。</p><p>索引下标[-1]表示倒数第一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">s1 = s[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s[0] = &#x27;</span> + s1)   <span class="comment">#s[0] = 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s[3] = &#x27;</span>+ s[<span class="number">3</span>])  <span class="comment">#s[3] = 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;倒数第三个数为：&#x27;</span> + s[-<span class="number">3</span>])   <span class="comment">#倒数第三个数为：6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最后一个数为：&#x27;</span> + s[-<span class="number">1</span>])     <span class="comment">#最后一个数为：8</span></span><br></pre></td></tr></table></figure><p>切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">s2 = s[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s[0:3] = &#x27;</span> + s2)     </span><br><span class="line"><span class="comment">#s[0:3] = 012</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;整个字符串如下：&#x27;</span> + s[:])    </span><br><span class="line"><span class="comment">#整个字符串如下：0123456789</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;整个字符串如下：&#x27;</span> + s[<span class="number">0</span>:])   </span><br><span class="line"><span class="comment">#整个字符串如下：0123456789</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;前两个字符：&#x27;</span> + s[:<span class="number">2</span>])      </span><br><span class="line"><span class="comment">#前两个字符：01</span></span><br></pre></td></tr></table></figure><p>跳首</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;01234567489&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>]) <span class="comment">#行首0,行尾6，间隔2 取 打印出024</span></span><br><span class="line"><span class="built_in">print</span>(s[::<span class="number">2</span>])      <span class="comment">#024649</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">4</span>:<span class="number">0</span>:-<span class="number">1</span>])   <span class="comment">#倒着取:4321</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">3</span>::-<span class="number">1</span>])    <span class="comment">#3210</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>::-<span class="number">1</span>])   <span class="comment">#98476543210</span></span><br></pre></td></tr></table></figure><h4 id="常见的字符串操作"><a href="#常见的字符串操作" class="headerlink" title="常见的字符串操作"></a>常见的字符串操作</h4><ul><li><p>大小写操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;adbCDefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;首字母大写&quot;</span>,s.capitalize())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全部大写  &quot;</span>,s.upper())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全部小写  &quot;</span>,s.lower())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大小写互换&quot;</span>,s.swapcase())</span><br></pre></td></tr></table></figure></li><li><p>删除空格操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;  xtt  123&#x27;</span></span><br><span class="line">s_1 = s.strip()             <span class="comment">#删除字符串前后的空格    </span></span><br><span class="line"><span class="built_in">print</span>(s_1)                  <span class="comment">#xtt 123</span></span><br><span class="line">s_2 = s.strip(<span class="string">&#x27;%&#x27;</span>)          <span class="comment">#删除字符串前后的空格 </span></span><br><span class="line"><span class="built_in">print</span>(s_2)                  <span class="comment">#  xtt  123</span></span><br><span class="line">s_3 = s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)     <span class="comment">#替换掉所有的空格</span></span><br><span class="line"><span class="built_in">print</span>(s_3)                  <span class="comment">#使用join()方法将字符串中所有的空格删除</span></span><br><span class="line">s=<span class="string">&#x27; This is a demo code&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(s.split()))   <span class="comment">#Thisisademo</span></span><br><span class="line"><span class="comment">#其中，join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。</span></span><br></pre></td></tr></table></figure></li><li><p>计算字符出现的次数count</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;  xtt  123 xtt&#x27;</span></span><br><span class="line">count = s.count(<span class="string">&quot;t&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(count)  <span class="comment">#打印出现的次数为4次</span></span><br></pre></td></tr></table></figure></li><li><p>分割。split不加任何参数则默认空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;I am the king of amazon!!!&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;I am the: king: of amazon:&#x27;</span></span><br><span class="line">s_1 = s1.split()</span><br><span class="line"><span class="built_in">print</span>(s_1)              <span class="comment">#[&#x27;I&#x27;, &#x27;am&#x27;, &#x27;the&#x27;, &#x27;king&#x27;, &#x27;of&#x27;, &#x27;amazon!!!&#x27;]</span></span><br><span class="line">s_2 = s2.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s_2)              <span class="comment">#[&#x27;I am the&#x27;, &#x27; king&#x27;, &#x27; of amazon&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>格式化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s12_1 = <span class="string">&#x27;我叫&#123;&#125;,今年&#123;&#125;岁，爱好&#123;&#125;,再说一下我叫&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s12_1)  </span><br><span class="line">s12_2 = <span class="string">&#x27;我叫&#123;0&#125;,今年&#123;1&#125;岁，爱好&#123;2&#125;,再说一下我叫&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;学习&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s12_2)</span><br><span class="line">s12_3 = s1 = <span class="string">&#x27;我叫&#123;name&#125;,今年&#123;age&#125;岁，爱好&#123;hobby&#125;,再说一下我叫&#123;name&#125;&#x27;</span>.<span class="built_in">format</span>(name = <span class="string">&#x27;小明&#x27;</span>,age = <span class="number">18</span>,hobby = <span class="string">&#x27;学习&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s12_3)</span><br></pre></td></tr></table></figure></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>list列表可以存放多个值，创建list列表，使用[ ]，多个值之间用逗号隔开，不限制数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 =[<span class="string">&quot;joenero&quot;</span>,<span class="string">&quot;amazon&quot;</span>,<span class="string">&quot;joker&quot;</span>,<span class="string">&quot;father&quot;</span>,<span class="string">&quot;was&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(l1)<span class="comment">#[&#x27;joenero&#x27;, &#x27;amazon&#x27;, &#x27;joker&#x27;, &#x27;father&#x27;, &#x27;was&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(l1[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>])<span class="comment">#[&#x27;joenero&#x27;, &#x27;joker&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(l1[-<span class="number">3</span>:-<span class="number">1</span>])<span class="comment">#[&#x27;joker&#x27;, &#x27;father&#x27;]</span></span><br></pre></td></tr></table></figure><p>list相关的方法如下:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.append(元素)</td><td>向列表最后追加一个元素</td></tr><tr><td>.extend(元素)</td><td>向列表最后追加多个元素</td></tr><tr><td>.insert(下标,元素)</td><td>向指定的下标位置插入元素</td></tr><tr><td>.pop(下标)</td><td>移除下标指定的元素，如果没有指定的下标，则删除最后一个元素</td></tr><tr><td>.remove(元素)</td><td>删除指定元素</td></tr><tr><td>.clear()</td><td>清空列表</td></tr><tr><td>.index(元素)</td><td>获取指定元素在list列表中的第一次出现的下标</td></tr><tr><td>.count(元素)</td><td>统计元素在list列表中出现的次数</td></tr><tr><td>.reverse()</td><td>反转list列表</td></tr><tr><td>.sort()</td><td>排序.默认是升序，降序添加参数:reverse&#x3D;True</td></tr></tbody></table><p>这三比较复杂,会在之后单独拎出来讲解</p><ul><li>Tuple(元组)</li><li>Sets(集合)</li><li>Dictionaries(字典)</li></ul><h1 id="2-添加help参数"><a href="#2-添加help参数" class="headerlink" title="2 添加help参数"></a>2 添加help参数</h1><p>一般我们写一个需要外部输入的参数，我们都需要借用解析器argparse去获取和解析对应的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">help</span>():</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;PSS文件&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-o&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;生成的图片&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="built_in">print</span>(args)  <span class="comment">#打印存储的所有输入值</span></span><br><span class="line">    <span class="built_in">print</span>(args.f)<span class="comment">#打印存储的-f 之后的值</span></span><br><span class="line">    <span class="built_in">print</span>(args.o)<span class="comment">#打印存储的-o 之后的值</span></span><br></pre></td></tr></table></figure><p>然后运行这个py文件后面加-h的参数就可以显示对应的help值</p><p>例如上面的内容显示如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python plot.py -h</span><br><span class="line">usage: plot.py [-h] [-f F] [-o O]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br><span class="line">  -f F        PSS文件</span><br><span class="line">  -o O        生成的图片</span><br></pre></td></tr></table></figure><h1 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3 文件操作"></a>3 文件操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>open</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = open(&quot;fileName.txt&quot;,mode=&quot;r&quot;)</span><br></pre></td></tr></table></figure><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>‘r’</td><td>以「只读」模式打开文件，如果指定文件不存在，则会报错，默认情况下文件指针指向文件开头</td></tr><tr><td>‘w’</td><td>以「只写」模式打开文件，如果文件不存在，则根据 filename 创建相应的文件，如果文件已存在，则会覆盖原文件</td></tr><tr><td>‘a’</td><td>以「追加」模式打开文件，如果文件已存在，文件指针会指向文件尾部，将内容追加在原文件后面，如果文件不存在，则会新建文件且写入内容</td></tr><tr><td>‘t’</td><td>以「文本文件」模式打开文件</td></tr><tr><td>‘b’</td><td>以「二进制」模式打开文件，主要用于打开图片、音频等非文本文件</td></tr><tr><td>‘+’</td><td>打开文件并允许更新（可读可写），也就是说，使用参数 w+、a+ 也是可以读入文件的，在使用的时候，需要注意区别</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;fileName.txt&quot;</span>,mode=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>,num,<span class="string">&quot;行内容:&quot;</span>,line)</span><br><span class="line">    num +=<span class="number">1</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li><li><p>read(): 直接读取整个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;fileName.txt&quot;</span>,mode=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">fileCon = file.read()</span><br><span class="line"><span class="built_in">print</span>(fileCon)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">r&quot;fileName.txt&quot;</span>,mode=<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure></li><li><p>readline():读一行</p></li><li><p>readlines():按行读取所有数据。结果为列表，一行为一个成员。</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>直接举个实际例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@File    : main.py</span></span><br><span class="line"><span class="string">@Author  : JoeNero</span></span><br><span class="line"><span class="string">@Time    : 2022/12/30 16:32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> find_peaks</span><br><span class="line"></span><br><span class="line">fileName = <span class="string">&quot;&quot;</span></span><br><span class="line">outTxt   = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INFO</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.username = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.password = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">help</span>():</span><br><span class="line">    <span class="keyword">global</span> fileName</span><br><span class="line">    <span class="keyword">global</span> outTxt</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;对应的TXT文件&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-o&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;生成的文件&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    fileName = args.f</span><br><span class="line">    outTxt = args.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取解析txt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readTxt</span>(<span class="params">filename</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    aInfo = INFO()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fileinput.<span class="built_in">input</span>(filename):</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            temp = line.split(<span class="string">&#x27;username:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            temp = temp.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="comment"># print(&quot;temp&quot;,temp)</span></span><br><span class="line">            aInfo.username = temp</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            temp = line.split(<span class="string">&#x27;password:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&quot;temp&quot;,temp)</span></span><br><span class="line">            temp = temp.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            aInfo.password = temp</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;username&quot;</span>,aInfo.username,<span class="string">&quot;password&quot;</span>,aInfo.password)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#主函数入口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">help</span>()</span><br><span class="line">    <span class="keyword">if</span> fileName == <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(fileName):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入文件不能为空&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        readTxt(fileName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>我这边是有个外部文件。其格式如下，可以通过以上的内容来读取解析其中的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:xtt</span><br><span class="line">password:123456</span><br></pre></td></tr></table></figure><p>生成临时文件. 路径为&#x2F;tmp&#x2F;tmp06pz62p5 文件名字为随机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    dir_name = tempfile.mkdtemp()</span><br><span class="line">    <span class="built_in">print</span> (dir_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="4-shell"><a href="#4-shell" class="headerlink" title="4 shell"></a>4 shell</h1><p>python有很多操作shell的方式。需要先import 的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><p>第一种方式是直接用os.system(“command”)，其中返回0,表示执行命令成功，明显的缺点是无法将返回的值保存下来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devices = os.system(<span class="string">&quot;adb devices&quot;</span>)</span><br></pre></td></tr></table></figure><p>第二种方式是用os.popen(“command”)</p><p>os.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices = os.popen(<span class="string">&quot;adb devices&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;deviecs = &quot;</span>,devices.read())</span><br></pre></td></tr></table></figure><p>打印输出的结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deviecs =  List of devices attached</span><br><span class="line">L7Z5AABQAILZPBTO        device</span><br></pre></td></tr></table></figure><p>配合下将其修改成如下的内容，就可以把对应的adb设备获取出来，当前只能获取到最上面的那个，可以自己根据逻辑来完善</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices = os.popen(<span class="string">&quot;adb  devices|awk &#x27;&#123;print $1&#125;&#x27;|sed -n &#x27;2p&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;deviecs = &quot;</span>,devices.read())</span><br></pre></td></tr></table></figure><p>注意:popen中主要涉及到文件上的操作，但是一些shell中的sleep和拍照等操作不需要返回值还是用system来操作。</p><p>我实际操作拍照的时候，发现存在的这个问题。popen不生效，只有system的才生效。</p><h1 id="5-类"><a href="#5-类" class="headerlink" title="5 类"></a>5 类</h1><p>python中的类和c++的及其相似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义INFO类,用来存储</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INFO</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.username = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.password = <span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">aInfo = INFO()</span><br><span class="line">aInfo.username = temp</span><br><span class="line">aInfo.password = temp</span><br></pre></td></tr></table></figure><h1 id="6-import"><a href="#6-import" class="headerlink" title="6 import"></a>6 import</h1><p>python import 和包含头文件的用法相似。</p><p>在同一个目录下直接import 文件名即可</p><p>导入模块的方式有如下几种:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hello.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span> ():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello,World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#say.py</span></span><br><span class="line"><span class="keyword">import</span> hello</span><br><span class="line">hello.say()</span><br></pre></td></tr></table></figure><p>临时添加模块完整路径如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&#x27;D:\\python_module&#x27;)</span><br></pre></td></tr></table></figure><p>“from 模块名 import 成员”的形式直接导入指定成员</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda3管理python包环境说明</title>
      <link href="/2024/11/10/%E6%90%AD%E5%BB%BA/anaconda3%E7%AE%A1%E7%90%86python%E5%8C%85%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/11/10/%E6%90%AD%E5%BB%BA/anaconda3%E7%AE%A1%E7%90%86python%E5%8C%85%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>在实际项目开发的时候,我们往往需要不同的python包版本和环境。</p><p>pycharm对此就有很好的器包环境。</p><p>今天要介绍的是anaconda3 这个环境包管理。</p><p>Conda as a package manager helps you find and install packages. If you need a package that requires a different version of Python, you do not need to switch to a different environment manager, because conda is also an environment manager. With just a few commands, you can set up a totally separate environment to run that different version of Python, while continuing to run your usual version of Python in your normal environment.</p><p>—-Conda官网</p><p>anaconda相当于一个包的管理者，去管理这些不同的环境，你可以本地建立多个虚拟环境，并且互相不影响。</p><h1 id="2-安装配置"><a href="#2-安装配置" class="headerlink" title="2 安装配置"></a>2 安装配置</h1><p>下载官网<a href="http://continuum.io/downloads">http://continuum.io/downloads</a></p><p>下载下来一路回车,配置好对应的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 Anaconda3-2021.11-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-2021.11-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>添加conda环境变量,根据本地下载的实际地方路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">export PATH=~/anaconda3/bin:$PATH</span><br></pre></td></tr></table></figure><p>由于我本地需要一个测试ITS的环境,并且在R版本和S版本的架构中.python的版本要求也不同,所以我同时也需要本地有python2和python3</p><p>新建一个环境，设定的python版本为python2.7，然后会跳出给你安装的相关配置，一路回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py2 python=2.7</span><br></pre></td></tr></table></figure><p>激活环境命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate py2</span><br></pre></td></tr></table></figure><p>退出当前环境命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>需要在当前环境下安装对应的pip包之前需要先激活对应的环境，然后pip安装即可</p><p>以下是我ITS S版本的python环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py3 python=3.7.9 #这表示创建python版本为3.7.9 ,名字为py3的虚拟环境。不加python=版本 默认是2.7版本</span><br><span class="line">conda activate py3 #激活并进入py3。</span><br><span class="line">conda install opencv=3.4.2 //安装3.4.2版本的opencv 遇见选择Y/N 选择Y 下面都一样</span><br><span class="line">conda install numpy=1.19.2 //安装1.19.2版本的numpy</span><br><span class="line">conda install matplotlib=3.3.2 //安装3.3.2版本的matplotlib</span><br><span class="line">conda install scipy=1.5.2 //安装1.5.2版本的scipy</span><br><span class="line">conda install pyserial=3.5 //安装3.5版本的pyserial</span><br><span class="line">conda install pillow=8.1.0 //安装8.1.0版本的pillow</span><br><span class="line">conda install pyyaml=5.3.1 //安装5.3.1版本的pyyaml</span><br><span class="line">pip install mobly //安装mobly</span><br></pre></td></tr></table></figure><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h1><p>这边搭建一个AI环境为例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pyAI python=3.7.9</span><br><span class="line">conda activate pyAI #激活并进入环境</span><br><span class="line">pip list #查看当前pip 的包</span><br><span class="line">pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install scikit-learn -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br><span class="line">pip install scipy -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install jupyter -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install nltk -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install jiaba -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install tensorflow -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install tensorflow_addons  -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>AI安装好，运行如下命令打开对应的界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><h1 id="4-使用命令"><a href="#4-使用命令" class="headerlink" title="4 使用命令"></a>4 使用命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs  #查看存在的环境</span><br><span class="line">conda activate 环境 #激活对应的环境</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android编码文件概述</title>
      <link href="/2024/11/10/Android/Android%E7%BC%96%E7%A0%81%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/11/10/Android/Android%E7%BC%96%E7%A0%81%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>需要小心的是修改item后要注意CTS测项testGetWithId(android.media.cts.CamcorderProfileTest)，也就是high profile一定要和分辨率的profile适配，比如spec为1920 x 1080的spec(平台所supprot的)<br>那么high的分辨率和1080p的分辨率一定要一样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EncoderProfile</span> <span class="attr">quality</span>=<span class="string">&quot;1080p&quot;</span> <span class="attr">fileFormat</span>=<span class="string">&quot;3gp&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">Video</span> <span class="attr">codec</span>=<span class="string">&quot;h264&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">bitRate</span>=<span class="string">&quot;17000000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">width</span>=<span class="string">&quot;1920&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">Audio</span> <span class="attr">codec</span>=<span class="string">&quot;aac&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">bitRate</span>=<span class="string">&quot;128000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">sampleRate</span>=<span class="string">&quot;48000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">channels</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">EncoderProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EncoderProfile</span> <span class="attr">quality</span>=<span class="string">&quot;high&quot;</span> <span class="attr">fileFormat</span>=<span class="string">&quot;3gp&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Video</span> <span class="attr">codec</span>=<span class="string">&quot;h264&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bitRate</span>=<span class="string">&quot;17000000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">width</span>=<span class="string">&quot;1920&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">frameRate</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Audio</span> <span class="attr">codec</span>=<span class="string">&quot;aac&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bitRate</span>=<span class="string">&quot;128000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">sampleRate</span>=<span class="string">&quot;48000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">channels</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">EncoderProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-标准尺寸"><a href="#2-标准尺寸" class="headerlink" title="2 标准尺寸"></a>2 标准尺寸</h1><p>详细参考谷歌官网说明:</p><p><a href="https://developer.android.com/reference/android/media/CamcorderProfile.html#QUALITY_1080P">https://developer.android.com/reference/android/media/CamcorderProfile.html#QUALITY_1080P</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static final int QUALITY_1080P </span><br><span class="line">public static final int QUALITY_2160P</span><br><span class="line">public static final int QUALITY_2K</span><br><span class="line">public static final int QUALITY_480P</span><br><span class="line">public static final int QUALITY_4KDCI</span><br><span class="line">public static final int QUALITY_720P</span><br><span class="line">public static final int QUALITY_8KUHD</span><br><span class="line">public static final int QUALITY_CIF</span><br><span class="line">public static final int QUALITY_HIGH</span><br><span class="line">public static final int QUALITY_HIGH_SPEED_1080P</span><br></pre></td></tr></table></figure><table><thead><tr><th>标准尺寸</th><th></th><th>常量值</th></tr></thead><tbody><tr><td>QUALITY_1080P</td><td>1920x1080</td><td>6          (0x00000006)</td></tr><tr><td>QUALITY_2160P</td><td>3840x2160</td><td>8          (0x00000008)</td></tr><tr><td>QUALITY_2K</td><td>2048x1080</td><td>12          (0x0000000c)</td></tr><tr><td>QUALITY_480P</td><td>720 x 480</td><td>4          (0x00000004)</td></tr><tr><td>QUALITY_4KDCI</td><td>4096 x 2160</td><td>10          (0x0000000a)</td></tr><tr><td>QUALITY_720P</td><td>1280 x 720</td><td>5          (0x00000005)</td></tr><tr><td>QUALITY_8KUHD</td><td>7680 x 4320</td><td>13          (0x0000000d)</td></tr><tr><td>QUALITY_CIF</td><td>352 x 288</td><td>3          (0x00000003)</td></tr><tr><td>QUALITY_HIGH</td><td>Quality level corresponding to the highest available resolution.</td><td>1          (0x00000001)</td></tr><tr><td>QUALITY_HIGH_SPEED_1080P</td><td>High speed ( &gt;&#x3D; 100fps) quality level corresponding to the 1080p (1920 x 1080 or 1920x1088) resolution.</td><td>2004          (0x000007d4)</td></tr><tr><td>QUALITY_HIGH_SPEED_2160P</td><td>High speed ( &gt;&#x3D; 100fps) quality level corresponding to the 2160p (3840 x 2160) resolution.</td><td>2005          (0x000007d5)</td></tr></tbody></table><p>可以通过如下代码获取到所支持的编码尺寸</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static EncoderProfiles getAll (String cameraId, </span><br><span class="line">                int quality)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个文件实际对应camera video 调用关系.</span><br><span class="line"></span><br><span class="line">系统启动后，通过CamcorderProfile.java：static&#123; &#125; 块，初始化并解析好。以供上层获取。</span><br><span class="line"></span><br><span class="line">进入录像模式后：VideoMode.java：initRecorder——&gt;configRecoderSpec——&gt;getProfile，去获取摄像头或录像的默认配置。</span><br><span class="line"></span><br><span class="line">native层主要是在 /frameworks/av/media/libmedia/MediaProfiles.cpp 文件里加载和检查参数。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake基础</title>
      <link href="/2024/11/10/CPP/cmake%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/10/CPP/cmake%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>选自百度百科:</p><p>CMake是一个跨平台的安装（<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fromModule=lemma_inlink">编译</a>）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067?fromModule=lemma_inlink">编译器</a>所支持的C++特性,类似<a href="https://baike.baidu.com/item/UNIX/219943?fromModule=lemma_inlink">UNIX</a>下的automake。只是 CMake 的<a href="https://baike.baidu.com/item/%E7%BB%84%E6%80%81%E6%A1%A3/4812025?fromModule=lemma_inlink">组态档</a>取名为 CMakeLists.txt。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 <a href="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink">Windows</a> [Visual C++](<a href="https://baike.baidu.com/item/Visual">https://baike.baidu.com/item/Visual</a> C%2B%2B&#x2F;1811800?fromModule&#x3D;lemma_inlink) 的 projects&#x2F;workspaces），然后再依一般的建构方式使用。这使得熟悉某个<a href="https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/298524?fromModule=lemma_inlink">集成开发环境</a>（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。</p><p>linux 下系统直接安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><p>查看cmake版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br><span class="line">cmake version 3.16.3</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>我们一般都是通过cmake生成对应的makefile后来运行make。</p><h1 id="2-单个文件"><a href="#2-单个文件" class="headerlink" title="2 单个文件"></a>2 单个文件</h1><p>只有单个main.cpp的时候可以用如下CMakeLists.txt文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake最低版本需求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程名称</span></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C标准还是C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(demo</span><br><span class="line">        main.cpp)</span><br></pre></td></tr></table></figure><h1 id="3-多个文件夹"><a href="#3-多个文件夹" class="headerlink" title="3 多个文件夹"></a>3 多个文件夹</h1><p>但是实际开发中玩玩会更加复杂。</p><p>比如:下面每个模块都有自己的文件夹,并且每个文件夹下都有自己对应的头文件和源文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── abstract</span><br><span class="line">│   ├── inc</span><br><span class="line">│   │   └── abstractModel.h</span><br><span class="line">│   └── src</span><br><span class="line">│       └── abstractModel.cpp</span><br><span class="line">├── blueEar</span><br><span class="line">│   ├── inc</span><br><span class="line">│   │   └── blueEarModel.h</span><br><span class="line">│   └── src</span><br><span class="line">│       └── blueEarModel.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── CmakeOut</span><br><span class="line">├── main.cpp</span><br><span class="line">├── out</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>这个时候我们可以看如下的内容。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake最低版本需求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程名称</span></span><br><span class="line"><span class="keyword">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C标准还是C++标准</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set(CMAKE_C_STANDARD 11) #c标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)<span class="comment">#c++标准11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set (EXECUTABLE_OUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/out)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">include_directories</span> (   abstract/inc/</span><br><span class="line">                        blueEar/inc/</span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span> (abstract/src/ abstract_path)</span><br><span class="line"><span class="keyword">aux_source_directory</span> (blueEar/src/ blueEar_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(demo</span><br><span class="line">        main.cpp</span><br><span class="line">        <span class="variable">$&#123;abstract_path&#125;</span></span><br><span class="line">        <span class="variable">$&#123;blueEar_path&#125;</span>)</span><br></pre></td></tr></table></figure><p>可以看到如上的内容。</p><p>通过include_directories将相关的头文件包含进来</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span></span><br><span class="line">使用的格式如下:</span><br><span class="line"><span class="keyword">include_directories</span> (   abstract/inc/</span><br><span class="line">                        blueEar/inc/</span><br><span class="line">                        )</span><br></pre></td></tr></table></figure><p>另外通过aux_source_directory将相关的cpp文件都加载到对应的变量中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用的格式如下:</span></span><br><span class="line"><span class="keyword">aux_source_directory</span> (abstract/src/ abstract_path)</span><br><span class="line"><span class="keyword">aux_source_directory</span> (blueEar/src/ blueEar_path)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置可执行文件输出路径.会输出到项目文件下的out目录下</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/out)</span><br></pre></td></tr></table></figure><p>cmake过程中会生成大量的中间文件。</p><p>其中的一种做法可以跟我上面一样建立一个 CmakeOut文件夹.</p><p>然后进入到这个文件夹中,运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>这样就会把编译的中间文件生成到这个目录中,不至于破坏工程的目录。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andoird camera app从零养成计划【二】</title>
      <link href="/2024/11/10/Android/APP/APP-2/"/>
      <url>/2024/11/10/Android/APP/APP-2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-API1"><a href="#1-API1" class="headerlink" title="1 API1"></a>1 API1</h1><p>AndroidManifest.xmlAndroidManifest官方解释是应用清单（manifest意思是货单），每个应用的根目录中都必须包含一个，并且文件名必须一模一样。这个文件中包含了APP的配置信息，系统需要根据里面的内容运行APP的代码，显示界面。示例如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.newcamera&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span>/&gt;</span>   //使用camera的权限</span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span> //写文件的权限</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span>  //<span class="attr">apk图标</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.NewCamera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.PreviewActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>     //<span class="attr">告知打开apk的主Activity的入口</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于API 1 来说.打开camera 的对象已经封装好.在android&#x2F;hardware&#x2F;Camera.java中.</p><p>Camera API 中主要涉及以下几个关键类:</p><ul><li><p>Camera:操作和管理相机资源.支持相机资源切换.设置预览和拍摄尺寸.设置光圈,曝光等相关参数.</p></li><li><p>SurfaceView:用于绘制相机预览图像.提供实时预览的图像</p></li><li><p>SurfaceHolder:用于控制Surface的一个抽象接口.它可以控制Surface的尺寸,格式与像素等.并可以监视Surface的变化.</p></li><li><p>SurfaceHolder.Callback:用于监听Surface状态变化的接口</p></li></ul><p>SurfaceView和普通的View相比有什么区别呢？</p><p>普通View都是共享一个Surface的,所有的绘制也都在UI线程中进行.因为UI线程还要处理其他逻辑.因此对View的更新速度和绘制帧率无法保证.这显然不适合相机实时预览这种情况.因而SurfaceView持有一个单独Surface.它负责管理这个Surface的格式.尺寸以及显示位置,它的Surface绘制也在单独的线程中进行,因而拥有更高的绘制效率和帧率。</p><p>SurfaceHolder.Callback接口里定义了三个函数:</p><ul><li><strong>surfaceCreated(SufaceHolder holder)</strong>;当Surface第一次创建的时候调用.可以在这个方法里调用camera.open(),camera.setPreviewDisplay()来实现打开相机以及连接Camera与Surface等操作</li><li><strong>surfaceChanged(SurfaceHolder holder,int format,int width,int height)</strong>;当Surface的size,format等发生变化的时候调用,可以在这个方法里调用camera.startPreview()开启预览</li><li><strong>surfaceDestroyed(SurfaceHolder holder)</strong>;</li></ul><p>在打开相机前,我们需要获取到相机的一些基础信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getCameraInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//有多少个摄像头</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfCameras</span> <span class="operator">=</span> Camera.getNumberOfCameras();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfCameras; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> Camera.<span class="type">CameraInfo</span> <span class="variable">cameraInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>.CameraInfo();</span><br><span class="line"></span><br><span class="line">        Camera.getCameraInfo(i, cameraInfo);</span><br><span class="line">        <span class="comment">//后置摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            faceBackCameraId = i;</span><br><span class="line">            faceBackCameraOrientation = cameraInfo.orientation;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置摄像头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">            faceFrontCameraId = i;</span><br><span class="line">            faceFrontCameraOrientation = cameraInfo.orientation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.e(TAG,<span class="string">&quot;faceBackCameraId =&quot;</span>+faceBackCameraId+<span class="string">&quot;\tfaceBackCameraOrientation=&quot;</span>+faceBackCameraOrientation);</span><br><span class="line">    Log.e(TAG,<span class="string">&quot;faceFrontCameraId=&quot;</span>+faceFrontCameraId+<span class="string">&quot;\tfaceFrontCameraOrientation=&quot;</span>+faceFrontCameraOrientation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上打印出来的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">02-09 14:05:28.078  5280  5280 E CameraXTT: faceBackCameraId =0faceBackCameraOrientation=90</span><br><span class="line">02-09 14:05:28.078  5280  5280 E CameraXTT: faceFrontCameraId=1faceFrontCameraOrientation=270</span><br></pre></td></tr></table></figure><h2 id="1-1-打开相机"><a href="#1-1-打开相机" class="headerlink" title="1.1 打开相机"></a>1.1 打开相机</h2><p>知道了相机的相关信息,就可以通过对应的CameraID来打开对应的cameraDevices.注意 只针对单摄.双摄打开原理不一样.示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.hardware.Camera;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">camera = Camera.open(<span class="number">0</span>);   <span class="comment">//open(参数),参数对应的camera id//针对单摄的情况.可以通过这个方法直接打开对应的device设备.</span></span><br><span class="line"></span><br><span class="line">camera.setPreviewDisplay(sfv_preview.getHolder());<span class="comment">//sfv_preview是定义的SurfaceView,用来呈现相机的预览.</span></span><br><span class="line">camera.setDisplayOrientation(<span class="number">90</span>);   <span class="comment">//让相机旋转90度,相机方向不对会出现拉伸情况.</span></span><br><span class="line">camera.startPreview();</span><br></pre></td></tr></table></figure><p>打开相机后可以获取到一个camera的对象.从这个对象里可以获取和设置相机的各种参数信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">camera.getParameters();</span><br><span class="line">这个后面跟对应的参数：</span><br><span class="line">例如:</span><br><span class="line"> camera.getParameters().getAntibanding()</span><br><span class="line"> <span class="comment">//获取预览尺寸</span></span><br><span class="line"> Log.e(TAG,<span class="string">&quot;w&quot;</span>+camera.getParameters().getPreviewSize().width+<span class="string">&quot;h=&quot;</span>+camera.getParameters().getPreviewSize().height);</span><br></pre></td></tr></table></figure><h2 id="1-2-关闭相机"><a href="#1-2-关闭相机" class="headerlink" title="1.2 关闭相机"></a>1.2 关闭相机</h2><p>关闭相机要先停止预览再release()即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">camera.stopPreview();</span><br><span class="line">camera.release();</span><br></pre></td></tr></table></figure><h2 id="1-3-拍照"><a href="#1-3-拍照" class="headerlink" title="1.3 拍照"></a>1.3 拍照</h2><p>拍照通过调用Camera的takePicture()方法来完成的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback postview, PictureCallback jpeg)</span><br></pre></td></tr></table></figure><p>该方法有三个参数</p><ul><li><p>ShutterCallback shutter:在拍照的瞬间被回调.这里通常可以播放”咔擦”的音效</p></li><li><p>PictureCallback raw:返回未经压缩的图像数据</p></li><li><p>PictureCallback postview:返回postview的图像数据</p></li><li><p>PictureCallback jpeg:返回经过JPEG压缩的图像数据</p><p>我们一般用的是最后一个.实现最后一个PictureCallback即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">takePic</span><span class="params">()</span>&#123;</span><br><span class="line">        camera.takePicture(<span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Camera</span>.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line">                <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> BitmapFactory.decodeByteArray(data, <span class="number">0</span> ,data.length);</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> Environment.getExternalStorageDirectory().toString()</span><br><span class="line">                                +File.separator</span><br><span class="line">                                +<span class="string">&quot;DCIM/Camera&quot;</span></span><br><span class="line">                                +File.separator</span><br><span class="line">                                +<span class="string">&quot;PicTest_&quot;</span>+System.currentTimeMillis()+<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                Log.e(TAG,<span class="string">&quot;fileName=&quot;</span>+fileName);</span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">                <span class="keyword">if</span>(!file.getParentFile().exists())&#123;</span><br><span class="line">                    file.getParentFile().mkdir();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">                    bmp.compress(Bitmap.CompressFormat.JPEG, <span class="number">80</span>, bos);<span class="comment">//向缓冲区压缩图片</span></span><br><span class="line">                    bos.flush();</span><br><span class="line">                    bos.close();</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;拍照成功，照片保存在&quot;</span>+fileName+<span class="string">&quot;文件之中！&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                    Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;拍照失败！&quot;</span>+e.toString(), Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">                stopPreview();</span><br><span class="line">                startPreivew();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-API2"><a href="#2-API2" class="headerlink" title="2 API2"></a>2 API2</h1><p>叫出CameraManager ，打开 CameraDevice ，拿住CameraCaptureSession，发送CaptureRequest .</p><p>Camera API2中主要涉及的以下几个关键类:</p><ul><li>CameraManager:摄像头管理器.用于打开和关闭系统摄像头</li><li>CameraCharacteristics:描述摄像头的各种特性.我们可以通过CameraManager的getCameraCharacteristics(@NonNull String cameraId)方法来获取</li><li>CameraDevice:描述系统摄像头.类似早期的Camera</li><li>CameraCaptureSession:Session类.当需要拍照,预览等功能时,需要创建该类的实例.然后通过该实例里的方法进行控制(例如:拍照 capture())</li><li>CaptureRequest:描述了一个操作请求,拍照,预览等操作都需要先传入CaptureRequest参数，具体的参数控制也是通过CameraRequest的成员变量来设置</li><li>CaptureResult:描述拍照完成后的结果</li></ul><p>开发者通过创建CaptureRequest向摄像头发起Capture请求,这些请求会排成一个队列供摄像头处理,摄像头将结果包装在CaptureMetadata中返回给开发者.整个流程建立一个CameraCaptureSession的会话中.</p><h2 id="2-1-打开相机"><a href="#2-1-打开相机" class="headerlink" title="2.1 打开相机"></a>2.1 打开相机</h2><p>打开相机之前,要获取到CameraManger,然后获取相机列表,进而获取各个摄像头(主要是前摄和后摄)的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CameraManager</span> <span class="variable">manager</span> <span class="operator">=</span> (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android_S_ITS重构梳理</title>
      <link href="/2024/11/10/GMS/Andorid_S_ITS%E9%87%8D%E6%9E%84%E6%A2%B3%E7%90%86/"/>
      <url>/2024/11/10/GMS/Andorid_S_ITS%E9%87%8D%E6%9E%84%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>先看its环境搭建的文档.里面有基础操作说明.</p><p>然后为了更好理解梳理its的内容.我顺道整理出its 测试的脚本内容.</p><p>单刀直入.找到这个总的测试文件.我们所有的整跑命令都是从这个文件中调用起来的.</p><p>android-cts-verifier&#x2F;CameraITS&#x2F;tools&#x2F;run_all_tests.py<br>main函数的入口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br></pre></td></tr></table></figure><p>设置输出的tmp文件即测试生成的图片和log 保存的路径.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"><span class="comment"># Make output directories to hold the generated files.</span></span><br><span class="line">topdir = tempfile.mkdtemp(prefix=<span class="string">&#x27;CameraITS_&#x27;</span>)</span><br><span class="line">subprocess.call([<span class="string">&#x27;chmod&#x27;</span>, <span class="string">&#x27;g+rx&#x27;</span>, topdir])</span><br><span class="line">logging.info(<span class="string">&#x27;Saving output files to: %s&#x27;</span>, topdir)</span><br></pre></td></tr></table></figure><p>将输入的sys参数即场景拼接到scenes. 这个是针对直接输入测试cmd后面衔接场景和camera的.(exp:  python tools&#x2F;run_all_tests.py camera&#x3D;0 scenes&#x3D;0)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Override camera &amp; scenes with cmd line values if available</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">list</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">  <span class="keyword">if</span> <span class="string">&#x27;scenes=&#x27;</span> <span class="keyword">in</span> s:</span><br><span class="line">    scenes = s.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  <span class="keyword">elif</span> <span class="string">&#x27;camera=&#x27;</span> <span class="keyword">in</span> s:</span><br><span class="line">    camera_id_combos = s.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure><p>读取测试testBeds. 这边和config.yml对应起来.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read config file and extract relevant TestBed</span></span><br><span class="line">config_file_contents = get_config_file_contents()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> config_file_contents[<span class="string">&#x27;TestBeds&#x27;</span>]:</span><br><span class="line">  <span class="keyword">if</span> scenes == [<span class="string">&#x27;sensor_fusion&#x27;</span>]:</span><br><span class="line">    <span class="keyword">if</span> TEST_KEY_SENSOR_FUSION <span class="keyword">not</span> <span class="keyword">in</span> i[<span class="string">&#x27;Name&#x27;</span>].lower():</span><br><span class="line">      config_file_contents[<span class="string">&#x27;TestBeds&#x27;</span>].remove(i)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> TEST_KEY_SENSOR_FUSION <span class="keyword">in</span> i[<span class="string">&#x27;Name&#x27;</span>].lower():</span><br><span class="line">      config_file_contents[<span class="string">&#x27;TestBeds&#x27;</span>].remove(i)</span><br></pre></td></tr></table></figure><p>我们的config.yml 每一个TestBeds:下面会衔接<br>- Name: TEST_BED_TABLET_SCENES  # Need ‘tablet’ in name for tablet scenes</p><p>- Name: TEST_BED_SENSOR_FUSION  # Need ‘sensor_fusion’ in name for SF tests</p><p>分别对应标准灯箱和马达灯箱</p><p>继续往下看. 如果没有直接输入测试cmd后衔接参数. 而是直接python tools&#x2F;run_all_tests.py.</p><p>以下逻辑会走进去判断. 因为这几个值都没写.会直接读取config.yml的对应字符camera和scene后衔接的参数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get test parameters from config file</span></span><br><span class="line">test_params_content = get_test_params(config_file_contents)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> camera_id_combos:</span><br><span class="line">  camera_id_combos = <span class="built_in">str</span>(test_params_content[<span class="string">&#x27;camera&#x27;</span>]).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> scenes:</span><br><span class="line">  scenes = <span class="built_in">str</span>(test_params_content[<span class="string">&#x27;scene&#x27;</span>]).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  scenes = [_INT_STR_DICT.get(n, n) <span class="keyword">for</span> n <span class="keyword">in</span> scenes]  <span class="comment"># recover &#x27;1_1&#x27; &amp; &#x27;1_2&#x27;</span></span><br></pre></td></tr></table></figure><p>获取config.yml 中dut(测试机器的SN号),并且覆盖apk模式以允许写入外部存储.即让com.android.cts.verifier  拥有读写操作.  注意:我们一般把apk 下载到手机的时候 都是把相机以及其他所有权限都打开. 这两个是不一样的. 相机权限的打开是避免无法调用相机导致的fail. 而这边的读写操作主要是给apk 的各种服务开的.  使其能正常下发命令.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device_id = get_device_serial_number(<span class="string">&#x27;dut&#x27;</span>, config_file_contents)</span><br><span class="line"><span class="comment"># Enable external storage on DUT to send summary report to CtsVerifier.apk</span></span><br><span class="line">enable_external_storage(device_id)</span><br></pre></td></tr></table></figure><p>然后获取测试图表的sn号. 如果TEST_KEY_TABLET 存在在对应的TestBeds里,则获取到table_id,否则为None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST_KEY_TABLET = <span class="string">&#x27;tablet&#x27;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">config_file_test_key = config_file_contents[<span class="string">&#x27;TestBeds&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;Name&#x27;</span>].lower()</span><br><span class="line">  <span class="keyword">if</span> TEST_KEY_TABLET <span class="keyword">in</span> config_file_test_key:</span><br><span class="line">    tablet_id = get_device_serial_number(<span class="string">&#x27;tablet&#x27;</span>, config_file_contents)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    tablet_id = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>获取马达舵机的控制通道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testing_sensor_fusion_with_controller = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> TEST_KEY_SENSOR_FUSION <span class="keyword">in</span> config_file_test_key:</span><br><span class="line">  <span class="keyword">if</span> test_params_content[<span class="string">&#x27;rotator_cntl&#x27;</span>].lower() <span class="keyword">in</span> VALID_CONTROLLERS:</span><br><span class="line">    testing_sensor_fusion_with_controller = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>预加载场景，如果cmd line没有指出场景</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prepend &#x27;scene&#x27; if not specified at cmd line</span></span><br><span class="line"><span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(scenes):</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">not</span> s.startswith(<span class="string">&#x27;scene&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">      <span class="keyword">not</span> s.startswith((<span class="string">&#x27;sensor_fusion&#x27;</span>, <span class="string">&#x27;&lt;scene-name&gt;&#x27;</span>))):</span><br><span class="line">    scenes[i] = <span class="string">f&#x27;scene<span class="subst">&#123;s&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>如果用户没有制定特定的场景会跑测所有的场景.</p><p>创建子文件用于保存各个cameraID各个场景</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A subdir in topdir will be created for each camera_id. All scene test</span></span><br><span class="line"><span class="comment"># output logs for each camera id will be stored in this subdir.</span></span><br><span class="line"><span class="comment"># This output log path is a mobly param : LogPath</span></span><br><span class="line">cam_id_string = <span class="string">&#x27;cam_id_%s&#x27;</span> % (</span><br><span class="line">    camera_id.replace(its_session_utils.SUB_CAMERA_SEPARATOR, <span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">mobly_output_logs_path = os.path.join(topdir, cam_id_string)</span><br><span class="line">os.mkdir(mobly_output_logs_path)</span><br></pre></td></tr></table></figure><p>以上对config.yml的读取和检索后都重新创建一个yml文件,用于正式的跑测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_yml_file_name = get_updated_yml_file(config_file_contents)</span><br></pre></td></tr></table></figure><h1 id="2-跑测"><a href="#2-跑测" class="headerlink" title="2 跑测"></a>2 跑测</h1><p>上面是一些跑测的文件创建和准备</p><p>下面直面跑测的内容.</p><p>这个逻辑是用来确定单跑和整跑的逻辑.</p><p>如果输入的命令有包含tests&#x2F;  则是单跑调用. 否则都是整跑，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;tests/&#x27;</span> <span class="keyword">in</span> test:</span><br><span class="line">  cmd = [</span><br><span class="line">      <span class="string">&#x27;python3&#x27;</span>,</span><br><span class="line">      os.path.join(os.environ[<span class="string">&#x27;CAMERA_ITS_TOP&#x27;</span>], test), <span class="string">&#x27;-c&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;%s&#x27;</span> % new_yml_file_name</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  cmd = [</span><br><span class="line">      <span class="string">&#x27;python3&#x27;</span>,</span><br><span class="line">      os.path.join(os.environ[<span class="string">&#x27;CAMERA_ITS_TOP&#x27;</span>], <span class="string">&#x27;tests&#x27;</span>, s, test),</span><br><span class="line">      <span class="string">&#x27;-c&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;%s&#x27;</span> % new_yml_file_name</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>创建subprocess 用于正式跑测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num_try <span class="keyword">in</span> <span class="built_in">range</span>(NUM_TRIES):</span><br><span class="line">      <span class="comment"># pylint: disable=subprocess-run-check</span></span><br><span class="line">      <span class="keyword">with</span> <span class="built_in">open</span>(MOBLY_TEST_SUMMARY_TXT_FILE, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        output = subprocess.run(cmd, stdout=fp)</span><br><span class="line">      <span class="comment"># pylint: enable=subprocess-run-check</span></span><br></pre></td></tr></table></figure><p>解析mobly log 记录跑测返回的状态(skip&#x2F;pass&#x2F;fail),并且记录此结果</p><p>大致的跑测逻辑如上概诉，真实挂测的def run(cmd): 在这不累诉</p><h2 id="2-1-加载场景"><a href="#2-1-加载场景" class="headerlink" title="2.1 加载场景"></a>2.1 加载场景</h2><p>下面看这俩个内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def report_result(device_id, camera_id, results):</span><br><span class="line">def load_scenes_on_tablet(scene, tablet_id):</span><br></pre></td></tr></table></figure><p>加载对应场景的逻辑很简单.</p><p>就是将对应场景下的png全部push进table 图表设备中.</p><p>push路径为.该路径 必须要有push 的权限. 就算是市面上的机器，不然没法正确调用出对应场景的图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DST_SCENE_DIR = <span class="string">&#x27;/mnt/sdcard/Download/&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_scenes_on_tablet</span>(<span class="params">scene, tablet_id</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Copies scenes onto the tablet before running the tests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    scene: Name of the scene to copy image files.</span></span><br><span class="line"><span class="string">    tablet_id: adb id of tablet</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  logging.info(<span class="string">&#x27;Copying files to tablet: %s&#x27;</span>, tablet_id)</span><br><span class="line">  scene_dir = os.listdir(</span><br><span class="line">      os.path.join(os.environ[<span class="string">&#x27;CAMERA_ITS_TOP&#x27;</span>], <span class="string">&#x27;tests&#x27;</span>, scene))</span><br><span class="line">  <span class="keyword">for</span> file_name <span class="keyword">in</span> scene_dir:</span><br><span class="line">    <span class="keyword">if</span> file_name.endswith(<span class="string">&#x27;.png&#x27;</span>):</span><br><span class="line">      src_scene_file = os.path.join(os.environ[<span class="string">&#x27;CAMERA_ITS_TOP&#x27;</span>], <span class="string">&#x27;tests&#x27;</span>,</span><br><span class="line">                                    scene, file_name)</span><br><span class="line">      cmd = <span class="string">f&#x27;adb -s <span class="subst">&#123;tablet_id&#125;</span> push <span class="subst">&#123;src_scene_file&#125;</span> <span class="subst">&#123;_DST_SCENE_DIR&#125;</span>&#x27;</span></span><br><span class="line">      subprocess.Popen(cmd.split())</span><br><span class="line">  time.sleep(LOAD_SCENE_DELAY)</span><br><span class="line">  logging.info(<span class="string">&#x27;Finished copying files to tablet.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而对于这个函数用于改变场景和check</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def check_manual_scenes(device_id, camera_id, scene, out_path):</span><br></pre></td></tr></table></figure><h2 id="2-2-上报结果"><a href="#2-2-上报结果" class="headerlink" title="2.2 上报结果"></a>2.2 上报结果</h2><p>所有的结果都会记录到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTION_ITS_RESULT = <span class="string">&#x27;com.android.cts.verifier.camera.its.ACTION_ITS_RESULT&#x27;</span></span><br></pre></td></tr></table></figure><p>本质上是通过这个将结果上报给apk. 会在手机目录下看到类似its_camera1_scene0.txt的文件.本质上是把这个文件读写上报给测试apk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">report_result</span>(<span class="params">device_id, camera_id, results</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Sends a pass/fail result to the device, via an intent.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">   device_id: The ID string of the device to report the results to.</span></span><br><span class="line"><span class="string">   camera_id: The ID string of the camera for which to report pass/fail.</span></span><br><span class="line"><span class="string">   results: a dictionary contains all ITS scenes as key and result/summary of</span></span><br><span class="line"><span class="string">            current ITS run. See test_report_result unit test for an example.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  adb = <span class="string">f&#x27;adb -s <span class="subst">&#123;device_id&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Start ItsTestActivity to receive test results</span></span><br><span class="line">  cmd = <span class="string">f&#x27;<span class="subst">&#123;adb&#125;</span> shell am start <span class="subst">&#123;ITS_TEST_ACTIVITY&#125;</span> --activity-brought-to-front&#x27;</span></span><br><span class="line">  run(cmd)</span><br><span class="line">  time.sleep(ACTIVITY_START_WAIT)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Validate/process results argument</span></span><br><span class="line">  <span class="keyword">for</span> scene <span class="keyword">in</span> results:</span><br><span class="line">    <span class="keyword">if</span> RESULT_KEY <span class="keyword">not</span> <span class="keyword">in</span> results[scene]:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;ITS result not found for <span class="subst">&#123;scene&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> results[scene][RESULT_KEY] <span class="keyword">not</span> <span class="keyword">in</span> RESULT_VALUES:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Unknown ITS result for <span class="subst">&#123;scene&#125;</span>: <span class="subst">&#123;results[RESULT_KEY]&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> SUMMARY_KEY <span class="keyword">in</span> results[scene]:</span><br><span class="line">      device_summary_path = <span class="string">f&#x27;/sdcard/its_camera<span class="subst">&#123;camera_id&#125;</span>_<span class="subst">&#123;scene&#125;</span>.txt&#x27;</span></span><br><span class="line">      run(<span class="string">&#x27;%s push %s %s&#x27;</span> %</span><br><span class="line">          (adb, results[scene][SUMMARY_KEY], device_summary_path))</span><br><span class="line">      results[scene][SUMMARY_KEY] = device_summary_path</span><br><span class="line"></span><br><span class="line">  json_results = json.dumps(results)</span><br><span class="line">  cmd = (<span class="string">f&quot;<span class="subst">&#123;adb&#125;</span> shell am broadcast -a <span class="subst">&#123;ACTION_ITS_RESULT&#125;</span> --es <span class="subst">&#123;EXTRA_VERSION&#125;</span>&quot;</span></span><br><span class="line">         <span class="string">f&quot; <span class="subst">&#123;CURRENT_ITS_VERSION&#125;</span> --es <span class="subst">&#123;EXTRA_CAMERA_ID&#125;</span> <span class="subst">&#123;camera_id&#125;</span> --es &quot;</span></span><br><span class="line">         <span class="string">f&quot;<span class="subst">&#123;EXTRA_RESULTS&#125;</span> \&#x27;<span class="subst">&#123;json_results&#125;</span>\&#x27;&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(cmd) &gt; <span class="number">8000</span>:</span><br><span class="line">    logging.info(<span class="string">&#x27;ITS command string might be too long! len:%s&#x27;</span>, <span class="built_in">len</span>(cmd))</span><br><span class="line">  run(cmd)</span><br></pre></td></tr></table></figure><h1 id="3-测试场景"><a href="#3-测试场景" class="headerlink" title="3 测试场景"></a>3 测试场景</h1><p>注意SUB_CAMERA_TESTS 数组保存了 对应场景 对应的测试项目. 但是这个不是最后全部的测试项目。也有部分api 测试存在于android-cts-verifier&#x2F;CameraITS&#x2F;tests&#x2F;its_base_test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SUB_CAMERA_TESTS = &#123;</span><br><span class="line">    <span class="string">&#x27;scene0&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;test_burst_capture&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test_jitter&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test_metadata&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test_read_write&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test_sensor_events&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test_solid_color_test_pattern&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;test_unified_timestamps&#x27;</span>,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><p>另外对于以下这种场景有说明:比如场景1中的1_1,1_2 是分出来</p><p>场景2 中的不同人脸图都共有测试项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;scene2_a&#x27;</span>: [</span><br><span class="line">    <span class="string">&#x27;test_faces&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;test_num_faces&#x27;</span>,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>#   scene*_1&#x2F;2&#x2F;… are same scene split to load balance run times for scenes</p><p>#   scene*_a&#x2F;b&#x2F;… are similar scenes that share one or more tests</p><h1 id="4-ITS-apK-代码"><a href="#4-ITS-apK-代码" class="headerlink" title="4 ITS apK 代码"></a>4 ITS apK 代码</h1><p>apk代码路径如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cts/apps/CtsVerifier/src/com/android/cts/verifier/camera</span><br><span class="line">目录结构如下:和camera有关的有如下的测试.</span><br><span class="line">├── bokeh</span><br><span class="line">│   └── CameraBokehActivity.java</span><br><span class="line">├── flashlight</span><br><span class="line">│   └── CameraFlashlightActivity.java</span><br><span class="line">├── formats</span><br><span class="line">│   └── CameraFormatsActivity.java</span><br><span class="line">├── fov</span><br><span class="line">│   ├── CalibrationPreferenceActivity.java</span><br><span class="line">│   ├── CameraPreviewView.java</span><br><span class="line">│   ├── CtsTestHelper.java</span><br><span class="line">│   ├── DetermineFovActivity.java</span><br><span class="line">│   ├── PhotoCaptureActivity.java</span><br><span class="line">│   ├── SelectableResolution.java</span><br><span class="line">│   └── Size.java</span><br><span class="line">├── intents</span><br><span class="line">│   ├── CameraContentJobService.java</span><br><span class="line">│   └── CameraIntentsActivity.java</span><br><span class="line">├── its</span><br><span class="line">│   ├── ItsException.java</span><br><span class="line">│   ├── ItsSerializer.java</span><br><span class="line">│   ├── ItsService.java</span><br><span class="line">│   ├── ItsTestActivity.java</span><br><span class="line">│   ├── ItsUtils.java</span><br><span class="line">│   ├── Logt.java</span><br><span class="line">│   └── StatsImage.java</span><br><span class="line">├── orientation</span><br><span class="line">│   └── CameraOrientationActivity.java</span><br><span class="line">├── OWNERS</span><br><span class="line">├── performance</span><br><span class="line">│   ├── CameraPerformanceActivity.java</span><br><span class="line">│   └── CameraTestInstrumentation.java</span><br><span class="line">└── video</span><br><span class="line">    └── CameraVideoActivity.java</span><br></pre></td></tr></table></figure><p>我们重点看its 目录下的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── its</span><br><span class="line">│   ├── ItsException.java   #记录异常的接口</span><br><span class="line">│   ├── ItsSerializer.java  #serialize  序列化解析json 对象</span><br><span class="line">│   ├── ItsService.java  #its 围绕这个服务进行交互的</span><br><span class="line">│   ├── ItsTestActivity.java #主要测试main</span><br><span class="line">│   ├── ItsUtils.java #检索的文件 获取图片格式等操作都在此文件内完成</span><br><span class="line">│   ├── Logt.java #传递log msg</span><br><span class="line">│   └── StatsImage.java #load ctsverifier_jni </span><br></pre></td></tr></table></figure><p>ItsTestActivity.java # 下列代码是两年前谷歌加入的为了修复tests&#x2F;scene0&#x2F;test_metadata.py 脚本的问题而加入的默认语言检查.所以我们使用cts-verifier apk的时候 系统的默认要美国地区的英语.不然无法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default locale must be set to &quot;en-us&quot;</span></span><br><span class="line"><span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault();</span><br><span class="line"><span class="keyword">if</span> (!Locale.US.equals(locale)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">toastMessage</span> <span class="operator">=</span> <span class="string">&quot;Unsupported default language &quot;</span> + locale + <span class="string">&quot;! &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please switch the default language to English (United States) in &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Settings &gt; Language &amp; input &gt; Languages&quot;</span>;</span><br><span class="line">    Toast.makeText(ItsTestActivity.<span class="built_in">this</span>, toastMessage, Toast.LENGTH_LONG).show();</span><br><span class="line">    ItsTestActivity.<span class="built_in">this</span>.getReportLog().setSummary(</span><br><span class="line">            <span class="string">&quot;FAIL: Default language is not set to &quot;</span> + Locale.US,</span><br><span class="line">            <span class="number">1.0</span>, ResultType.NEUTRAL, ResultUnit.NONE);</span><br><span class="line">    setTestResultAndFinish(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是当时谷歌的commit.  感觉谷歌的操作真的是全是堆积这种bug. 以前就没有中文语言不支持一说.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CtsVerifier: Fail Camera ITS in case of unsupported locale</span><br><span class="line"></span><br><span class="line">Per CTS specification Camera ITS must only be run with default</span><br><span class="line">language set to English (United States). Check this and directly</span><br><span class="line">fail during ITS activity initialization and when processing ITS</span><br><span class="line">commands.</span><br><span class="line">The python script handling of socket errors must also be modified</span><br><span class="line">to appropriately notify users about this error condition.</span><br><span class="line"></span><br><span class="line">Bug: 149922652</span><br><span class="line">Test: Manual using CtsVerifier app,</span><br><span class="line">python tests/scene0/test_metadata.py</span><br><span class="line"></span><br><span class="line">Change-Id: I3a2833e2fbc8e8863f5dd13600d39e7d77cea438</span><br></pre></td></tr></table></figure><p>ITS apk部分的源码建议去谷歌官网看.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> GMS </category>
          
          <category> ITS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ITS </tag>
            
            <tag> GMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android编译概述</title>
      <link href="/2024/11/10/Android/Android%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/11/10/Android/Android%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>所有的编译都要先source build&#x2F;envsetup.sh</p><p>然后lunch 对应的产品。</p><p>整编就直接make</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li><p>在Andorid 7.0 之前都是使用GNU make,模块编译脚本使用Android.mk;</p></li><li><p>之后,编译使用ninja,由kati工具把Andorid&#x2F;mk转换为构建规范文件buildxxx.ninja;</p></li><li><p>Android 8.0 开始,引入编译脚本Android.bp,及工具blueprint和soong用于把Android.bp转换为buildxxx.ninja.</p><p>Android 编译脚本主要为Android.mk和Android.bp,在编译过程中都会转换为buildxxx.nija构建文件,加入到ninja构建系统中参与编译.</p><p>buildxxxx.ninja文件生成在out目录中,文件大小比较大,包含了编译中的所有配置信息.</p></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>m</td><td>编译整个源码,可以不用切换根目录</td></tr><tr><td>mm</td><td>编译当前目录下的源码.不包含他们的依赖模块</td></tr><tr><td>mmm</td><td>编译指定目录下的所有模块,不包含他们的依赖模块</td></tr><tr><td>mma</td><td>编译当前目录的下的源码,包含他们的依赖模块</td></tr><tr><td>mmma</td><td>编译指定目录下的所有模块.包含他们的依赖项目</td></tr></tbody></table><p>编译环境初始化.</p><p>由命令source build&#x2F;envsetup.sh完成</p><p>其中envsetup.sh主要做了下面几个事情.</p><ul><li><p>定义一些lunch &#x2F;m &#x2F;mm &#x2F;mmm &#x2F;provision等函数.</p></li><li><p>确定当前的shell 环境.建立shell命令</p></li><li><p>从device&#x2F;vendor&#x2F;product等目录遍历搜索vendorsetup.sh, 并source 进来</p></li><li><p>将下面的bash文件导入到当前环境中</p><p>system&#x2F;core&#x2F;adb&#x2F;adb.bash,</p><p>system&#x2F;core&#x2F;fastboot&#x2F;fastboot.bash,</p><p>tools&#x2F;asuite&#x2F;asuite.sh</p></li></ul><h1 id="1-image"><a href="#1-image" class="headerlink" title="1 image"></a>1 image</h1><p>像system&#x2F;vendor&#x2F;dtbo&#x2F;boot 这些</p><p>可以直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make systemimage</span><br><span class="line">make bootimage</span><br><span class="line">make dtboimage</span><br><span class="line">make vendorimage</span><br><span class="line">make cts</span><br></pre></td></tr></table></figure><h1 id="2-framework"><a href="#2-framework" class="headerlink" title="2 framework"></a>2 framework</h1><p>framework部分内容是很复杂的一块的内容.</p><p>关于cameraservice的部分可以用ninja编译 ,jni的部分也可以直接mma或者找到对应的so去编译</p><p>下列命令是单编译对应的so.对于所有模块都是可以的.需要注意的是这种编译是不加依赖项的.所以会出现修改的Android.mk不生效. 对应的ninja工具需要在对应的项目内寻找.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-vnd_xxxx.ninja libcameraservice</span><br></pre></td></tr></table></figure><p>这个路径下是apk层直接调用的硬件接口.可以用如下的命令直接编译生成framework.jar包.</p><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make framework-minus-apex</span><br></pre></td></tr></table></figure><p>adb push framework.jar system&#x2F;framework&#x2F;</p><p>同时删除设备中system&#x2F;framework目录下</p><p>oat,arm,arm64的三个文件夹.</p><p>然后adb reboot. 不删除以上的三个文件，系统会一直处在开机动画中无法打开.</p><p>frameworks&#x2F;base&#x2F;Android.bp的相关编译规则如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java_library &#123;</span><br><span class="line">    name: &quot;framework-minus-apex&quot;,</span><br><span class="line">    defaults: [&quot;framework-minus-apex-defaults&quot;],</span><br><span class="line">    installable: true,</span><br><span class="line">    // For backwards compatibility.</span><br><span class="line">    stem: &quot;framework&quot;,</span><br><span class="line">    apex_available: [&quot;//apex_available:platform&quot;],</span><br><span class="line">    visibility: [</span><br><span class="line">        &quot;//frameworks/base&quot;,</span><br><span class="line">        // TODO(b/147128803) remove the below lines</span><br><span class="line">        &quot;//frameworks/base/apex/appsearch/framework&quot;,</span><br><span class="line">        &quot;//frameworks/base/apex/blobstore/framework&quot;,</span><br><span class="line">        &quot;//frameworks/base/apex/jobscheduler/framework&quot;,</span><br><span class="line">        &quot;//frameworks/base/packages/Tethering/tests/unit&quot;,</span><br><span class="line">        &quot;//packages/modules/Connectivity/Tethering/tests/unit&quot;,</span><br><span class="line">    ],</span><br><span class="line">    errorprone: &#123;</span><br><span class="line">        javacflags: [</span><br><span class="line">            &quot;-Xep:AndroidFrameworkBinderIdentity:ERROR&quot;,</span><br><span class="line">            &quot;-Xep:AndroidFrameworkCompatChange:ERROR&quot;,</span><br><span class="line">            &quot;-Xep:AndroidFrameworkUid:ERROR&quot;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-selinux"><a href="#3-selinux" class="headerlink" title="3 selinux"></a>3 selinux</h1><p>adb shell setenforce 0会解放selinux权限<br>Android 的selinux权限路径,但是这个是总的. 不同平台的编译本质上是编译这个路径.</p><p>system&#x2F;sepolicy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make selinux_policy</span><br><span class="line">将编译生成的.cil相关文件push到设备中重启.</span><br><span class="line">adb push vendor/etc/selinux/* vendor/etc/selinux</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGrok搭建笔记</title>
      <link href="/2024/11/10/%E6%90%AD%E5%BB%BA/OpenGrok%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/10/%E6%90%AD%E5%BB%BA/OpenGrok%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGrok"><a href="#OpenGrok" class="headerlink" title="OpenGrok"></a>OpenGrok</h1><p>克隆仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/JoeNero/OpenGrok.git</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#tomcat </span><br><span class="line">export CATALINA_HOME=&quot;/home/xtt/OpenGrok/apache-tomcat-8.5.55&quot;</span><br><span class="line"></span><br><span class="line">#opengrok</span><br><span class="line">export OPENGROK_TOMCAT_BASE=$CATALINA_HOME</span><br></pre></td></tr></table></figure><p>保存后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>打开本地端口8080测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure><p>部署opengrok<br>进入opengrok bin目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./OpenGrok deploy</span><br></pre></td></tr></table></figure><p>测试部署是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/source</span><br></pre></td></tr></table></figure><p>建立索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./OpenGrok index /root/chrome  #代码存放的位置</span><br></pre></td></tr></table></figure><p>最终生成的索引默认会存放在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/opengrok</span><br></pre></td></tr></table></figure><h1 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">ctags --version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> openGrok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 【vector】</title>
      <link href="/2024/11/10/CPP/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vector/"/>
      <url>/2024/11/10/CPP/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-vector/</url>
      
        <content type="html"><![CDATA[<h1 id="1-STL-简介"><a href="#1-STL-简介" class="headerlink" title="1 STL 简介"></a>1 STL 简介</h1><blockquote><p>STL是Standard Template Library的简称，中文名标准模板库<br>STL可分为<br>容器(containers)、<br>迭代器(iterators)、<br>空间配置器(allocator)、<br>配接器(adapters)、<br>算法(algorithms)、<br>仿函数(functors)六个部分。</p></blockquote><p>选自百度词条<a href="https://baike.baidu.com/item/STL/70103?fr=aladdin">STL百度词条</a><br>C++标准中，STL组件被组织命名为以下13个头文件</p><blockquote><p>&lt; algorithm&gt;<br>&lt; deque&gt;<br>&lt; functional&gt;<br>&lt; iterator&gt;<br>&lt; vector&gt;<br>&lt; list&gt;<br>&lt; map&gt;<br>&lt; memory.h&gt;<br>&lt; numeric&gt;<br>&lt; queue&gt;<br>&lt; set&gt;<br>&lt; stack&gt;<br>&lt; utility&gt;</p></blockquote><h1 id="2-容器-vector"><a href="#2-容器-vector" class="headerlink" title="2 容器 vector"></a>2 容器 vector</h1><p>向量(vector) 连续存储的元素&lt; vector&gt;;<br>vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。<br>为了更好理解，不用基础类型，自行定义一个MyInt结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line">string name;<span class="comment">//用作标识符</span></span><br><span class="line"><span class="type">int</span> Int;        <span class="comment">//实际存储类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写一个打印函数如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能: - vector类打印</span></span><br><span class="line"><span class="comment">@param</span></span><br><span class="line"><span class="comment">@param</span></span><br><span class="line"><span class="comment">@param</span></span><br><span class="line"><span class="comment">描述:</span></span><br><span class="line"><span class="comment">示例:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;MyInt&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;MyInt&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;标识符为:&quot;</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数据为:&quot;</span>&lt;&lt; it-&gt;Int &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-构造"><a href="#2-1-构造" class="headerlink" title="2.1 构造"></a>2.1 构造</h2><p>vector类构造demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;MyInt&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">MyInt* myInt = <span class="keyword">new</span> MyInt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">myInt[i].name = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">myInt[i].Int = i;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(myInt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="function">vector&lt;MyInt&gt; <span class="title">v2</span><span class="params">(v<span class="number">1.</span>begin(), v<span class="number">1.</span>end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">vector&lt;MyInt&gt;::iterator it = v<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line"><span class="function">vector&lt;MyInt&gt; <span class="title">v3</span><span class="params">(it<span class="number">+1</span>, v<span class="number">1.</span>end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="keyword">delete</span>[] myInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，因为用了迭代器来访问v1.begin() + 1的位置 ，(非基础类型不能用v1[1]访问),所以打印v3容器输出的结果是1到9<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cd43e6bd2b8d53298c83d9d6dc3ff2b2.jpeg" alt="在这里插入图片描述"></p><h2 id="2-2-成员函数"><a href="#2-2-成员函数" class="headerlink" title="2.2 成员函数"></a>2.2 成员函数</h2><p>基础访问操作:（注意v3.at[int index]适合访问基础类型,int,char等，自定义的类型还是用迭代器访问）<br>vector不支持头插(push_front)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">3.</span><span class="built_in">push_back</span>(elem)  <span class="comment">//在尾部插入一个elem数据。</span></span><br><span class="line">v<span class="number">3.</span><span class="built_in">pop_back</span>()       <span class="comment">//删除末尾的数据。</span></span><br><span class="line">v<span class="number">3.</span><span class="built_in">at</span>(<span class="type">int</span> index)<span class="comment">//传回索引为index的数据,如果index越界</span></span><br><span class="line"><span class="comment">//抛出out_of_range异常。</span></span><br><span class="line"><span class="comment">//非基础类型需要通过迭代器访问</span></span><br></pre></td></tr></table></figure><h3 id="2-2-1-assgin"><a href="#2-2-1-assgin" class="headerlink" title="2.2.1 assgin"></a>2.2.1 assgin</h3><p>v3.assign(beg,end)将[beg,end)一个左闭右开区间的数据赋值给v3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">3.</span><span class="built_in">assign</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br></pre></td></tr></table></figure><p>v3.assign (n,elem)将n个elem的拷贝赋值给v3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">3.</span><span class="built_in">assign</span>(<span class="number">2</span>, myInt[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f4409bb6edf35adcb6ebecb83746ac9.jpeg" alt="在这里插入图片描述"></p><h3 id="2-2-2-数据大小操作"><a href="#2-2-2-数据大小操作" class="headerlink" title="2.2.2 数据大小操作"></a>2.2.2 数据大小操作</h3><h4 id="2-2-1-empty"><a href="#2-2-1-empty" class="headerlink" title="2.2.1.empty"></a>2.2.1.empty</h4><p>v1.empty() &#x2F;&#x2F;  判空操作<br>先看empty()定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_NODISCARD <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; _My_data = _Mypair._Myval2;</span><br><span class="line">    <span class="keyword">return</span> _My_data._Myfirst == _My_data._Mylast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试容器空的状况:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;MyInt&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">cout &lt;&lt; v<span class="number">1.</span><span class="built_in">empty</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>空返回1<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d1d724b0d342e5c785976127f9cb4a2f.jpeg" alt="在这里插入图片描述"><br>非空返回 0<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f681f1fda108aa3696c04aa80a2a0b76.jpeg" alt="在这里插入图片描述"><br>了解empty后修改打印函数(暂时不抛出异常)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;MyInt&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打印Vector为空&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;MyInt&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;标识符为:&quot;</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数据为:&quot;</span> &lt;&lt; it-&gt;Int &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-容量"><a href="#2-2-2-容量" class="headerlink" title="2.2.2  容量"></a>2.2.2  容量</h4><p>参考链接<a href="https://blog.csdn.net/JIEJINQUANIL/article/details/51166154">capacity用法</a></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>capacity()</td><td>容器能存储 数据的个数(真实大小)</td></tr><tr><td>size()</td><td>目前存在的元素个数</td></tr><tr><td>max_size</td><td>最大容量</td></tr><tr><td>resize()</td><td>重新指定大小 ，若指定的更小，超出部分元素被删除</td></tr><tr><td>reserve</td><td>预留空间</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;v1真实的大小 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">capacity</span>() &lt;&lt; endl;<span class="comment">//真实的大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1最大容量 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">max_size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/67b826a0fe159edebbc23f08616daa89.jpeg" alt="在这里插入图片描述"><br>resize()使用，<br>重新指定大小10的v1容器为12，多指定的空间重新插入内容myInt[2]；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">12</span>, myInt[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br></pre></td></tr></table></figure><p>打印输出结果:<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5fa6feb23652dc4f316bd766deac09f6.jpeg" alt="在这里插入图片描述"><br>重新指定v1打下，删除超过索引的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br></pre></td></tr></table></figure><p>输出结果<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8b63a542688e35cfd61689810353b8e5.jpeg" alt="在这里插入图片描述"></p><h3 id="2-2-3-删除与插入操作"><a href="#2-2-3-删除与插入操作" class="headerlink" title="2.2.3 删除与插入操作"></a>2.2.3 删除与插入操作</h3><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>pop_back()</td><td>尾删</td></tr><tr><td>insert（）</td><td>插入操作</td></tr><tr><td>erase()</td><td>擦除</td></tr><tr><td></td><td></td></tr><tr><td>测试代码如下:</td><td></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;MyInt&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">MyInt* myInt = <span class="keyword">new</span> MyInt[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">myInt[i].name = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">myInt[i].Int = i;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(myInt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">vector&lt;MyInt&gt;::iterator it = v<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">v<span class="number">1.</span><span class="built_in">insert</span>(it<span class="number">+1</span>, myInt[<span class="number">1</span>]);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">2</span>, myInt[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">////删除</span></span><br><span class="line">v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;擦除头:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">////清空</span></span><br><span class="line"><span class="comment">//v1.erase(v1.begin(), v1.end());</span></span><br><span class="line"><span class="comment">//printVector(v1);</span></span><br><span class="line">v<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="keyword">delete</span>[] myInt;</span><br></pre></td></tr></table></figure><p>打印输出结果</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/70b367434aee7da1b47c36dced4fab0f.jpeg" alt="在这里插入图片描述"></p><h3 id="2-2-4-swap"><a href="#2-2-4-swap" class="headerlink" title="2.2.4 swap"></a>2.2.4 swap</h3><p>速览其定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp; _Right)</span> <span class="keyword">noexcept</span> <span class="comment">/* strengthened */</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != _STD <span class="built_in">addressof</span>(_Right)) &#123;</span><br><span class="line">        _Pocs(_Getal(), _Right._Getal());</span><br><span class="line">        _Mypair._Myval<span class="number">2.</span>_Swap_val(_Right._Mypair._Myval2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>swap交换，直接看代码吧:两容器大小需要一致，否在会进入异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;MyInt&gt; v1; </span><br><span class="line">vector&lt;MyInt&gt; v2;</span><br><span class="line">MyInt* myInt = <span class="keyword">new</span> MyInt[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">myInt[i].name = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">myInt[i].Int = i;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(myInt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">myInt[i].name = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">myInt[i].Int = <span class="number">3</span> - i;</span><br><span class="line">v<span class="number">2.</span><span class="built_in">push_back</span>(myInt[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; v1 =&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; v2 =&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">swap</span>(v2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; v1 =&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; v2 =&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br></pre></td></tr></table></figure><p>输出打印结果如下:<br><img src="https://i-blog.csdnimg.cn/blog_migrate/76d01921df3a4cba71f040a84ae42ae5.jpeg" alt="在这里插入图片描述"><br>在实际应用中swap常常用于与自身交换来达到收缩内存的效果，这里不加累述<br><a href="https://blog.csdn.net/liyazhen2011/article/details/103179974">swap收缩内存参考链接</a></p><h1 id="3-vector总结"><a href="#3-vector总结" class="headerlink" title="3 vector总结"></a>3 vector总结</h1><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td>push_back</td><td>尾插</td></tr><tr><td>assign</td><td><a href="https://blog.csdn.net/qq844352155/article/details/38583529">assgin用法</a></td></tr><tr><td>resize</td><td>重构大小</td></tr><tr><td>capacity</td><td>容量(真实大小)</td></tr><tr><td>size</td><td>当前大小</td></tr><tr><td>max_size</td><td>最大容量</td></tr><tr><td>pop_back</td><td>尾删</td></tr><tr><td>insert</td><td>插入</td></tr><tr><td>erase</td><td>删除</td></tr><tr><td>clear</td><td>清空</td></tr><tr><td>swap</td><td>交换</td></tr><tr><td>reserve</td><td>预留空间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬取天气</title>
      <link href="/2024/11/10/Python/python%E7%88%AC%E5%8F%96%E5%A4%A9%E6%B0%94/"/>
      <url>/2024/11/10/Python/python%E7%88%AC%E5%8F%96%E5%A4%A9%E6%B0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装使用"><a href="#1-安装使用" class="headerlink" title="1 安装使用"></a>1 安装使用</h1><p>VSCode中安装相关的插件就可以配合chatgpt来实现一些简单的爬虫操作，只能应对比较简单的场景.<br>安装插件<br>chatGPT-ChatMoss</p><h1 id="2-实例"><a href="#2-实例" class="headerlink" title="2 实例"></a>2 实例</h1><p>给AI发送<br>python 爬取无锡七日天气<br>回复如下:<br>要爬取无锡七日天气，可以使用Python中的第三方库 requests 和 Beautiful Soup。以下是详细步骤：</p><ol><li>导入必要的库</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><ol start="2"><li>发送GET请求获取网页内容</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://www.weather.com.cn/weather/101190201.shtml&quot;</span></span><br><span class="line">response = requests.get(url)</span><br></pre></td></tr></table></figure><ol start="3"><li>解析网页内容</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(response.content, <span class="string">&quot;html.parser&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>找到需要的天气信息所在的标签</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weather_data = soup.select(<span class="string">&quot;.t&gt;li&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>提取天气信息并输出</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> weather <span class="keyword">in</span> weather_data:</span><br><span class="line">    <span class="comment"># 获取日期、天气状况、最高温度和最低温度</span></span><br><span class="line">    date = weather.select_one(<span class="string">&quot;.date&quot;</span>).get_text()</span><br><span class="line">    condition = weather.select_one(<span class="string">&quot;.wea&quot;</span>).get_text()</span><br><span class="line">    high_temperature = weather.select_one(<span class="string">&quot;.tem span&quot;</span>).get_text()</span><br><span class="line">    low_temperature = weather.select_one(<span class="string">&quot;.tem i&quot;</span>).get_text()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印天气信息</span></span><br><span class="line">    <span class="built_in">print</span>(date, condition, high_temperature, low_temperature)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.weather.com.cn/weather/101190201.shtml&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.content, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line">weather_data = soup.select(<span class="string">&quot;.t&gt;li&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> weather <span class="keyword">in</span> weather_data:</span><br><span class="line">    date = weather.select_one(<span class="string">&quot;.date&quot;</span>).get_text()</span><br><span class="line">    condition = weather.select_one(<span class="string">&quot;.wea&quot;</span>).get_text()</span><br><span class="line">    high_temperature = weather.select_one(<span class="string">&quot;.tem span&quot;</span>).get_text()</span><br><span class="line">    low_temperature = weather.select_one(<span class="string">&quot;.tem i&quot;</span>).get_text()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(date, condition, high_temperature, low_temperature)</span><br></pre></td></tr></table></figure><p>但是上述实际运行是存在一些小问题的。</p><p>打印结果如下: 这个很明显就是date这个数据为None</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">None &lt;p <span class="class"><span class="keyword">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;多云&quot;&gt;多云&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;28&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;17℃&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;多云&quot;&gt;多云&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;27&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;15℃&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;多云&quot;&gt;多云&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;24&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;12℃&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;阴转小雨&quot;&gt;阴转小雨&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;20&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;15℃&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;阴&quot;&gt;阴&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;15&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;13℃&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;小雨&quot;&gt;小雨&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;19&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;14℃&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">wea</span>&quot; <span class="title">title</span>=&quot;小雨转晴&quot;&gt;小雨转晴&lt;/<span class="title">p</span>&gt; &lt;<span class="title">span</span>&gt;16&lt;/<span class="title">span</span>&gt; &lt;<span class="title">i</span>&gt;8℃&lt;/<span class="title">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续追问机器人:</p><p>优化下代码，没有获取到天数，并且这个get_text有报错.</p><p>机器人直接回复:</p><p>以下是优化后的代码，已解决上述问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.weather.com.cn/weather/101190201.shtml&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.content, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line">weather_data = soup.select(<span class="string">&quot;.t li&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> weather <span class="keyword">in</span> weather_data:</span><br><span class="line">    <span class="comment"># 获取日期、天气状况、最高温度和最低温度</span></span><br><span class="line">    date = weather.select_one(<span class="string">&quot;h1&quot;</span>).get_text()</span><br><span class="line">    condition = weather.select_one(<span class="string">&quot;.wea&quot;</span>).get_text()</span><br><span class="line">    high_temperature = weather.select(<span class="string">&quot;.tem span&quot;</span>)[<span class="number">0</span>].get_text()</span><br><span class="line">    low_temperature = weather.select(<span class="string">&quot;.tem i&quot;</span>)[<span class="number">0</span>].get_text()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印天气信息</span></span><br><span class="line">    <span class="built_in">print</span>(date, condition, high_temperature, low_temperature)</span><br></pre></td></tr></table></figure><p>在优化代码时，我们对原有代码进行了以下改进：</p><ul><li>将CSS选择器中的“&gt;”删除，因为它只会选择直接子元素，导致无法获取到所有的天气信息。</li><li>由于天数信息并不在 “.date” 标签内，所以将日期信息从该标签中提取出来。在这里，我们使用了 h1 标签来获取日期信息。</li><li>使用 select() 方法来选取多个元素，并且使用索引 [0] 来定位到需要的元素，因为 .select_one() 方法只能返回单个元素，如果要选取多个元素，需要使用 select() 方法。同时，我们还修改了 “.tem span” 和 “.tem i” 的类选择器，以便正确获取最高温度和最低温度。</li><li>在使用 get_text() 方法时，需要确保该元素存在并且不为空。如果该元素不存在或为空，会导致 AttributeError 异常。</li></ul><p>这一次就非常好用了.</p><p>打印出的结果如下:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>日（今天） 多云 <span class="number">28</span> <span class="number">17</span>℃</span><br><span class="line"><span class="number">20</span>日（明天） 多云 <span class="number">27</span> <span class="number">15</span>℃</span><br><span class="line"><span class="number">21</span>日（后天） 多云 <span class="number">24</span> <span class="number">12</span>℃</span><br><span class="line"><span class="number">22</span>日（周六） 阴转小雨 <span class="number">20</span> <span class="number">15</span>℃</span><br><span class="line"><span class="number">23</span>日（周日） 阴 <span class="number">15</span> <span class="number">13</span>℃</span><br><span class="line"><span class="number">24</span>日（周一） 小雨 <span class="number">19</span> <span class="number">14</span>℃</span><br><span class="line"><span class="number">25</span>日（周二） 小雨转晴 <span class="number">16</span> <span class="number">8</span>℃</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTS基础操作</title>
      <link href="/2024/11/10/GMS/cts%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/11/10/GMS/cts%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h1><p>设置永久不锁屏</p><h1 id="1-CTS"><a href="#1-CTS" class="headerlink" title="1 CTS"></a>1 CTS</h1><p>进入cts目录tools<br>运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./cts-tradefed</span><br><span class="line">adb devices找设备数串</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整跑</span><br><span class="line">run cts -m CtsCameraTestCases --skip-preconditions</span><br><span class="line">run cts -m CtsMediaTestCases</span><br><span class="line">单测格式如下 -t 后面是单跑的内容</span><br><span class="line">run cts -m CtsCameraTestCases -t android.hardware.camera2.cts.StillCaptureTest#testAeCompensation --skip-preconditions</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看设备状态</span><br><span class="line">l d</span><br><span class="line">查看报告状态</span><br><span class="line">l r</span><br><span class="line">查看当前命令</span><br><span class="line">l c</span><br><span class="line">打开报告</span><br><span class="line">nautilus ./</span><br><span class="line">run retry --retry &lt;session-number&gt;</span><br><span class="line">重跑(注意:重跑需要同一个机子同一个版本)</span><br><span class="line">run retry --retry session</span><br><span class="line">run retry --retry 0</span><br></pre></td></tr></table></figure><p>以上的是在环境中跑cts.<br>cts 的本质是下载测试的apk到手机中（在谷歌释放包中CtsCameraTest.apk），这个apk集成了测试相关的内容来调用手机的一些功能完成测试项目<br>以下命令在终端运行即可，替换成你需要跑的单项和abi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am instrument -e android.hardware.camera2.cts.CameraDeviceTest#testSessionParametersStateLeak --abi arm64-v8a  -w android.camera.cts/androidx.</span><br></pre></td></tr></table></figure><h1 id="2-VTS-需要镜像"><a href="#2-VTS-需要镜像" class="headerlink" title="2 VTS(需要镜像)"></a>2 VTS(需要镜像)</h1><p>vts 需要python 相关的环境包配置,相关命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install python-protobuf</span><br><span class="line">sudo apt-get install protobuf-compiler</span><br><span class="line">sudo apt-get install python-virtualenv</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo apt-get install python-numpy</span><br><span class="line">sudo apt-get install python-scipy</span><br><span class="line">sudo apt-get install python-matplotlib</span><br><span class="line">sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure><h2 id="2-1进入fastbootd模式"><a href="#2-1进入fastbootd模式" class="headerlink" title="2.1进入fastbootd模式"></a>2.1进入fastbootd模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb unroot</span><br><span class="line">adb reboot fastboot #进入这个模式刷system.img,bootloader模式没有这个分区</span><br></pre></td></tr></table></figure><h2 id="2-2-system-img"><a href="#2-2-system-img" class="headerlink" title="2.2 system.img"></a>2.2 system.img</h2><p>刷入谷歌 system.img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash system system.img</span><br></pre></td></tr></table></figure><p>查看gsi版本日期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings system.img | grep ro.build.version.security_patch</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.build.version.security_patch</span><br></pre></td></tr></table></figure><p>重新进入fastboot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot bootloader</span><br><span class="line">fastboot -w</span><br></pre></td></tr></table></figure><h2 id="2-3-boot-debug-img"><a href="#2-3-boot-debug-img" class="headerlink" title="2.3 boot-debug.img"></a>2.3 boot-debug.img</h2><p>vts需要debug的权限，所以需要刷debug的镜像,另外fastboot 的版本不能太旧,太久分区不对，刷system.img会破坏分区，导致无限重启无法进去到系统里面进去.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash boot boot-debug.img</span><br><span class="line">fastboot -w</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><h2 id="2-4-手机配置"><a href="#2-4-手机配置" class="headerlink" title="2.4 手机配置"></a>2.4 手机配置</h2><p>进入设置打开开发者模式,usb调试模式,不锁定屏幕,语言设置成英语(这个语言无所谓)</p><h2 id="2-5-命令"><a href="#2-5-命令" class="headerlink" title="2.5 命令"></a>2.5 命令</h2><p>需要连接外网(电脑)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ./vts-tradefed</span><br><span class="line">VTS camera 相关的三个模块</span><br><span class="line">run vts -m VtsHalCameraProviderV2_4Target --skip-preconditions</span><br><span class="line">run vts -m VtsHalCameraProviderV2_5Target --skip-preconditions</span><br><span class="line">run vts -m VtsHalCameraServiceV2_0Target --skip-preconditions</span><br><span class="line">单跑</span><br><span class="line">run vts --include-filter VtsHalCameraProviderV2_4Target --include-filter VtsHalCameraProviderV2_5Target --include-filter VtsHalCameraServiceV2_0Target --include-filter VtsVndkDependency -s xxx；</span><br><span class="line">单跑命令</span><br><span class="line">run vts -m xxx -t xxx -s xxx</span><br><span class="line">run vts -s</span><br></pre></td></tr></table></figure><p>vts常用命令<br>列出所有的跑测结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l  r</span><br></pre></td></tr></table></figure><p>列出所有渐层到或已知的设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l d</span><br><span class="line">列出当前运行的模块内容</span><br><span class="line">l i</span><br></pre></td></tr></table></figure><p>单跑某个模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vts -m &lt;模块&gt;</span><br></pre></td></tr></table></figure><p>可用选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vts -s &lt;device_id&gt; --logcat-on-failure --screenshot-on-failure --shard-count &lt;shards&gt;</span><br></pre></td></tr></table></figure><h1 id="3-ITS"><a href="#3-ITS" class="headerlink" title="3 ITS"></a>3 ITS</h1><p>its以来python环境(不建议使用ubuntu20测试,默认python包可能太新，跑不起来)</p><h2 id="3-1-环境包"><a href="#3-1-环境包" class="headerlink" title="3.1 环境包"></a>3.1 环境包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-numpy</span><br><span class="line">sudo apt install python-scipy</span><br><span class="line">sudo apt install python-matplotlib</span><br><span class="line">sudo apt install python-opencv</span><br></pre></td></tr></table></figure><h2 id="3-2-手机端"><a href="#3-2-手机端" class="headerlink" title="3.2 手机端"></a>3.2 手机端</h2><p>手机需要安装CtsVerifier.apk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install CtsVerifier.apk</span><br></pre></td></tr></table></figure><p>进入到手机apk，所有的权限都打开，选择its测试项目<br><img src="https://i-blog.csdnimg.cn/blog_migrate/98bd0b0e3985e78f88f07014ebaf5ade.png#pic_center" alt="在这里插入图片描述"></p><p>然后选择测试的场景和摄像头<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5b08b61f99d217a0609f2e75a70e1800.jpeg#pic_center" alt="在这里插入图片描述"></p><h2 id="3-3-电脑端"><a href="#3-3-电脑端" class="headerlink" title="3.3 电脑端"></a>3.3 电脑端</h2><p>进入到对应的tools目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android-cts-verifier/CameraITS</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./build/envsetup.sh</span><br></pre></td></tr></table></figure><p>整跑命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/run_all_tests.py device=017650f70401   camera=0 scenes=1</span><br></pre></td></tr></table></figure><p>单跑命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python ./tests/xxx/xxx.py camera=x（执行tests目录下的对应scenes的报错项）。</span><br><span class="line">python tools/run_all_tests.py camera=0 scenes=1</span><br></pre></td></tr></table></figure><h2 id="3-4-场景说明"><a href="#3-4-场景说明" class="headerlink" title="3.4 场景说明"></a>3.4 场景说明</h2><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>场景0</td><td>无任何要求</td></tr><tr><td>场景1</td><td>相机位于三脚架上, 指向一个静态场景, 其中包含灰色卡和白色背景, 在恒定 (稳定) 相对明亮的光照源下。这是 CTS 验证程序物理设置上面描述的场景。镜头视野中，灰卡大致放在中间，周围为白色背景</td></tr><tr><td>场景 2</td><td>这是测试人脸检测的场景。相机位于三脚架上, 指向一张包含3人脸的静态图片, 在恒定 (稳定) 相对明亮的照明光源下。</td></tr><tr><td>场景3</td><td>这是测试图像清晰度的场景。相机位于三脚架上, 指向包含某些边缘的静态图片, 如打印的 ISO 12233 图表。现场应在一个恒定 (稳定) 相对明亮的照明源。</td></tr><tr><td>场景4</td><td>这是测试纵横比的场景。相机位于三脚架上, 指向一个静态测试页, 其中包含一个黑色圆圈和一个方块。现场应在一个恒定 (稳定) 相对明亮的照明源</td></tr><tr><td>场景5</td><td>这是测试镜头着色和颜色均匀性的场景。在摄像机前放置一个扩散器。相机位于三脚架上，指向恒定的 (稳定) 相对地明亮的照明源。</td></tr><tr><td>我们这边就用的一张白色餐巾纸代替了扩散器，将镜头对着光源，用餐巾纸挡住镜头即可。（很好使，反正不用钱）场景的具体说明看its的官方文档</td><td></td></tr></tbody></table><h2 id="3-5-创建报告"><a href="#3-5-创建报告" class="headerlink" title="3.5 创建报告"></a>3.5 创建报告</h2><p>单跑是空的，显示在终端上。暂不创建报告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">appops set com.android.cts.verifier android:read_device_identifiers allow</span><br><span class="line">exit</span><br><span class="line">adb pull /storage/emulated/0/verifierReports ~/桌面/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-GTS"><a href="#4-GTS" class="headerlink" title="4 GTS"></a>4 GTS</h1><p>进入到tool目录下,手机电脑需要挂VPN 连接外网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run gts -m GtsCameraTestCases -s xxx</span><br><span class="line">run gts -m GtsCameraTestCases -s 008bcdcf0405</span><br></pre></td></tr></table></figure><h1 id="5-STS"><a href="#5-STS" class="headerlink" title="5 STS"></a>5 STS</h1><p>安全补丁包测试以后再说</p><h1 id="6-GSI"><a href="#6-GSI" class="headerlink" title="6 GSI"></a>6 GSI</h1><p>需要烧录谷歌镜像<br>进入fastboot模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot fastboot</span><br></pre></td></tr></table></figure><p>刷入对应的谷歌镜像system.img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash system system.img</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot bootloader</span><br><span class="line">fastboot -w</span><br><span class="line">fastboot oem unlock</span><br><span class="line">adb reboot bootloader</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p>打开开发者选项,打开stay awake和USB debugging<br>进入vts目录，运行     .&#x2F;vts-tradefed</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全跑      </span><br><span class="line">run cts-on-gsi -m CtsCameraTestCases</span><br><span class="line">单跑</span><br><span class="line">run cts-on-gsi --include-filter CtsCameraApi25TestCases --include-filter CtsCameraTestCases -s xxx</span><br><span class="line">run cts-on-gsi -m CtsCameraTestCases -t xxx</span><br><span class="line">run cts-on-gsi -o</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> GMS </category>
          
          <category> cts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> GMS </tag>
            
            <tag> cts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 【链表】</title>
      <link href="/2024/11/10/CPP/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/11/10/CPP/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-链表的创建"><a href="#1-链表的创建" class="headerlink" title="1 链表的创建"></a>1 链表的创建</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构。<a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fr=aladdin">摘自百度百科</a><br>如下存储:<br><img src="https://s2.loli.net/2024/11/10/RyU92tuGW31qNbP.png" alt="链表.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;  <span class="comment">//数据域</span></span><br><span class="line">Node* next;<span class="comment">//指针域</span></span><br><span class="line"><span class="built_in">Node</span>():<span class="built_in">data</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> _data,Node* _next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = _data;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = _next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-1-头插"><a href="#1-1-头插" class="headerlink" title="1.1 头插"></a>1.1 头插</h2><p><img src="https://s2.loli.net/2024/11/10/JCxgW6TPU9prDdY.png" alt="链表2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushFront</span><span class="params">(Node* head, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* pNew= <span class="keyword">new</span> <span class="built_in">Node</span>();           <span class="comment">//定义新节点头</span></span><br><span class="line">pNew-&gt;data = data;                <span class="comment">//存储数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span>== head-&gt;next)<span class="comment">//判断是不是只有头结点</span></span><br><span class="line">&#123;</span><br><span class="line">head-&gt;next = pNew;                 </span><br><span class="line">&#125;</span><br><span class="line">pNew-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = pNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-尾插"><a href="#1-2-尾插" class="headerlink" title="1.2 尾插"></a>1.2 尾插</h2><p>尾插:<br>申请一个新的节点pNew.将要插入的数据赋值给pNew节点的数据域.并且将pNew的指针域指向空.<br>定义一个节点p指向head(实际操作时一般定义一个新的节点来操作,以便返回头结点)</p><p><img src="https://s2.loli.net/2024/11/10/cvAkowQN6xO75Ui.png" alt="链表3.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushBack</span><span class="params">(Node* head, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* pNew = <span class="keyword">new</span> Node;          <span class="comment">//定义一个Node结点指针newNode</span></span><br><span class="line">pNew-&gt;next = <span class="literal">NULL</span>;              <span class="comment">//定义newNode的数据域和指针域</span></span><br><span class="line">pNew-&gt;data = data;</span><br><span class="line">Node* p = head;                 <span class="comment">//定义指针p指向头结点</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;                               <span class="comment">//当头结点为空时，设置newNode为头结点</span></span><br><span class="line">head = pNew;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                            <span class="comment">//循环直到最后一个节点，将newNode放置在最后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = pNew;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-获取链表长度"><a href="#1-3-获取链表长度" class="headerlink" title="1.3 获取链表长度"></a>1.3 获取链表长度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLens</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lens = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">lens++;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-翻转链表"><a href="#2-翻转链表" class="headerlink" title="2 翻转链表"></a>2 翻转链表</h1><p><img src="https://s2.loli.net/2024/11/10/ATsyCik163ZvPbJ.png" alt="链表4.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((head-&gt;next == <span class="literal">nullptr</span> )||(head-&gt;next-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* pCur = head-&gt;next;</span><br><span class="line">Node* pNext = pCur-&gt;next;</span><br><span class="line">Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (pNext)</span><br><span class="line">&#123;</span><br><span class="line">pCur-&gt;next = pre;</span><br><span class="line">pre = pCur;</span><br><span class="line">pCur = pNext;</span><br><span class="line">pNext = pCur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pCur-&gt;next = pre;</span><br><span class="line">head-&gt;next = pCur;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的使用</title>
      <link href="/2024/11/10/Linux/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/10/Linux/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-git-下载"><a href="#1-git-下载" class="headerlink" title="1.git 下载"></a>1.git 下载</h1><p>最好是更新下镜像源</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> update</span><br></pre></td></tr></table></figure><p>下载git</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install git</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/57610ea2389eed7f411f029a43c3c8b5.png"><br>检测git下载成功的版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><p>版本显示正确后执行再执行下一步<br><img src="https://i-blog.csdnimg.cn/blog_migrate/804594cf93c6f0f70dbe0f7e487fed39.png"></p><h1 id="2-ssh"><a href="#2-ssh" class="headerlink" title="2 ssh"></a>2 ssh</h1><p>ssh具体内容参考百度词条<a href="https://baike.baidu.com/item/SSH/10407">ssh</a><br>执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install ssh </span><br></pre></td></tr></table></figure><p>显示如下<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2d7bb5fce1275523d01140a2a1c01424.png"><br>查看ssh服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ps</span> <span class="literal">-e</span> | grep sshd</span><br></pre></td></tr></table></figure><p>显示sshd的话表示ssh-server已经启动<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ccac9456c7008cd8439c45c645c8c26e.png"><br>生成ssh-key</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;你的邮箱@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>生成后默认就行，直接回车生成文件隐藏<br>用下面命令检测是否在根目录下生存(上面建议默认，是直接在根目录下生成的)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> <span class="literal">-al</span> ~/.ssh</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/de0994ad8d808f189ed4ec9030615e3b.png"><br>然后打开显示隐藏文件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/eb47eba16f9a712bd8047524f5f5eb84.png">找到<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bcc065d14a29d13598f4d56647b41ed2.png"><br>再进入到文件夹下找到以下文件，这个是公钥。<br>打开这个文件将其内容复制(用记事本或者vim打开都行)<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7c0c0e8b5c356f45ba34f74f38fd475a.png"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/c787fd589d622eef983fe42f02857eff.png">打开你的github帐号，进入你的settings<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c948ad84b69384cd61385fe7347ad056.png">找到ssh<br><img src="https://i-blog.csdnimg.cn/blog_migrate/978cb04f1e14a96e65df43568252c90d.png"><br>新建一个ssh<br><img src="https://i-blog.csdnimg.cn/blog_migrate/df880886f641c1af1f64f360b189b121.png">将复制的内容粘贴进去后便是如上显示</p><h1 id="3-git-使用"><a href="#3-git-使用" class="headerlink" title="3 git 使用"></a>3 git 使用</h1><h2 id="3-1-新建仓库"><a href="#3-1-新建仓库" class="headerlink" title="3.1 新建仓库"></a>3.1 新建仓库</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d9eb93e958f4078d7cbca14191487f6d.png"><br>这部分比较简单(其实都不难)，直接看图说话吧。名字和描诉整干净后直接创建仓库</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4eb16a6a5731d31d61aea7dca0a0c4eb.png">然后把地址复制下来<br><img src="https://i-blog.csdnimg.cn/blog_migrate/460b2d3f06233ee1b0a8aaade07a981e.png"></p><h2 id="3-2-git它！！！git就万事了"><a href="#3-2-git它！！！git就万事了" class="headerlink" title="3.2 git它！！！git就万事了"></a>3.2 git它！！！git就万事了</h2><p>在你自己的文件夹下git clone远程仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 网址</span><br></pre></td></tr></table></figure><p>然后进入到目录里初始化他<br><img src="https://i-blog.csdnimg.cn/blog_migrate/36735234074ff0312a22d082cb636779.png"><br>在该目录下创建你自己的文件,这个随便你怎么建立，touch 是创建命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch README.md</span><br></pre></td></tr></table></figure><p>git add .  是有个空格后再家一个点。直接该该目录下的文件添加到暂存区域<br>git add 文件名  是直接将相应的文件添加到暂存区域</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"><span class="comment">#git add README.md</span></span><br></pre></td></tr></table></figure><p>提交本次修改<br>git commit</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit <span class="literal">-m</span> <span class="string">&quot;add readme file&quot;</span> <span class="comment">#提交本次修改</span></span><br></pre></td></tr></table></figure><p>推送到远程仓库<br>格式为 git push (brash) 我这里是直接推送到origin master</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master<span class="comment">#推送到远程仓库</span></span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1c8ad0468251a3f08b6c1b1de785d3e.png"><br>输入你名字和密码<br><img src="https://i-blog.csdnimg.cn/blog_migrate/524377bf2fdf3cca28cc2a639e873c5a.png"><br>刷新你的仓库，内容就提交上去了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d4fb82ae9b4940d3130cff0c98c91b05.png"></p><p>更多笔记请访问<br><a href="https://joenero.github.io/">JoeNero私人博客</a><br>参考链接<br><a href="https://blog.csdn.net/wxy540843763/article/details/80197301">参考链接1</a><br><a href="https://blog.csdn.net/qicheng777/article/details/74724015">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andoird camera app从零养成计划【一】</title>
      <link href="/2024/11/10/Android/APP/APP_1/"/>
      <url>/2024/11/10/Android/APP/APP_1/</url>
      
        <content type="html"><![CDATA[<p>要创建一个基本的Camera App demo，我们将使用Android Studio和Java来编写一个应用，该应用能够打开相机预览，拍照，并保存照片到设备的存储中。这里将使用Android的Camera2 API，因为它提供了更丰富的功能和更好的性能，尽管它比Camera API（已弃用）更复杂一些。</p><h3 id="步骤-1-创建一个新的Android项目"><a href="#步骤-1-创建一个新的Android项目" class="headerlink" title="步骤 1: 创建一个新的Android项目"></a>步骤 1: 创建一个新的Android项目</h3><ol><li>打开Android Studio，选择“Start a new Android Studio project”。</li><li>选择“Empty Activity”，然后点击“Next”。</li><li>填写你的应用名称（如 <code>CameraDemo</code>），选择你的保存位置，语言选择Java，最小API级别设置为21（因为Camera2 API在API 21（Android 5.0）上引入）。</li><li>点击“Finish”创建项目。</li></ol><h3 id="步骤-2-添加权限"><a href="#步骤-2-添加权限" class="headerlink" title="步骤 2: 添加权限"></a>步骤 2: 添加权限</h3><p>在你的 <code>AndroidManifest.xml</code> 文件中添加必要的权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;你的包名&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span> <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera.autofocus&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="步骤-3-布局文件"><a href="#步骤-3-布局文件" class="headerlink" title="步骤 3: 布局文件"></a>步骤 3: 布局文件</h3><p>修改 <code>res/layout/activity_main.xml</code> 文件来添加必要的视图控件（如TextureView用于显示相机预览，Button用于拍照）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextureView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textureView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@+id/button_capture&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_capture&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;拍照&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="步骤-4-编写MainActivity"><a href="#步骤-4-编写MainActivity" class="headerlink" title="步骤 4: 编写MainActivity"></a>步骤 4: 编写MainActivity</h3><p>由于Camera2 API较为复杂，这里不会详细展开全部代码，但会概述主要步骤和关键代码片段。</p><ol><li><strong>初始化Camera2 API</strong>：打开相机，设置预览大小，创建CaptureSession等。</li><li><strong>设置TextureView显示预览</strong>。</li><li><strong>处理拍照和保存</strong>：在点击按钮时，捕获图像并保存到存储。</li></ol><p>你需要创建多个类来处理Camera2的不同部分，如CameraStateCallback、CaptureRequest等。</p><h3 id="示例代码片段（MainActivity部分）"><a href="#示例代码片段（MainActivity部分）" class="headerlink" title="示例代码片段（MainActivity部分）"></a>示例代码片段（MainActivity部分）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextureView textureView;</span><br><span class="line">    <span class="keyword">private</span> CameraDevice cameraDevice;</span><br><span class="line">    <span class="keyword">private</span> CaptureRequest.Builder previewRequestBuilder;</span><br><span class="line">    <span class="comment">// 其他变量...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        textureView = findViewById(R.id.textureView);</span><br><span class="line">        <span class="comment">// 初始化相机，设置TextureView显示预览等...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拍照按钮点击事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureButtonClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 拍照逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相机打开，关闭等状态的回调</span></span><br><span class="line">    <span class="keyword">private</span> CameraDevice.<span class="type">StateCallback</span> <span class="variable">stateCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraDevice</span>.StateCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">            <span class="comment">// 相机成功打开</span></span><br><span class="line">            cameraDevice = camera;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">            <span class="comment">// 相机被断开</span></span><br><span class="line">            cameraDevice.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera, <span class="type">int</span> error)</span> &#123;</span><br><span class="line">            <span class="comment">// 相机发生错误</span></span><br><span class="line">            cameraDevice.close();</span><br><span class="line">            cameraDevice = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5-运行时权限请求"><a href="#步骤-5-运行时权限请求" class="headerlink" title="步骤 5: 运行时权限请求"></a>步骤 5: 运行时权限请求</h3><p>由于Android 6.0（API 级别 23）及以上版本需要在运行时请求权限，你需要检查并在必要时请求权限。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里只提供了一个基本的框架和思路。Camera2 API 涉及很多复杂的步骤和概念，如处理相机状态、创建和管理CaptureRequests、SurfaceTexture等。为了完整实现功能，你需要深入研究Camera2 API的文档和示例代码。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL速学</title>
      <link href="/2024/11/10/CPP/STL/"/>
      <url>/2024/11/10/CPP/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h1><h2 id="1-1-array"><a href="#1-1-array" class="headerlink" title="1.1 array"></a>1.1 array</h2><p><strong>array保存在栈中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// 非法, 数组大小参数必须是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// 正确写法</span></span><br></pre></td></tr></table></figure><h2 id="1-2-vector"><a href="#1-2-vector" class="headerlink" title="1.2 vector"></a>1.2 vector</h2><p>不同的编译器实现的扩容方式不一样，vector 在VS2015中以1.5倍扩容，GCC以2倍扩容。</p><p><strong>vector保存在堆中</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">size</span>();<span class="comment">//返回行数</span></span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//返回列数</span></span><br></pre></td></tr></table></figure><h2 id="1-3-list"><a href="#1-3-list" class="headerlink" title="1.3 list"></a>1.3 list</h2><p>list 是双向循环链表 记住！！！</p><p>List的插入、删除或者拼合操作不会造成原有迭代器的失效。</p><p>List不能用STL 中的sort函数进行排序，而是要用自身的sort函数。List仅支持随机访问迭代器，而List是双向迭代器。</p><h2 id="1-4-forward-list"><a href="#1-4-forward-list" class="headerlink" title="1.4 forward_list"></a>1.4 forward_list</h2><p>单向链表，标准库容器中唯一不提供size()方法的容器，当不需要双向迭代时，具备比list更高的空间利用率。</p><h2 id="1-5-stack"><a href="#1-5-stack" class="headerlink" title="1.5 stack"></a>1.5 stack</h2><p>基础示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素&quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小为:&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>emplace :&#x2F;&#x2F;emplace函数可以将一个元素加入栈中，与push的区别在于：emplace可以直接传入Node的构造函数的参数，并将构造的元素加入栈中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        a = x; b = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;Node&gt; mystack;</span><br><span class="line">    mystack.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">2</span>);        </span><br><span class="line">    <span class="comment">//mystack.push(1,2);        //编译不通过，要达到上面的效果需要手动构造，例如mystack.push(Node(1,2));</span></span><br><span class="line">    Node p = mystack.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    stack&lt;Node&gt; my2;</span><br><span class="line">    my<span class="number">2.</span><span class="built_in">swap</span>(mystack);            <span class="comment">//swap函数可以交换两个栈的元素</span></span><br><span class="line">    cout &lt;&lt; mystack.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; my<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h1><p>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。</p><p>访问智能指针包含的裸指针则可以用 get() 函数。由于智能指针是一个对象，所以if (my_smart_object)永远为真，要判断智能指针的裸指针是否为空，需要这样判断：if (my_smart_object.get())。</p><h2 id="2-1auto-ptr"><a href="#2-1auto-ptr" class="headerlink" title="2.1auto_ptr"></a>2.1auto_ptr</h2><p><strong>采用管理权转移，拷贝时会导致对象悬空，设计有缺陷，不建议使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//auto_ptr&lt;int&gt; p;//初始化为NULL</span></span><br><span class="line"><span class="comment">//  错误写法  auto_ptr&lt;int&gt; p = new int(123);</span></span><br><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; *p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;<span class="comment">//将p的使用权转给p1,p1已经指向nullptr无法正常访问</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; *p &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-2unique-ptr"><a href="#2-2unique-ptr" class="headerlink" title="2.2unique_ptr"></a>2.2unique_ptr</h2><p><strong>特点：防拷贝，简单粗暴，建议使用</strong></p><p><strong>缺点：不能拷贝，可以转让</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">*p = <span class="number">7</span>;</span><br><span class="line">cout &lt;&lt; *p&lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; upt1=std::<span class="built_in">move</span>(upt);  <span class="comment">//控制权限转移</span></span><br><span class="line"><span class="keyword">if</span>(upt.<span class="built_in">get</span>()!=<span class="literal">nullptr</span>)<span class="comment">//判空操作更安全</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p1;          <span class="comment">//创建空的智能指针</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>));    <span class="comment">//绑定动态对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">4</span>))</span> </span>;        <span class="comment">//创建时绑定动态对象</span></span><br><span class="line">cout &lt;&lt; *p1 &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; *p2 &lt;&lt;endl;</span><br><span class="line"><span class="comment">//所有权发生变化</span></span><br><span class="line"><span class="type">int</span> *p = p<span class="number">1.</span><span class="built_in">release</span>();      <span class="comment">//释放所有权</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p_s1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;abc&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;string&gt; p_s2 = std::move(p_s1);</span></span><br><span class="line">    cout &lt;&lt; *p_s1 &lt;&lt;endl;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p_s2 &lt;&lt;endl;</span></span><br></pre></td></tr></table></figure><h2 id="2-3shared-ptr"><a href="#2-3shared-ptr" class="headerlink" title="2.3shared_ptr"></a>2.3shared_ptr</h2><p> shared_ptr的原理：通过引用计数的方式来实现多个shared_ptr对象之间共享资源。</p><ol><li>shared_ptr在其内部，给每个资源都维护了一份计数，用来记录该份资源被几个对象共享。</li><li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。</li><li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源。</li><li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">cout &lt;&lt; *p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>循环引用</p><p>循坏引用分析：</p><ol><li>node1和node2两个智能指针对象指向两个结点，引用计数变成1，我们不需要手动delete。</li><li>node1和_next指向node2，node2的_prev还指向下一个结点。但是_prev还指向上一个节点。</li><li>node1和node2析构，引用计数减一，但是_next还指向下一个节点。但是_prev还指向上一个节点。</li><li>也就是说_next析构了，node2就释放了。</li><li>也就是说_prev析构了，node1就释放了。</li><li>但是_next属于node成员，node1释放了，_next才会析构，而node1由_prev管理，_prev属于node2成员，所以这就叫循环引用，谁也不会释放。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ListNode</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ListNode()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">node1</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">node2</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    cout &lt;&lt; node<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; node<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    node1-&gt;_next = node2;</span><br><span class="line">    node2-&gt;_prev = node1;</span><br><span class="line">    cout &lt;&lt; node<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; node<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：在引用计数的场景下，把节点中的_prev和_next改成weak_ptr就可以了</strong></p><p><strong>原理：node1-&gt;_next &#x3D; node2;和node2-&gt;_prev &#x3D; node1;时weak_ptr的_next和_prev不会增加 node1和node2的引用计数。</strong> </p><h2 id="2-4weak-ptr"><a href="#2-4weak-ptr" class="headerlink" title="2.4weak_ptr"></a>2.4weak_ptr</h2><p>weak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造而来。weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-&gt; ，因此取名为 weak，表明其是功能较弱的智能指针。它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _next;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ListNode</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~ListNode()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">node1</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">node2</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    cout &lt;&lt; node<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; node<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    node1-&gt;_next = node2;</span><br><span class="line">    node2-&gt;_prev = node1;</span><br><span class="line">    cout &lt;&lt; node<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; node<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出几个使用指南。<br>（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：<br>（a）的元素和最小的元素；<br>（b）两个对象都包含指向第三个对象的指针；<br>（c）STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr</p><h1 id="3-类型推导"><a href="#3-类型推导" class="headerlink" title="3.类型推导"></a>3.类型推导</h1><h2 id="3-1-auto"><a href="#3-1-auto" class="headerlink" title="3.1 auto"></a>3.1 auto</h2><p>编程时候常常需要把表达式的值付给变量,需要在声明变量的时候清楚的知道变量是什么类型。然而做到这一点并非那么容易(特别是模板中)，有时候根本做不到。为了解决这个问题，C++11新标准就引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同。auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i,&amp;b = i,*c = &amp;i;<span class="comment">//正确: a初始化为i的副本,b初始化为i的引用,c为i的指针.</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//错误,两个变量的类型不一样。</span></span><br></pre></td></tr></table></figure><h2 id="3-2-decltype"><a href="#3-2-decltype" class="headerlink" title="3.2 decltype"></a>3.2 decltype</h2><p><code>decltype</code> 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) i2 = i;</span><br><span class="line">cout  &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">cout &lt;&lt; i2;</span><br></pre></td></tr></table></figure><h1 id="4-强制类型转换"><a href="#4-强制类型转换" class="headerlink" title="4.强制类型转换"></a>4.强制类型转换</h1><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p><h2 id="4-1-const-cast"><a href="#4-1-const-cast" class="headerlink" title="4.1 const_cast"></a>4.1 const_cast</h2><p><strong>const_cast&lt;类型说明符&gt; (变量或表达式)</strong></p><p> 用于将const变量转换为非const类型</p><p>const_cast用于强制去掉const这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</p><h2 id="4-2-static-cast"><a href="#4-2-static-cast" class="headerlink" title="4.2  static_cast"></a>4.2  static_cast</h2><p>static_cast&lt;类型说明符&gt; (变量或表达式)</p><p>用于各种隐私转换，比如非const转const， void*转指针等， static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知。</p><h2 id="4-3-dynamic-cast"><a href="#4-3-dynamic-cast" class="headerlink" title="4.3 dynamic_cast"></a>4.3 dynamic_cast</h2><p>dynamic_cast&lt;类型说明符&gt; (变量或表达式)</p><p>用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向上转换：指的是子类向基类转换。 向下转换：指的是基类向子类转换。  他通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。    </p><h2 id="4-4-reinterpret-cast"><a href="#4-4-reinterpret-cast" class="headerlink" title="4.4 reinterpret_cast"></a>4.4 reinterpret_cast</h2><p>reinterpret_cast&lt;类型说明符&gt; (变量或表达式)</p><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用。</p><p>改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。</p><h2 id="4-5-为什么不用C的强制转换？"><a href="#4-5-为什么不用C的强制转换？" class="headerlink" title="4.5 为什么不用C的强制转换？"></a>4.5 为什么不用C的强制转换？</h2><p>C的强制转换表面上看起来功能强大什么都能转换，但转化不够明确，不能进行错误检查，容易出错。</p><h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h1><p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。<br> 假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">double</span> d,<span class="type">int</span> i)&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">float</span> f,<span class="type">int</span> i,<span class="type">const</span> <span class="type">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> i):<span class="built_in">A</span>(i)&#123;&#125;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">double</span> d,<span class="type">int</span> i):<span class="built_in">A</span>(d,i)&#123;&#125;</span><br><span class="line">  <span class="built_in">B</span>(folat f,<span class="type">int</span> i,<span class="type">const</span> <span class="type">char</span>* c):<span class="built_in">A</span>(f,i,e)&#123;&#125;</span><br><span class="line">  <span class="comment">//......等等好多个和基类构造函数对应的构造函数</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>C++11的继承构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">double</span> d,<span class="type">int</span> i)&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">float</span> f,<span class="type">int</span> i,<span class="type">const</span> <span class="type">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> A::A;</span><br><span class="line">  <span class="comment">//关于基类各构造函数的继承一句话搞定</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">auto f = [=] &#123; return a; &#125;;</span><br><span class="line"></span><br><span class="line">a+=1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f() &lt;&lt; endl;       //输出0</span><br><span class="line"></span><br><span class="line">int a = 0;</span><br><span class="line">auto f = [&amp;a] &#123; return a; &#125;;</span><br><span class="line"></span><br><span class="line">a+=1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f() &lt;&lt;endl;       //输出1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">        temp ^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
