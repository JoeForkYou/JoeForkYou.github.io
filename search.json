[{"title":"lightroomv","url":"/2024/11/10/Android/3rd/lightroomv/","content":"[toc]\n\n# 1 lightroomv\n\n三方apk lightroomv 拍照. 一次性只能拍照4张，无法生成第5张图片.\n\n很明显能看到异常的时候会有如下的报错log,到这里hal就没有收到任何拍照请求.\n\n```shell\n#上一张拍照请求到hal,下述log. pic_req =1 ，拍照请求到hal 查收了\n05-13 17:32:18.966   560 12747 D Cam3HWI : 2317, processCaptureRequest: camId=0, bufs_num=2, frame_num=49, cap_intent=2, pic_req=1, first_regular_req=0\n#已经报错\n05-13 16:53:39.869  8798 12489 W ImageReader_JNI: Unable to acquire a buffer item, very likely client tried to acquire more than maxImages buffers\n#下面就无法打印出对应的拍照请求.\n```\n\n\n\n# 2 JNI\n我们camera相关的会涉及如下路径的JNI\nframeworks/base/media/jni      (这个是多媒体相关的，主要涉及到拍照的image相关的内容)\n\n编译的so 为libmedia_jni.so\n\nframeworks/base/core/jni\n\n编译的so为libandroid_runtime.so\n\n具体查看编译什么可以去看对应目录文件下Android.bp文件\n\n```makefile\ncc_library_shared {\n    name: \"libandroid_runtime\",\n    host_supported: true,\n    cflags: [\n```\n\n```makefile\ncc_library_shared {\n    name: \"libmedia_jni\",\n\n```\n\n举个例子\n1.android_hardware_Camera.cpp 这个文件中如下的内容:\n\n```cpp\nstatic const JNINativeMethod camMethods[] = {\n  { \"getNumberOfCameras\",\n    \"()I\",\n    (void *)android_hardware_Camera_getNumberOfCameras },\n```\n对于java hardware 中的虚函数  getNumberOfCameras使用的实际方法是通过这个JNI的方法映射过来. 实际使用函数是这个文件中的android_hardware_Camera_getNumberOfCameras\n\n2.\n\n`ImageReader`允许应用程序直接获取渲染到`surface`的图形数据，并转换为图片\n\n更为详细的内容可以查阅https://developer.android.google.cn/reference/android/media/ImageReader.html\n\nframeworks/base/media/java/android/media/ImageReader.java中\n\n```java\nprivate synchronized native int nativeImageSetup(Image i);\n```\n\n实际上调用的是如下位置的内容.下述是其映射关系.\n\nframeworks/base/media/jni/android_media_ImageReader.cpp\n\n```c++\nstatic const JNINativeMethod gImageReaderMethods[] = {\n    {\"nativeClassInit\",        \"()V\",                        (void*)ImageReader_classInit },\n    {\"nativeInit\",             \"(Ljava/lang/Object;IIIIJ)V\",  (void*)ImageReader_init },\n    {\"nativeClose\",            \"()V\",                        (void*)ImageReader_close },\n    {\"nativeReleaseImage\",     \"(Landroid/media/Image;)V\",   (void*)ImageReader_imageRelease },\n    {\"nativeImageSetup\",       \"(Landroid/media/Image;)I\",   (void*)ImageReader_imageSetup }, \n    {\"nativeGetSurface\",       \"()Landroid/view/Surface;\",   (void*)ImageReader_getSurface },\n    {\"nativeDetachImage\",      \"(Landroid/media/Image;)I\",   (void*)ImageReader_detachImage },\n    {\"nativeDiscardFreeBuffers\", \"()V\",                      (void*)ImageReader_discardFreeBuffers }\n};\n```\n\n\n\n![JNI.png](https://s2.loli.net/2022/05/13/13qiodPny2csMCW.png)\n\n\n\n# 3 追溯原因\n\n报错内容:\n\n```shell\n05-13 16:53:39.869  8798 12489 W ImageReader_JNI: Unable to acquire a buffer item, very likely client tried to acquire more than maxImages buffers\n```\n\n报错位置:frameworks/base/media/jni/android_media_ImageReader.cpp.我们可以把相关的logv 都改成可以打印出的loge看具体的差异.\n\n```c++\nstatic jint ImageReader_imageSetup(JNIEnv* env, jobject thiz, jobject image) {\n    ALOGV(\"%s:\", __FUNCTION__);\n    JNIImageReaderContext* ctx = ImageReader_getContext(env, thiz);\n    if (ctx == NULL) {\n        jniThrowException(env, \"java/lang/IllegalStateException\",\n                \"ImageReader is not initialized or was already closed\");\n        return -1;\n    }\n\n    BufferItemConsumer* bufferConsumer = ctx->getBufferConsumer();\n    BufferItem* buffer = ctx->getBufferItem();//看这个函数的调用\n    if (buffer == NULL) {\n        ALOGW(\"Unable to acquire a buffer item, very likely client tried to acquire more than\"\n            \" maxImages buffers\"); //这是报错的位置.我们看buffer 为NULL,打印了这个log\n        return ACQUIRE_MAX_IMAGES;\n    }\n```\n\n```c++\nBufferItem* JNIImageReaderContext::getBufferItem() {\n    if (mBuffers.empty()) {\n        return NULL;  //<==== 这是实际返回的NULL,说明mBuffers.empty()是为空了.然后往下面的内容看构造函数.\n    }\n    // Return a BufferItem pointer and remove it from the list\n    List<BufferItem*>::iterator it = mBuffers.begin();   //用一块，擦一块\n    BufferItem* buffer = *it;\n    mBuffers.erase(it);\n    return buffer;\n}\n```\n\n```c++\nJNIImageReaderContext::JNIImageReaderContext(JNIEnv* env,\n        jobject weakThiz, jclass clazz, int maxImages) :\n    mWeakThiz(env->NewGlobalRef(weakThiz)),\n    mClazz((jclass)env->NewGlobalRef(clazz)),\n    mFormat(0),\n    mDataSpace(HAL_DATASPACE_UNKNOWN),\n    mWidth(-1),\n    mHeight(-1) {\n    for (int i = 0; i < maxImages; i++) {   //这是构造上述BufferItem的内容,只申请了4块空间.\n        BufferItem* buffer = new BufferItem;\n        mBuffers.push_back(buffer);\n    }\n}\n```\n\n相关路径:frameworks/base/media/java/android/media/ImageReader.java\n\n```java\n    /**\n     * Attempts to acquire the next image from the underlying native implementation.\n     *\n     * <p>\n     * Note that unexpected failures will throw at the JNI level.\n     * </p>\n     *\n     * @param si A blank SurfaceImage.\n     * @return One of the {@code ACQUIRE_*} codes that determine success or failure.\n     *\n     * @see #ACQUIRE_MAX_IMAGES\n     * @see #ACQUIRE_NO_BUFS\n     * @see #ACQUIRE_SUCCESS\n     */\n    private int acquireNextSurfaceImage(SurfaceImage si) {\n        synchronized (mCloseLock) {\n            // A null image will eventually be returned if ImageReader is already closed.\n            int status = ACQUIRE_NO_BUFS;\n            if (mIsReaderValid) {\n                status = nativeImageSetup(si);//这边会对应到JNI android_media_ImageReader的对应方法\n            }\n\n            switch (status) {\n                case ACQUIRE_SUCCESS:\n                    si.mIsImageValid = true;\n                case ACQUIRE_NO_BUFS:\n                case ACQUIRE_MAX_IMAGES: //这是JNI 上报的最大值\n                    break;\n                default:\n                    throw new AssertionError(\"Unknown nativeImageSetup return code \" + status);\n            }\n\n            // Only keep track the successfully acquired image, as the native buffer is only mapped\n            // for such case.\n            if (status == ACQUIRE_SUCCESS) {\n                mAcquiredImages.add(si);\n            }\n            return status;\n        }\n    }\n```\n\n\n\n![JNI.png](https://s2.loli.net/2022/05/16/EXj5iBuNPFo3cy4.png)\n\n\n\n相关log 关键字\n\n```\nCameraService: CameraService::connect call\nCamera2ClientBase: Camera 0: Opened\nCameraDeviceClient: CameraDeviceClient\nopen_: open camera\nhal3: Constructor\ncap_intent=2\nImageReader_JNI\n```\n\n这是三方打开相机JNI的相关log.这里我们能清楚看到maxImages的值为4. 这也解释通这个三方apk只能拍4张照片的原因.一旦超过4张照片就不再申请新的buffer去拍照存第5张图片.而我们正常apk  有的设置拍照8张后会立马清空缓冲，然后重新拍照,所以不存在这个问题.也有平台专门对JNI进行更好的兼容,所以也不存在这个问题.但是目前看来这个apk 在mtk 和高通不同的项目上也存在拍照4张后无法拍第5张的情况.说明这个apk 确定很拉胯.而且平板项目这个apk没有拍照的功能.\n\n![2022-05-16 14-21-45 的屏幕截图.png](https://s2.loli.net/2022/05/16/NLPwStgWZJ1hRi5.png)\n\n\n\n# 4 修改方案\n\n在acquireNextSurfaceImage拿buffer 满的时候.给它逐一释放关闭.image.close();\n\n```diff\n\n---\n\ndiff --git a/media/java/android/media/ImageReader.java b/media/java/android/media/ImageReader.java\nindex 87c3bb9..8b7f8d0 100644\n--- a/media/java/android/media/ImageReader.java\n+++ b/media/java/android/media/ImageReader.java\n@@ -36,6 +36,7 @@\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import android.util.Log;\n \n /**\n  * <p>The ImageReader class allows direct application access to image data\n@@ -58,7 +59,7 @@\n  * production rate.</p>\n  */\n public class ImageReader implements AutoCloseable {\n-\n+    private final static String TAG = \"qtf\";\n     /**\n      * Returned by nativeImageSetup when acquiring the image was successful.\n      */\n@@ -469,6 +470,10 @@\n                     si.mIsImageValid = true;\n                 case ACQUIRE_NO_BUFS:\n                 case ACQUIRE_MAX_IMAGES:\n+                    for(Image image : mAcquiredImages){  //sprd_qtf\n+                        image.close();\n+                        }\n+                    Log.i(TAG, \"imageBuffer has been clear!\");\n                     break;\n                 default:\n                     throw new AssertionError(\"Unknown nativeImageSetup return code \" + status);\n```\n\n","tags":["3rd"]},{"title":"linux下openCV搭建","url":"/2024/11/10/搭建/linux下openCV搭建/","content":"\n# 1 依赖项\n先下载好相关的依赖项目.确保编译成功。\n```\nsudo apt-get install build-essential\nsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev\nsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libdc1394-22-dev\nsudo apt-get install libopencv-dev\n```\n# 2 源码编译\nclone 源码,我在gitee上放了一份。但是呢，实际上cmake的时候,部分内容还是会链接到github上。如果某些同学连接不到github的网站,那也没辙。\n```\ngit clone https://gitee.com/joenero/opencv.git\n```\n进入源码目录,创建一个单独文件build\n```shell\ncd opencv\nmkdir build\ncd build\n```\ncmake 一下到/usr/local/目录下\n```shell\ncmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..\n```\n执行编译\n```shell\nsudo make -j8\n```\n将make生成的文件下载到系统目录下\n```\nsudo make install\n```\n# 3 配置\n用vim打开这个文件。因为这些只读文件。有些文本编辑器可能无法强制修改。但是vim是万能的。强制保存命令为 : w ! sudo tee %\n```\nsudo vim /etc/ld.so.conf\n```\n在打开的文件添加makefile安装路劲\n```\n/usr/local/lib\n```\n再运行\n```\nsudo ldconfig\n```\n# 4示例代码\n## 4.1 cmake\ncmakelist.txt添加如下内容\n```\ninclude_directories(/usr/local/include/opencv4/opencv2)\nset (OpenCV_LIBS /usr/local/lib)\nfind_package(OpenCV REQUIRED)\ntarget_link_libraries(helloCV ${OpenCV_LIBS}) #helloCV 工程名字\n```\n完整的cmakelist.txt如下:\n```cmake\ncmake_minimum_required(VERSION 3.17)\nproject(myTool)\n\nset(CMAKE_CXX_STANDARD 14)\n\ninclude_directories(/usr/local/include/opencv4/opencv2)\nset (OpenCV_LIBS /usr/local/lib)\nfind_package(OpenCV REQUIRED)\nadd_executable(myTool main.cpp)\n\ntarget_link_libraries(myTool ${OpenCV_LIBS}) #helloCV 工程名字\n```\ndemon代码如下\n```cpp\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <string>\nusing namespace cv;\nusing namespace std;\nint main(int argc,char **argv)\n{\n    Mat img = imread(\"../test.jpeg\");\n //   cout<<img;\n    if(img.empty())\n    {\n        cout<<\"error\";\n        return -1;\n    }\n    cout<<\"My picture: \"<< img.size() <<endl;\n    imshow(\"image\",img);\n    waitKey();\n    return 0;\n}\n```\n如果出现报错： Gtk-Message: 21:57:35.293: Failed to load module \"canberra-gtk-module\" 则安装\n```shell\nsudo apt-get install libcanberra-gtk-module\n```\n## 4.2 Qt使用\n在.pro文件中添加如下内容,根据个人情况\n```pro\nINCLUDEPATH += /usr/local/include \\\n                /usr/local/include/opencv4 \\\n\nLIBS += /usr/local/lib/libopencv*\n```\n出现这个错误，只需要在对应的文件中添加头文件\n#include <opencv2/highgui/highgui_c.h>\n```\nOpenNCC_View/widget.cpp:330: error: ~~‘cvGetWindowHandle’~~ was not declared in this scope\n                 if (!cvGetWindowHandle(\"OpenNCC\"))\n                      ^~~~~~~~~~~~~~~~~\n```\n","tags":["linux"]},{"title":"Linux 命令之AWK过滤提取需要的信息","url":"/2024/11/10/Linux/Linux-命令之AWK过滤提取需要的信息/","content":"# 1 概述\nAWK是一个优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人阿尔佛雷德·艾侯、彼得·温伯格和布莱恩·柯林汉姓氏的首个字母）的最大功能取决于一个人所拥有的知识。awk经过改进生成的新的版本nawk,gawk，现在默认linux系统下日常使用的是gawk，用命令可以查看正在应用的awk的来源（ls -l /bin/awk ）\n\n# 2 基本用法\n\n```bash\nawk '{pattern + action}' <file>\n```\n\npattern表示在数据中要查找的内容\n\naction是要执行的一系列的命令\n\nawk 通过指定分隔符，将一行分为多个字段，依次用 $1、$2 ... $n 表示第一个字段、第二个字段... 第n个字段。\n\n举例有以下一个文件。我们已经知道的格式如下。想过滤的PSS和RSS之后的文件，对应的字段是3和6。通过以下命令即可过滤出第3个字段和第6个字段的内容。\n\n```\n           TOTAL PSS:   102206            TOTAL RSS:   127132      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102438            TOTAL RSS:   127364      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102494            TOTAL RSS:   127420      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102578            TOTAL RSS:   127504      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102610            TOTAL RSS:   127536      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102558            TOTAL RSS:   127484      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102378            TOTAL RSS:   127304      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102594            TOTAL RSS:   127520      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102554            TOTAL RSS:   127480      TOTAL SWAP (KB):        0\n           TOTAL PSS:   102262            TOTAL RSS:   127188      TOTAL SWAP (KB):        0\n```\n\n```\nawk '{print $3, $6}' hal_PSS.txt\n```\n\n## 2.1 分隔符\n\nawk默认分割符是空格和制表符,上面的例子中,若希望把逗号去掉则加 -F即可\n\n```\nawk -F ':|,' '{print $3 $6}' hal_PSS.txt\n```\n\n这里制定冒号（:）和逗号（,）作为作为分割符号\n\n## 2.2 条件判断\n\n将第三个字段满足小于102262的数字真与否打印出来\n\n```\nawk '{print $3<102262}' hal_PSS.txt\n```\n打印结果为\n\n```shell\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n```\n\n将第三个字段满足小于102262的那一行的信息打印出来\n\n```\nawk '$3 <102262 {print $0}' hal_PSS.txt\n```\n\n打印结果如下\n\n```\nTOTAL PSS:   102206            TOTAL RSS:   127132      TOTAL SWAP (KB):        0\n```\n\n## 2.3 统计计算\n\n### 最大值\n\n```\nawk 'BEGIN {max=0} {if($3>max) max=$3} END {print \"max PSS:\", max}' hal_PSS.txt\n```\n\n### 最小值\n\n```\nawk 'BEGIN {min=102262} {if($3<min) min=$3} END {print \"min PSS:\", min}' hal_PSS.txt\n```\n\n### 平均值\n\n```\nawk 'BEGIN {sum=0} {sum+=$3} END {print \"mean steer:\", sum/NR}' hal_PSS.txt\n```\n\n\n","tags":["linux"]},{"title":"火焰图抓取","url":"/2024/11/10/Android/火焰图抓取/","content":"@[toc]\n# 1 概述\n\nSimpleperf 是 Android 的原生 CPU 分析工具。 它可用于分析 Android 应用程序和在 Android 上运行的本机进程。 它可以在 Android 上分析 Java 和 C++ 代码。 simpleperf 可执行文件可以在 Android >=L 上运行，而 Python 脚本可以在 Android >= N 上使用。\n\n火焰图是基于 perf 结果产生的 SVG 图片，用来展示进程在一段时间 CPU 的调用栈。\n\n现代的CPU具有一个硬件组件，称为性能监控单元(PMU)。PMU具有一些硬件计数器，计数一些诸如 经历了多少次CPU周期，执行了多少条指令，或发生了多少次缓存未命中 等的事件。\n\nLinux内核将这些硬件计数器包装到硬件perf事件 (hardware perf events)中。此外，Linux内核还提供了独立于硬件的软件事件和跟踪点事件。Linux内核通过 perf_event_open 系统调用将这些都暴露给了用户空间，这正是simpleperf所使用的机制。\n\nSimpleperf具有三个主要的功能：stat,record 和 report。\n\nStat命令给出了在一个时间段内被分析的进程中发生了多少事件的摘要。以下是它的工作原理：\n\n    给定用户选项，simpleperf通过对linux内核进行系统调用来启用分析。\n    Linux 内核在调度到被分析进程时启用计数器。\n    分析之后，simpleperf从内核读取计数器，并报告计数器摘要。\n\nRecord 命令在一段时间内记录剖析进程的样本。它的工作原理如下：\n\n    给定用户选项，simpleperf通过对linux内核进行系统调用来启用分析。\n    Simpleperf 在simpleperf 和 linux 内核之间创建映射缓冲区。\n    Linux 内核在调度到被分析进程时启用计数器。\n    每次给定数量的事件发生时，linux 内核将样本转储到映射缓冲区。\n    Simpleperf 从映射缓冲区读取样本并生成 perf.data。\n\nReport 命令读取 “perf.data” 文件及所有被剖析进程用到的共享库，并输出一份报告，展示时间消耗在了哪里。\n\n# 2 抓取火焰图\n\nsimpleperf是集成在谷歌内部.直接使用即可\n\n抓取30s的perf.data 路径随便你. 我一般放在data/vendor/camera_dump\n\n```shell\nadb shell simpleperf record -p 13248 -g --duration 30 -o /sdcard/perf.data\n\nadb shell simpleperf record -p 1791 -g --duration 30 -o /data/vendor/camera_dump/simpleperf_mcu.data\n\n或者\nadb shell 进入到手机:\nsimpleperf record -g -p `pidof cameraserver` --duration 60 -o /sdcard/perf.data\nsimpleperf record -g -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data\n//示例中的 \" -p 13248 \" 指的是需要分析的进程号 \n//示例中的 \" -p 1791 \" 指的是需要分析的进程号 \n```\n\n# 3 SDK火焰图\n\n谷歌官网下载Android NDK： https://developer.android.google.cn/ndk/downloads/\n\n进入到android-ndk-r25b-linux/android-ndk-r25b/simpleperf\n将上述生产的perf.data文件拉取出来放到这个同级目录下\n```\nadb pull /sdcard/perf.data\n```\n直接运行\n\n```shell\npython report_html.py\n```\n会生成对应的火焰图.这个火焰图有三种呈现方式.呈现的偏重点不一样.\n\n以下都是进入到adb shell中执行操作:\n\n```shell\nMCPS每秒百万个时钟\n（Million Clocks Per Second）\nsimpleperf record -g -e cpu-cycles -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data --call-graph dward\n\nMIPS每秒数百万条指令\n（Million Instructions Per Second）\nsimpleperf record -g -e instructions -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data --call-graph dward\n\nMCPS_MIPS:\nsimpleperf record -g -e cpu-cycles,instructions -p `pidof camerahalserver` --duration 60 -o /sdcard/perf.data --call-graph dward\n\n#可以将相关线程合入到一个报告表中\nsimpleperf record -g -e cpu-cycles,instructions -p `pidof camerahalserver`,`pidof cameraserver`,`pidof com.sec.android.app.camera` --duration 60 -o /sdcard/perf.data --call-graph dward\n```\n\n```\nsimpleperf record -g --exclude-pid 813 880 11872 --duration 60 -o /sdcard/perf.data --call-graph dwarf\n\n-e cpu-cycles\n\npython report_html.py\n```\n\n# 4 分析火焰图\n\n火焰图x-y轴代表\n\n- x轴代表的不是时间,而是采样总量\n\n- y轴代表方法的调用栈深度,倘若方法调用用的越多,火焰越高,顶部的栈就是当前正在执行的方法\n\n栈宽含义(cpu时间)\n- 宽度可以理解为CPU采样率的占比,越宽代表当前栈在采样数中占比高,其可能为三种含义:\n  1. 函数运行时间较长\n  2. 该函数被调用次数多\n\n平顶现象：\n\n- 平顶现象是由于当前程序的采样数在总采样数中占用过高导致的,出现这种现象需要特意关注一下程序具体的调用栈,采样比例占用\n\n\n\n\n\n\n\n","tags":["Android"]},{"title":"一篇文章入门python去写shell","url":"/2024/11/10/Python/一篇文章入门python去写shell/","content":"\n# 1 基础\n\n有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（比如 Windows 下的 .exe 文件），比如C语言、[C++](http://c.biancheng.net/cplus/)、Golang、[汇编语言](http://c.biancheng.net/asm/)等，它们都属于**编译型语言**，使用的转换工具称为**编译器**。\n\n有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 [Python](http://c.biancheng.net/python/)、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/)、Shell 等，这类编程语言称为**解释型语言**，使用的转换工具称为**解释器**\n\n注意:python使用的是对其方式来区分同一级的逻辑控制。不使用分号(；)所以设置的时候，一定要设置好一个tab对4个空格，不要使用tab,不然换到其他编辑器中，容易报语法错误。tab和空格不要混用。\n\npython 中都是通过import去导入一些系统包或者自己写的包。这个和java的操作很相似,也和c中的#include <某些.h>相似。\n\n毕竟市面上绝大多数的python的底层逻辑都是用c去写的。\n\n加减乘除取余就不赘述了。所有编程的语法都是大同小异的。\n\npython在linux的环境下不需要安装，我们使用的图形化界面都是以python和一些桌面管理为基础的。\n\n一般存在的路径在/usr/bin/python, 查看python 默认的版本,直接python -v\n\npython文件开头解释器说明。我是用python3版本的。编码格式为utf-8\n\n```python\n#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n```\n\n函数入口我一般是这样定义的\n\n```python\nif __name__ == '__main__':\n    main()\n```\n\n然后在定义出main函数的运行内容\n\n```python\ndef main():\n\t执行语句\n```\n\n## 1.1 流程控制\n\n选择控制\n\n```python\ndef ifTest():\n    i = random.randint(1,100)\n    print(\"随机生成的数字为\",i)\n    if i%2 == 0:\n        print(\"是个偶数\")\n    else:\n        print(\"是个奇数\")\n```\n\n选择控制的格式如下:\n\n```python\nif 条件:\n\t执行命令\nelif 条件:\n\t执行命令\nelse:\n\t执行命令\n```\n\n循环控制 while循环和for循环的示例如下:\n\n```python\ndef whileTest(i):\n    count = 0\n    while i > 0 :\n        i -=1\n        count+=1\n        print(\"循环的第\",count,\"次\")\n\ndef forTest(i):\n    for count in range(i):\n        print(\"循环的第\",count,\"次\")\n    for count in range(0,i,3):\n        print(\"步进循环的第\",count,\"次\")\n```\n\npython不提供switch语句。虽然可以自己实现，但是我觉得没啥必要的。\n\n## 1.2 数据类型\n\npython中有6个标准的数据类型:\n\n- Number(数字型号)\n- String(字符串型号)\n- List(列表)\n- Tuple(元组)\n- Sets(集合)\n- Dictionaries(字典)\n\n### number\n\nint(x) 将x转换为一个整数。\n\nfloat(x) 将x转换到一个浮点数。\n\ncomplex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。\n\ncomplex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n\n### String\n\n#### 索引\n\n字符串直接拿引号包起来就可以了。\n\n索引下标[-1]表示倒数第一个。\n\n```python\n    s = '0123456789'\n    s1 = s[0]\n    print('s[0] = ' + s1)   #s[0] = 0\n    print('s[3] = '+ s[3])  #s[3] = 3\n    print('倒数第三个数为：' + s[-3])   #倒数第三个数为：6\n    print('最后一个数为：' + s[-1])     #最后一个数为：8\n```\n\n切片\n\n```python\n    s = '0123456789'\n    s2 = s[0:3]\n    print('s[0:3] = ' + s2)     \n    #s[0:3] = 012\n\n    print('整个字符串如下：' + s[:])    \n    #整个字符串如下：0123456789\n\n    print('整个字符串如下：' + s[0:])   \n    #整个字符串如下：0123456789\n\n    print('前两个字符：' + s[:2])      \n    #前两个字符：01\n```\n\n跳首\n\n```python\n    s = \"01234567489\"\n    print(s[0:6:2]) #行首0,行尾6，间隔2 取 打印出024\n    print(s[::2])      #024649\n    print(s[4:0:-1])   #倒着取:4321\n    print(s[3::-1])    #3210\n    print(s[-1::-1])   #98476543210\n```\n\n#### 常见的字符串操作\n\n- 大小写操作\n\n  ```python\n      s = \"adbCDefg\"\n      print(\"首字母大写\",s.capitalize())\n      print(\"全部大写  \",s.upper())\n      print(\"全部小写  \",s.lower())\n      print(\"大小写互换\",s.swapcase())\n  ```\n\n- 删除空格操作\n\n  ```python\n      s = '  xtt  123'\n      s_1 = s.strip()             #删除字符串前后的空格    \n      print(s_1)                  #xtt 123\n      s_2 = s.strip('%')          #删除字符串前后的空格 \n      print(s_2)                  #  xtt  123\n      s_3 = s.replace(\" \",\"\")     #替换掉所有的空格\n      print(s_3)                  #使用join()方法将字符串中所有的空格删除\n      s=' This is a demo code'\n      print(''.join(s.split()))   #Thisisademo\n      #其中，join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。\n  ```\n\n- 计算字符出现的次数count\n\n  ```python\n      s = '  xtt  123 xtt'\n      count = s.count(\"t\")\n      print(count)  #打印出现的次数为4次\n  ```\n\n- 分割。split不加任何参数则默认空格\n```python\n    s1 = 'I am the king of amazon!!!'\n    s2 = 'I am the: king: of amazon:'\n    s_1 = s1.split()\n    print(s_1)              #['I', 'am', 'the', 'king', 'of', 'amazon!!!']\n    s_2 = s2.split(':')\n    print(s_2)              #['I am the', ' king', ' of amazon', '']\n```\n\n- 格式化输出\n\n  ```python\n      s12_1 = '我叫{},今年{}岁，爱好{},再说一下我叫{}'.format('小明',22,'学习','小明')\n      print(s12_1)  \n      s12_2 = '我叫{0},今年{1}岁，爱好{2},再说一下我叫{0}'.format('小明',22,'学习')\n      print(s12_2)\n      s12_3 = s1 = '我叫{name},今年{age}岁，爱好{hobby},再说一下我叫{name}'.format(name = '小明',age = 18,hobby = '学习')\n      print(s12_3)\n  ```\n\n### List\n\nlist列表可以存放多个值，创建list列表，使用[ ]，多个值之间用逗号隔开，不限制数据类型\n\n```python\n    l1 =[\"joenero\",\"amazon\",\"joker\",\"father\",\"was\"]\n    print(l1)\t\t\t\t\t\t\t\t#['joenero', 'amazon', 'joker', 'father', 'was']\n    print(l1[0:4:2])\t\t\t\t\t\t#['joenero', 'joker']\n    print(l1[-3:-1])\t\t\t\t\t\t#['joker', 'father']\n```\n\nlist相关的方法如下:\n\n| 方法               | 说明                                                       |\n| ------------------ | ---------------------------------------------------------- |\n| .append(元素)      | 向列表最后追加一个元素                                     |\n| .extend(元素)      | 向列表最后追加多个元素                                     |\n| .insert(下标,元素) | 向指定的下标位置插入元素                                   |\n| .pop(下标)         | 移除下标指定的元素，如果没有指定的下标，则删除最后一个元素 |\n| .remove(元素)      | 删除指定元素                                               |\n| .clear()           | 清空列表                                                   |\n| .index(元素)       | 获取指定元素在list列表中的第一次出现的下标                 |\n| .count(元素)       | 统计元素在list列表中出现的次数                             |\n| .reverse()         | 反转list列表                                               |\n| .sort()            | 排序.默认是升序，降序添加参数:reverse=True                 |\n\n这三比较复杂,会在之后单独拎出来讲解\n- Tuple(元组)\n- Sets(集合)\n- Dictionaries(字典)\n\n# 2 添加help参数\n\n一般我们写一个需要外部输入的参数，我们都需要借用解析器argparse去获取和解析对应的内容\n\n```python\nimport argparse\n\ndef help():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-f',help='PSS文件')\n    parser.add_argument('-o',help='生成的图片')\n    args = parser.parse_args()\n    print(args)  \t\t\t\t#打印存储的所有输入值\n    print(args.f)\t\t\t\t#打印存储的-f 之后的值\n    print(args.o)\t\t\t\t#打印存储的-o 之后的值\n```\n\n然后运行这个py文件后面加-h的参数就可以显示对应的help值\n\n例如上面的内容显示如下:\n\n```shell\npython plot.py -h\nusage: plot.py [-h] [-f F] [-o O]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  -f F        PSS文件\n  -o O        生成的图片\n```\n\n\n\n# 3 文件操作\n\n## 基础\n\n\n- open\n\n  ```\n  file = open(\"fileName.txt\",mode=\"r\")\n  ```\n  | 模式 | 描述                                                         |\n  | ---- | ------------------------------------------------------------ |\n  | ‘r’  | 以「只读」模式打开文件，如果指定文件不存在，则会报错，默认情况下文件指针指向文件开头 |\n  | ‘w’  | 以「只写」模式打开文件，如果文件不存在，则根据 filename 创建相应的文件，如果文件已存在，则会覆盖原文件 |\n  | ‘a’  | 以「追加」模式打开文件，如果文件已存在，文件指针会指向文件尾部，将内容追加在原文件后面，如果文件不存在，则会新建文件且写入内容 |\n  | ‘t’  | 以「文本文件」模式打开文件                                   |\n  | ‘b’  | 以「二进制」模式打开文件，主要用于打开图片、音频等非文本文件 |\n  | ‘+’  | 打开文件并允许更新（可读可写），也就是说，使用参数 w+、a+ 也是可以读入文件的，在使用的时候，需要注意区别 |\n  \n  ```python\n      file = open(\"fileName.txt\",mode=\"r\")\n      num = 1\n      for line in file:\n          print(\"第\",num,\"行内容:\",line)\n          num +=1\n      file.close()\n  ```\n  \n- read(): 直接读取整个文件。\n\n  ```python\n      file = open(\"fileName.txt\",mode=\"r\")\n      fileCon = file.read()\n      print(fileCon)\n      \n      with open(file=r\"fileName.txt\",mode=\"r\",encoding=\"utf-8\") as f:\n          content = f.read()\n          print(content)\n  ```\n\n- readline():读一行\n\n- readlines():按行读取所有数据。结果为列表，一行为一个成员。\n\n## 实例\n\n直接举个实际例子如下:\n\n```python\n#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\"\"\"\n@File    : main.py\n@Author  : JoeNero\n@Time    : 2022/12/30 16:32\n\"\"\"\nimport argparse\nimport fileinput\nimport re\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\n\nfileName = \"\"\noutTxt   = \"\"\n\nclass INFO:\n    def __init__(self):\n        self.username = \"\"\n        self.password = \"\"\n\ndef help():\n    global fileName\n    global outTxt\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-f',help='对应的TXT文件')\n    parser.add_argument('-o',help='生成的文件')\n    args = parser.parse_args()\n    fileName = args.f\n    outTxt = args.o\n\n#读取解析txt\ndef readTxt(filename):\n    count = 0\n    aInfo = INFO()\n    for line in fileinput.input(filename):\n        if count == 0:\n            temp = line.split('username:')[1]\n            temp = temp.replace(\"\\n\",\"\")\n            # print(\"temp\",temp)\n            aInfo.username = temp\n        else :\n            temp = line.split('password:')[1]\n            # print(\"temp\",temp)\n            temp = temp.replace(\"\\n\",\"\")\n            aInfo.password = temp\n        count+=1\n    print(\"username\",aInfo.username,\"password\",aInfo.password)\n        \n#主函数入口\ndef main():\n    help()\n    if fileName == None or len(fileName):\n        print(\"输入文件不能为空\")\n    else :\n        readTxt(fileName)\n\nif __name__ == '__main__':\n    main()\n```\n\n我这边是有个外部文件。其格式如下，可以通过以上的内容来读取解析其中的内容。\n\n```\nusername:xtt\npassword:123456\n```\n\n生成临时文件. 路径为/tmp/tmp06pz62p5 文件名字为随机\n\n```python\nimport tempfile\n\ndef main():\n    dir_name = tempfile.mkdtemp()\n    print (dir_name)\n\nif __name__ == '__main__':\n    main()\n```\n\n# 4 shell\n\npython有很多操作shell的方式。需要先import 的包\n\n```python\nimport os\n```\n\n第一种方式是直接用os.system(\"command\")，其中返回0,表示执行命令成功，明显的缺点是无法将返回的值保存下来\n\n```python\ndevices = os.system(\"adb devices\")\n```\n\n第二种方式是用os.popen(\"command\")\n\nos.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。\n\n```python\ndevices = os.popen(\"adb devices\")\nprint(\"deviecs = \",devices.read())\n```\n\n打印输出的结果为\n\n```shell\ndeviecs =  List of devices attached\nL7Z5AABQAILZPBTO        device\n```\n\n配合下将其修改成如下的内容，就可以把对应的adb设备获取出来，当前只能获取到最上面的那个，可以自己根据逻辑来完善\n\n```python\ndevices = os.popen(\"adb  devices|awk '{print $1}'|sed -n '2p'\")\nprint(\"deviecs = \",devices.read())\n```\n\n注意:popen中主要涉及到文件上的操作，但是一些shell中的sleep和拍照等操作不需要返回值还是用system来操作。\n\n我实际操作拍照的时候，发现存在的这个问题。popen不生效，只有system的才生效。\n\n# 5 类\n\npython中的类和c++的及其相似。\n\n```python\n#定义INFO类,用来存储\nclass INFO:\n    def __init__(self):\n        self.username = \"\"\n        self.password = \"\"\n        \n#使用\naInfo = INFO()\naInfo.username = temp\naInfo.password = temp\n```\n\n# 6 import\n\npython import 和包含头文件的用法相似。\n\n在同一个目录下直接import 文件名即可\n\n导入模块的方式有如下几种:\n\n```python\n#hello.py\ndef say ():\n    print(\"Hello,World!\")\n\n#say.py\nimport hello\nhello.say()\n```\n临时添加模块完整路径如下:\n```\n    import sys\n    sys.path.append('D:\\\\python_module')\n```\n\n\"from 模块名 import 成员\"的形式直接导入指定成员\n\n","tags":["python"]},{"title":"anaconda3管理python包环境说明","url":"/2024/11/10/搭建/anaconda3管理python包环境说明/","content":"\n@[toc]\n# 1 概述\n\n在实际项目开发的时候,我们往往需要不同的python包版本和环境。\n\npycharm对此就有很好的器包环境。\n\n今天要介绍的是anaconda3 这个环境包管理。\n\nConda as a package manager helps you find and install packages. If you need a package that requires a different version of Python, you do not need to switch to a different environment manager, because conda is also an environment manager. With just a few commands, you can set up a totally separate environment to run that different version of Python, while continuing to run your usual version of Python in your normal environment.\n\n----Conda官网\n\nanaconda相当于一个包的管理者，去管理这些不同的环境，你可以本地建立多个虚拟环境，并且互相不影响。\n\n# 2 安装配置\n\n下载官网http://continuum.io/downloads\n\n下载下来一路回车,配置好对应的环境变量\n\n```shell\nsudo chmod 777 Anaconda3-2021.11-Linux-x86_64.sh\n./Anaconda3-2021.11-Linux-x86_64.sh\n```\n\n添加conda环境变量,根据本地下载的实际地方路径\n\n```shell\nvim ~/.bashrc\nexport PATH=~/anaconda3/bin:$PATH\n```\n\n由于我本地需要一个测试ITS的环境,并且在R版本和S版本的架构中.python的版本要求也不同,所以我同时也需要本地有python2和python3\n\n新建一个环境，设定的python版本为python2.7，然后会跳出给你安装的相关配置，一路回车。\n\n```\nconda create -n py2 python=2.7\n```\n\n激活环境命令\n\n```\nconda activate py2\n```\n\n退出当前环境命令\n\n```\nconda deactivate\n```\n\n需要在当前环境下安装对应的pip包之前需要先激活对应的环境，然后pip安装即可\n\n以下是我ITS S版本的python环境。\n\n```shell\nconda create -n py3 python=3.7.9 #这表示创建python版本为3.7.9 ,名字为py3的虚拟环境。不加python=版本 默认是2.7版本\nconda activate py3 #激活并进入py3。\nconda install opencv=3.4.2 //安装3.4.2版本的opencv 遇见选择Y/N 选择Y 下面都一样\nconda install numpy=1.19.2 //安装1.19.2版本的numpy\nconda install matplotlib=3.3.2 //安装3.3.2版本的matplotlib\nconda install scipy=1.5.2 //安装1.5.2版本的scipy\nconda install pyserial=3.5 //安装3.5版本的pyserial\nconda install pillow=8.1.0 //安装8.1.0版本的pillow\nconda install pyyaml=5.3.1 //安装5.3.1版本的pyyaml\npip install mobly //安装mobly\n```\n\n# 3 使用\n\n这边搭建一个AI环境为例子\n\n```shell\nconda create -n pyAI python=3.7.9\nconda activate pyAI #激活并进入环境\npip list \t\t\t#查看当前pip 的包\npip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple\npip install scikit-learn -i https://pypi.tuna.tsinghua.edu.cn/simple \npip install scipy -i https://pypi.tuna.tsinghua.edu.cn/simple\npip install jupyter -i https://pypi.tuna.tsinghua.edu.cn/simple\npip install nltk -i https://pypi.tuna.tsinghua.edu.cn/simple\npip install jiaba -i https://pypi.tuna.tsinghua.edu.cn/simple\npip install tensorflow -i https://pypi.tuna.tsinghua.edu.cn/simple\npip install tensorflow_addons  -i https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\nAI安装好，运行如下命令打开对应的界面\n\n```\njupyter notebook\n```\n\n# 4 使用命令\n\n```\nconda info --envs \t\t #查看存在的环境\nconda activate 环境 \t\t#激活对应的环境\n```\n\n","tags":["python"]},{"title":"Android编码文件概述","url":"/2024/11/10/Android/Android编码文件概述/","content":"@[toc]\n# 1 概述\n需要小心的是修改item后要注意CTS测项testGetWithId(android.media.cts.CamcorderProfileTest)，也就是high profile一定要和分辨率的profile适配，比如spec为1920 x 1080的spec(平台所supprot的)\n那么high的分辨率和1080p的分辨率一定要一样\n\n```xml\n     <EncoderProfile quality=\"1080p\" fileFormat=\"3gp\" duration=\"30\">\n            <Video codec=\"h264\"\n                   bitRate=\"17000000\"\n                   width=\"1920\"\n                   height=\"1080\"\n                   frameRate=\"30\" />\n            <Audio codec=\"aac\"\n                   bitRate=\"128000\"\n                   sampleRate=\"48000\"\n                   channels=\"2\" />\n        </EncoderProfile>\n```\n\n```xml\n        <EncoderProfile quality=\"high\" fileFormat=\"3gp\" duration=\"30\">\n            <Video codec=\"h264\"\n                   bitRate=\"17000000\"\n                   width=\"1920\"\n                   height=\"1080\"\n                   frameRate=\"30\" />\n            <Audio codec=\"aac\"\n                   bitRate=\"128000\"\n                   sampleRate=\"48000\"\n                   channels=\"2\" />\n        </EncoderProfile>\n```\n\n# 2 标准尺寸\n\n详细参考谷歌官网说明:\n\nhttps://developer.android.com/reference/android/media/CamcorderProfile.html#QUALITY_1080P\n\n```\npublic static final int QUALITY_1080P \npublic static final int QUALITY_2160P\npublic static final int QUALITY_2K\npublic static final int QUALITY_480P\npublic static final int QUALITY_4KDCI\npublic static final int QUALITY_720P\npublic static final int QUALITY_8KUHD\npublic static final int QUALITY_CIF\npublic static final int QUALITY_HIGH\npublic static final int QUALITY_HIGH_SPEED_1080P\n```\n\n| 标准尺寸                 |                                                              | 常量值                     |\n| ------------------------ | ------------------------------------------------------------ | -------------------------- |\n| QUALITY_1080P            | 1920x1080                                                    | 6          (0x00000006)    |\n| QUALITY_2160P            | 3840x2160                                                    | 8          (0x00000008)    |\n| QUALITY_2K               | 2048x1080                                                    | 12          (0x0000000c)   |\n| QUALITY_480P             | 720 x 480                                                    | 4          (0x00000004)    |\n| QUALITY_4KDCI            | 4096 x 2160                                                  | 10          (0x0000000a)   |\n| QUALITY_720P             | 1280 x 720                                                   | 5          (0x00000005)    |\n| QUALITY_8KUHD            | 7680 x 4320                                                  | 13          (0x0000000d)   |\n| QUALITY_CIF              | 352 x 288                                                    | 3          (0x00000003)    |\n| QUALITY_HIGH             | Quality level corresponding to the highest available resolution. | 1          (0x00000001)    |\n| QUALITY_HIGH_SPEED_1080P | High speed ( >= 100fps) quality level corresponding to the 1080p (1920 x 1080 or 1920x1088) resolution. | 2004          (0x000007d4) |\n| QUALITY_HIGH_SPEED_2160P | High speed ( >= 100fps) quality level corresponding to the 2160p (3840 x 2160) resolution. | 2005          (0x000007d5) |\n\n可以通过如下代码获取到所支持的编码尺寸\n\n```\npublic static EncoderProfiles getAll (String cameraId, \n                int quality)\n```\n\n```\n这个文件实际对应camera video 调用关系.\n\n系统启动后，通过CamcorderProfile.java：static{ } 块，初始化并解析好。以供上层获取。\n\n进入录像模式后：VideoMode.java：initRecorder——>configRecoderSpec——>getProfile，去获取摄像头或录像的默认配置。\n\nnative层主要是在 /frameworks/av/media/libmedia/MediaProfiles.cpp 文件里加载和检查参数。\n```\n\n\n\n\n","tags":["Android"]},{"title":"cmake基础","url":"/2024/11/10/CPP/cmake基础/","content":"\n# 1 概述\n\n选自百度百科:\n\nCMake是一个跨平台的安装（[编译](https://baike.baidu.com/item/编译/1258343?fromModule=lemma_inlink)）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试[编译器](https://baike.baidu.com/item/编译器/8853067?fromModule=lemma_inlink)所支持的C++特性,类似[UNIX](https://baike.baidu.com/item/UNIX/219943?fromModule=lemma_inlink)下的automake。只是 CMake 的[组态档](https://baike.baidu.com/item/组态档/4812025?fromModule=lemma_inlink)取名为 CMakeLists.txt。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 [Windows](https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink) [Visual C++](https://baike.baidu.com/item/Visual C%2B%2B/1811800?fromModule=lemma_inlink) 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个[集成开发环境](https://baike.baidu.com/item/集成开发环境/298524?fromModule=lemma_inlink)（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。\n\nlinux 下系统直接安装\n\n```\nsudo apt install cmake\n```\n\n查看cmake版本\n\n```shell\ncmake --version\ncmake version 3.16.3\n\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\n```\n\n我们一般都是通过cmake生成对应的makefile后来运行make。\n\n# 2 单个文件\n\n只有单个main.cpp的时候可以用如下CMakeLists.txt文件\n\n```cmake\n# cmake最低版本需求\ncmake_minimum_required(VERSION 3.10)\n\n# 工程名称\nproject (demo)\n\n# 设置C标准还是C++标准\nset(CMAKE_C_STANDARD 11)\n\nadd_executable(demo\n        main.cpp)\n```\n\n# 3 多个文件夹\n\n但是实际开发中玩玩会更加复杂。\n\n比如:下面每个模块都有自己的文件夹,并且每个文件夹下都有自己对应的头文件和源文件。\n\n```shell\n.\n├── abstract\n│   ├── inc\n│   │   └── abstractModel.h\n│   └── src\n│       └── abstractModel.cpp\n├── blueEar\n│   ├── inc\n│   │   └── blueEarModel.h\n│   └── src\n│       └── blueEarModel.cpp\n├── CMakeLists.txt\n├── CmakeOut\n├── main.cpp\n├── out\n└── README.md\n```\n\n这个时候我们可以看如下的内容。\n\n```cmake\n# cmake最低版本需求\ncmake_minimum_required(VERSION 3.10)\n\n# 工程名称\nproject (demo)\n\n# 设置C标准还是C++标准\n\n#set(CMAKE_C_STANDARD 11) #c标准\nset(CMAKE_CXX_STANDARD 11)#c++标准11\n\n# 设置可执行文件输出路径\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/out)\n\n# set (EXECUTABLE_OUT_PATH ${PROJECT_SOURCE_DIR}/out)\n\n#\ninclude_directories (   abstract/inc/\n                        blueEar/inc/\n                        )\n\naux_source_directory (abstract/src/ abstract_path)\naux_source_directory (blueEar/src/ blueEar_path)\n\nadd_executable(demo\n        main.cpp\n        ${abstract_path}\n        ${blueEar_path})\n```\n\n可以看到如上的内容。\n\n通过include_directories将相关的头文件包含进来\n\n```cmake\ninclude_directories\n使用的格式如下:\ninclude_directories (   abstract/inc/\n                        blueEar/inc/\n                        )\n```\n\n另外通过aux_source_directory将相关的cpp文件都加载到对应的变量中\n\n```cmake\naux_source_directory\n\n#使用的格式如下:\naux_source_directory (abstract/src/ abstract_path)\naux_source_directory (blueEar/src/ blueEar_path)\n```\n\n```cmake\n# 设置可执行文件输出路径.会输出到项目文件下的out目录下\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/out)\n```\n\ncmake过程中会生成大量的中间文件。\n\n其中的一种做法可以跟我上面一样建立一个 CmakeOut文件夹.\n\n然后进入到这个文件夹中,运行\n\n```\ncmake ..\n```\n\n这样就会把编译的中间文件生成到这个目录中,不至于破坏工程的目录。\n\n\n","tags":["cpp"]},{"title":"Andoird camera app从零养成计划【二】","url":"/2024/11/10/Android/APP/APP-2/","content":"\n# 1 API1\n\nAndroidManifest.xmlAndroidManifest官方解释是应用清单（manifest意思是货单），每个应用的根目录中都必须包含一个，并且文件名必须一模一样。这个文件中包含了APP的配置信息，系统需要根据里面的内容运行APP的代码，显示界面。示例如下:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.newcamera\">\n    <uses-permission android:name=\"android.permission.CAMERA\"/>   //使用camera的权限\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/> //写文件的权限\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"  //apk图标\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.NewCamera\">\n        <activity\n            android:name=\".PreviewActivity\"\n            android:exported=\"false\" />\n        <activity\n            android:name=\".MainActivity\"     //告知打开apk的主Activity的入口\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n```\n\n对于API 1 来说.打开camera 的对象已经封装好.在android/hardware/Camera.java中.\n\nCamera API 中主要涉及以下几个关键类:\n\n- Camera:操作和管理相机资源.支持相机资源切换.设置预览和拍摄尺寸.设置光圈,曝光等相关参数.\n\n- SurfaceView:用于绘制相机预览图像.提供实时预览的图像\n\n- SurfaceHolder:用于控制Surface的一个抽象接口.它可以控制Surface的尺寸,格式与像素等.并可以监视Surface的变化.\n\n- SurfaceHolder.Callback:用于监听Surface状态变化的接口\n\n\n\nSurfaceView和普通的View相比有什么区别呢？\n\n普通View都是共享一个Surface的,所有的绘制也都在UI线程中进行.因为UI线程还要处理其他逻辑.因此对View的更新速度和绘制帧率无法保证.这显然不适合相机实时预览这种情况.因而SurfaceView持有一个单独Surface.它负责管理这个Surface的格式.尺寸以及显示位置,它的Surface绘制也在单独的线程中进行,因而拥有更高的绘制效率和帧率。\n\n\n\nSurfaceHolder.Callback接口里定义了三个函数:\n\n- **surfaceCreated(SufaceHolder holder)**;当Surface第一次创建的时候调用.可以在这个方法里调用camera.open(),camera.setPreviewDisplay()来实现打开相机以及连接Camera与Surface等操作\n- **surfaceChanged(SurfaceHolder holder,int format,int width,int height)**;当Surface的size,format等发生变化的时候调用,可以在这个方法里调用camera.startPreview()开启预览\n- **surfaceDestroyed(SurfaceHolder holder)**;\n\n在打开相机前,我们需要获取到相机的一些基础信息\n\n```java\n    private void getCameraInfo() {\n        //有多少个摄像头\n        int numberOfCameras = Camera.getNumberOfCameras();\n\n        for (int i = 0; i < numberOfCameras; ++i) {\n            final Camera.CameraInfo cameraInfo = new Camera.CameraInfo();\n\n            Camera.getCameraInfo(i, cameraInfo);\n            //后置摄像头\n            if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {\n                faceBackCameraId = i;\n                faceBackCameraOrientation = cameraInfo.orientation;\n            }\n            //前置摄像头\n            else if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {\n                faceFrontCameraId = i;\n                faceFrontCameraOrientation = cameraInfo.orientation;\n            }\n        }\n\n        Log.e(TAG,\"faceBackCameraId =\"+faceBackCameraId+\"\\tfaceBackCameraOrientation=\"+faceBackCameraOrientation);\n        Log.e(TAG,\"faceFrontCameraId=\"+faceFrontCameraId+\"\\tfaceFrontCameraOrientation=\"+faceFrontCameraOrientation);\n    }\n```\n\n实际上打印出来的是\n\n```\n02-09 14:05:28.078  5280  5280 E CameraXTT: faceBackCameraId =0\tfaceBackCameraOrientation=90\n02-09 14:05:28.078  5280  5280 E CameraXTT: faceFrontCameraId=1\tfaceFrontCameraOrientation=270\n```\n\n## 1.1 打开相机\n\n知道了相机的相关信息,就可以通过对应的CameraID来打开对应的cameraDevices.注意 只针对单摄.双摄打开原理不一样.示例如下:\n\n```java\nimport android.hardware.Camera;\n\nprivate Camera camera = null;\n\ncamera = Camera.open(0);   //open(参数),参数对应的camera id//针对单摄的情况.可以通过这个方法直接打开对应的device设备.\n\ncamera.setPreviewDisplay(sfv_preview.getHolder());//sfv_preview是定义的SurfaceView,用来呈现相机的预览.\ncamera.setDisplayOrientation(90);   //让相机旋转90度,相机方向不对会出现拉伸情况.\ncamera.startPreview();\n```\n\n打开相机后可以获取到一个camera的对象.从这个对象里可以获取和设置相机的各种参数信息.\n\n```java\ncamera.getParameters();\n这个后面跟对应的参数：\n例如:\n camera.getParameters().getAntibanding()\n //获取预览尺寸\n Log.e(TAG,\"w\"+camera.getParameters().getPreviewSize().width+\"h=\"+camera.getParameters().getPreviewSize().height);\n```\n\n## 1.2 关闭相机\n\n关闭相机要先停止预览再release()即可\n\n```java\ncamera.stopPreview();\ncamera.release();\n```\n\n## 1.3 拍照\n\n拍照通过调用Camera的takePicture()方法来完成的.\n\n```\ntakePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback postview, PictureCallback jpeg)\n```\n\n该方法有三个参数\n\n- ShutterCallback shutter:在拍照的瞬间被回调.这里通常可以播放\"咔擦\"的音效\n\n- PictureCallback raw:返回未经压缩的图像数据\n\n- PictureCallback postview:返回postview的图像数据\n\n- PictureCallback jpeg:返回经过JPEG压缩的图像数据\n\n  我们一般用的是最后一个.实现最后一个PictureCallback即可\n\n  ```java\n  private void takePic(){\n          camera.takePicture(null, null, new Camera.PictureCallback() {\n              @Override\n              public void onPictureTaken(byte[] data, Camera camera) {\n                  Bitmap bmp = BitmapFactory.decodeByteArray(data, 0 ,data.length);\n                  String fileName = Environment.getExternalStorageDirectory().toString()\n                                  +File.separator\n                                  +\"DCIM/Camera\"\n                                  +File.separator\n                                  +\"PicTest_\"+System.currentTimeMillis()+\".jpg\";\n                  Log.e(TAG,\"fileName=\"+fileName);\n                  File file = new File(fileName);\n                  if(!file.getParentFile().exists()){\n                      file.getParentFile().mkdir();\n                  }\n                  try {\n                      BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(file));\n                      bmp.compress(Bitmap.CompressFormat.JPEG, 80, bos);//向缓冲区压缩图片\n                      bos.flush();\n                      bos.close();\n                      Toast.makeText(MainActivity.this, \"拍照成功，照片保存在\"+fileName+\"文件之中！\", Toast.LENGTH_LONG).show();\n                  }catch (Exception e){\n                      // TODO Auto-generated catch block\n                      //e.printStackTrace();\n                      Toast.makeText(MainActivity.this, \"拍照失败！\"+e.toString(), Toast.LENGTH_LONG).show();\n                  }\n                  stopPreview();\n                  startPreivew();\n              }\n          });\n      }\n  ```\n\n  \n\n# 2 API2\n\n叫出CameraManager ，打开 CameraDevice ，拿住CameraCaptureSession，发送CaptureRequest .\n\nCamera API2中主要涉及的以下几个关键类:\n\n- CameraManager:摄像头管理器.用于打开和关闭系统摄像头\n- CameraCharacteristics:描述摄像头的各种特性.我们可以通过CameraManager的getCameraCharacteristics(@NonNull String cameraId)方法来获取\n- CameraDevice:描述系统摄像头.类似早期的Camera\n- CameraCaptureSession:Session类.当需要拍照,预览等功能时,需要创建该类的实例.然后通过该实例里的方法进行控制(例如:拍照 capture())\n- CaptureRequest:描述了一个操作请求,拍照,预览等操作都需要先传入CaptureRequest参数，具体的参数控制也是通过CameraRequest的成员变量来设置\n- CaptureResult:描述拍照完成后的结果\n\n开发者通过创建CaptureRequest向摄像头发起Capture请求,这些请求会排成一个队列供摄像头处理,摄像头将结果包装在CaptureMetadata中返回给开发者.整个流程建立一个CameraCaptureSession的会话中.\n\n## 2.1 打开相机\n\n打开相机之前,要获取到CameraManger,然后获取相机列表,进而获取各个摄像头(主要是前摄和后摄)的参数\n\n```java\nCameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);\n```\n\n\n","tags":["Android","APP"]},{"title":"Android_S_ITS重构梳理","url":"/2024/11/10/GMS/Andorid_S_ITS重构梳理/","content":"# 1 概述\n\n先看its环境搭建的文档.里面有基础操作说明.\n\n然后为了更好理解梳理its的内容.我顺道整理出its 测试的脚本内容.\n\n单刀直入.找到这个总的测试文件.我们所有的整跑命令都是从这个文件中调用起来的.\n\nandroid-cts-verifier/CameraITS/tools/run_all_tests.py\nmain函数的入口\n\n```python\ndef main():\n```\n设置输出的tmp文件即测试生成的图片和log 保存的路径.\n```python \n  logging.basicConfig(level=logging.INFO)\n  # Make output directories to hold the generated files.\n  topdir = tempfile.mkdtemp(prefix='CameraITS_')\n  subprocess.call(['chmod', 'g+rx', topdir])\n  logging.info('Saving output files to: %s', topdir)\n```\n将输入的sys参数即场景拼接到scenes. 这个是针对直接输入测试cmd后面衔接场景和camera的.(exp:  python tools/run_all_tests.py camera=0 scenes=0)\n```python\n  # Override camera & scenes with cmd line values if available\n  for s in list(sys.argv[1:]):\n    if 'scenes=' in s:\n      scenes = s.split('=')[1].split(',')\n    elif 'camera=' in s:\n      camera_id_combos = s.split('=')[1].split(',')\n```\n\n读取测试testBeds. 这边和config.yml对应起来.\n\n```python\n  # Read config file and extract relevant TestBed\n  config_file_contents = get_config_file_contents()\n  for i in config_file_contents['TestBeds']:\n    if scenes == ['sensor_fusion']:\n      if TEST_KEY_SENSOR_FUSION not in i['Name'].lower():\n        config_file_contents['TestBeds'].remove(i)\n    else:\n      if TEST_KEY_SENSOR_FUSION in i['Name'].lower():\n        config_file_contents['TestBeds'].remove(i)\n```\n\n我们的config.yml 每一个TestBeds:下面会衔接\n\\- Name: TEST_BED_TABLET_SCENES  # Need 'tablet' in name for tablet scenes\n\n\\- Name: TEST_BED_SENSOR_FUSION  # Need 'sensor_fusion' in name for SF tests\n\n分别对应标准灯箱和马达灯箱\n\n继续往下看. 如果没有直接输入测试cmd后衔接参数. 而是直接python tools/run_all_tests.py.\n\n以下逻辑会走进去判断. 因为这几个值都没写.会直接读取config.yml的对应字符camera和scene后衔接的参数.\n\n```python\n  # Get test parameters from config file\n  test_params_content = get_test_params(config_file_contents)\n  if not camera_id_combos:\n    camera_id_combos = str(test_params_content['camera']).split(',')\n  if not scenes:\n    scenes = str(test_params_content['scene']).split(',')\n    scenes = [_INT_STR_DICT.get(n, n) for n in scenes]  # recover '1_1' & '1_2'\n```\n\n获取config.yml 中dut(测试机器的SN号),并且覆盖apk模式以允许写入外部存储.即让com.android.cts.verifier  拥有读写操作.  注意:我们一般把apk 下载到手机的时候 都是把相机以及其他所有权限都打开. 这两个是不一样的. 相机权限的打开是避免无法调用相机导致的fail. 而这边的读写操作主要是给apk 的各种服务开的.  使其能正常下发命令.\n\n```python\n  device_id = get_device_serial_number('dut', config_file_contents)\n  # Enable external storage on DUT to send summary report to CtsVerifier.apk\n  enable_external_storage(device_id)\n```\n\n然后获取测试图表的sn号. 如果TEST_KEY_TABLET 存在在对应的TestBeds里,则获取到table_id,否则为None\n\n```python\nTEST_KEY_TABLET = 'tablet'\n...\n\nconfig_file_test_key = config_file_contents['TestBeds'][0]['Name'].lower()\n  if TEST_KEY_TABLET in config_file_test_key:\n    tablet_id = get_device_serial_number('tablet', config_file_contents)\n  else:\n    tablet_id = None\n```\n\n获取马达舵机的控制通道\n\n```python\n  testing_sensor_fusion_with_controller = False\n  if TEST_KEY_SENSOR_FUSION in config_file_test_key:\n    if test_params_content['rotator_cntl'].lower() in VALID_CONTROLLERS:\n      testing_sensor_fusion_with_controller = True\n```\n\n预加载场景，如果cmd line没有指出场景\n\n```python\n  # Prepend 'scene' if not specified at cmd line\n  for i, s in enumerate(scenes):\n    if (not s.startswith('scene') and\n        not s.startswith(('sensor_fusion', '<scene-name>'))):\n      scenes[i] = f'scene{s}'\n```\n\n如果用户没有制定特定的场景会跑测所有的场景.\n\n创建子文件用于保存各个cameraID各个场景\n\n```python\n    # A subdir in topdir will be created for each camera_id. All scene test\n    # output logs for each camera id will be stored in this subdir.\n    # This output log path is a mobly param : LogPath\n    cam_id_string = 'cam_id_%s' % (\n        camera_id.replace(its_session_utils.SUB_CAMERA_SEPARATOR, '_'))\n    mobly_output_logs_path = os.path.join(topdir, cam_id_string)\n    os.mkdir(mobly_output_logs_path)\n```\n\n以上对config.yml的读取和检索后都重新创建一个yml文件,用于正式的跑测\n\n```\n      new_yml_file_name = get_updated_yml_file(config_file_contents)\n```\n\n\n\n# 2 跑测\n\n上面是一些跑测的文件创建和准备\n\n下面直面跑测的内容.\n\n这个逻辑是用来确定单跑和整跑的逻辑.\n\n如果输入的命令有包含tests/  则是单跑调用. 否则都是整跑，\n\n```python\n        if 'tests/' in test:\n          cmd = [\n              'python3',\n              os.path.join(os.environ['CAMERA_ITS_TOP'], test), '-c',\n              '%s' % new_yml_file_name\n          ]\n        else:\n          cmd = [\n              'python3',\n              os.path.join(os.environ['CAMERA_ITS_TOP'], 'tests', s, test),\n              '-c',\n              '%s' % new_yml_file_name\n          ]\n```\n创建subprocess 用于正式跑测\n```python\n    for num_try in range(NUM_TRIES):\n          # pylint: disable=subprocess-run-check\n          with open(MOBLY_TEST_SUMMARY_TXT_FILE, 'w') as fp:\n            output = subprocess.run(cmd, stdout=fp)\n          # pylint: enable=subprocess-run-check\n```\n\n解析mobly log 记录跑测返回的状态(skip/pass/fail),并且记录此结果\n\n大致的跑测逻辑如上概诉，真实挂测的def run(cmd): 在这不累诉\n\n## 2.1 加载场景\n\n下面看这俩个内容:\n\n```\ndef report_result(device_id, camera_id, results):\ndef load_scenes_on_tablet(scene, tablet_id):\n```\n\n加载对应场景的逻辑很简单.\n\n就是将对应场景下的png全部push进table 图表设备中.\n\npush路径为.该路径 必须要有push 的权限. 就算是市面上的机器，不然没法正确调用出对应场景的图片\n\n```python\n_DST_SCENE_DIR = '/mnt/sdcard/Download/'\n```\n\n\n\n```python\ndef load_scenes_on_tablet(scene, tablet_id):\n  \"\"\"Copies scenes onto the tablet before running the tests.\n\n  Args:\n    scene: Name of the scene to copy image files.\n    tablet_id: adb id of tablet\n  \"\"\"\n  logging.info('Copying files to tablet: %s', tablet_id)\n  scene_dir = os.listdir(\n      os.path.join(os.environ['CAMERA_ITS_TOP'], 'tests', scene))\n  for file_name in scene_dir:\n    if file_name.endswith('.png'):\n      src_scene_file = os.path.join(os.environ['CAMERA_ITS_TOP'], 'tests',\n                                    scene, file_name)\n      cmd = f'adb -s {tablet_id} push {src_scene_file} {_DST_SCENE_DIR}'\n      subprocess.Popen(cmd.split())\n  time.sleep(LOAD_SCENE_DELAY)\n  logging.info('Finished copying files to tablet.')\n```\n而对于这个函数用于改变场景和check\n```\ndef check_manual_scenes(device_id, camera_id, scene, out_path):\n```\n\n\n\n## 2.2 上报结果\n\n所有的结果都会记录到\n\n```python\nACTION_ITS_RESULT = 'com.android.cts.verifier.camera.its.ACTION_ITS_RESULT'\n```\n\n本质上是通过这个将结果上报给apk. 会在手机目录下看到类似its_camera1_scene0.txt的文件.本质上是把这个文件读写上报给测试apk\n\n```python\ndef report_result(device_id, camera_id, results):\n  \"\"\"Sends a pass/fail result to the device, via an intent.\n\n  Args:\n   device_id: The ID string of the device to report the results to.\n   camera_id: The ID string of the camera for which to report pass/fail.\n   results: a dictionary contains all ITS scenes as key and result/summary of\n            current ITS run. See test_report_result unit test for an example.\n  \"\"\"\n  adb = f'adb -s {device_id}'\n\n  # Start ItsTestActivity to receive test results\n  cmd = f'{adb} shell am start {ITS_TEST_ACTIVITY} --activity-brought-to-front'\n  run(cmd)\n  time.sleep(ACTIVITY_START_WAIT)\n\n  # Validate/process results argument\n  for scene in results:\n    if RESULT_KEY not in results[scene]:\n      raise ValueError(f'ITS result not found for {scene}')\n    if results[scene][RESULT_KEY] not in RESULT_VALUES:\n      raise ValueError(f'Unknown ITS result for {scene}: {results[RESULT_KEY]}')\n    if SUMMARY_KEY in results[scene]:\n      device_summary_path = f'/sdcard/its_camera{camera_id}_{scene}.txt'\n      run('%s push %s %s' %\n          (adb, results[scene][SUMMARY_KEY], device_summary_path))\n      results[scene][SUMMARY_KEY] = device_summary_path\n\n  json_results = json.dumps(results)\n  cmd = (f\"{adb} shell am broadcast -a {ACTION_ITS_RESULT} --es {EXTRA_VERSION}\"\n         f\" {CURRENT_ITS_VERSION} --es {EXTRA_CAMERA_ID} {camera_id} --es \"\n         f\"{EXTRA_RESULTS} \\'{json_results}\\'\")\n  if len(cmd) > 8000:\n    logging.info('ITS command string might be too long! len:%s', len(cmd))\n  run(cmd)\n```\n\n# 3 测试场景\n\n注意SUB_CAMERA_TESTS 数组保存了 对应场景 对应的测试项目. 但是这个不是最后全部的测试项目。也有部分api 测试存在于android-cts-verifier/CameraITS/tests/its_base_test.py\n\n```python\nSUB_CAMERA_TESTS = {\n    'scene0': [\n        'test_burst_capture',\n        'test_jitter',\n        'test_metadata',\n        'test_read_write',\n        'test_sensor_events',\n        'test_solid_color_test_pattern',\n        'test_unified_timestamps',\n    ],\n```\n\n另外对于以下这种场景有说明:比如场景1中的1_1,1_2 是分出来\n\n场景2 中的不同人脸图都共有测试项\n\n```python\n    'scene2_a': [\n        'test_faces',\n        'test_num_faces',\n    ],\n```\n\n\\#   scene*_1/2/... are same scene split to load balance run times for scenes\n\n\\#   scene*_a/b/... are similar scenes that share one or more tests\n\n# 4 ITS apK 代码\n\napk代码路径如下:\n\n```\ncts/apps/CtsVerifier/src/com/android/cts/verifier/camera\n目录结构如下:和camera有关的有如下的测试.\n├── bokeh\n│   └── CameraBokehActivity.java\n├── flashlight\n│   └── CameraFlashlightActivity.java\n├── formats\n│   └── CameraFormatsActivity.java\n├── fov\n│   ├── CalibrationPreferenceActivity.java\n│   ├── CameraPreviewView.java\n│   ├── CtsTestHelper.java\n│   ├── DetermineFovActivity.java\n│   ├── PhotoCaptureActivity.java\n│   ├── SelectableResolution.java\n│   └── Size.java\n├── intents\n│   ├── CameraContentJobService.java\n│   └── CameraIntentsActivity.java\n├── its\n│   ├── ItsException.java\n│   ├── ItsSerializer.java\n│   ├── ItsService.java\n│   ├── ItsTestActivity.java\n│   ├── ItsUtils.java\n│   ├── Logt.java\n│   └── StatsImage.java\n├── orientation\n│   └── CameraOrientationActivity.java\n├── OWNERS\n├── performance\n│   ├── CameraPerformanceActivity.java\n│   └── CameraTestInstrumentation.java\n└── video\n    └── CameraVideoActivity.java\n```\n\n我们重点看its 目录下的代码\n\n```shell\n├── its\n│   ├── ItsException.java   #记录异常的接口\n│   ├── ItsSerializer.java  #serialize  序列化解析json 对象\n│   ├── ItsService.java  #its 围绕这个服务进行交互的\n│   ├── ItsTestActivity.java #主要测试main\n│   ├── ItsUtils.java #检索的文件 获取图片格式等操作都在此文件内完成\n│   ├── Logt.java #传递log msg\n│   └── StatsImage.java #load ctsverifier_jni \n```\nItsTestActivity.java # 下列代码是两年前谷歌加入的为了修复tests/scene0/test_metadata.py 脚本的问题而加入的默认语言检查.所以我们使用cts-verifier apk的时候 系统的默认要美国地区的英语.不然无法进行测试\n```java\n        // Default locale must be set to \"en-us\"\n        Locale locale = Locale.getDefault();\n        if (!Locale.US.equals(locale)) {\n            String toastMessage = \"Unsupported default language \" + locale + \"! \" +\n                    \"Please switch the default language to English (United States) in \" +\n                    \"Settings > Language & input > Languages\";\n            Toast.makeText(ItsTestActivity.this, toastMessage, Toast.LENGTH_LONG).show();\n            ItsTestActivity.this.getReportLog().setSummary(\n                    \"FAIL: Default language is not set to \" + Locale.US,\n                    1.0, ResultType.NEUTRAL, ResultUnit.NONE);\n            setTestResultAndFinish(false);\n        }\n```\n这是当时谷歌的commit.  感觉谷歌的操作真的是全是堆积这种bug. 以前就没有中文语言不支持一说.\n```\nCtsVerifier: Fail Camera ITS in case of unsupported locale\n\nPer CTS specification Camera ITS must only be run with default\nlanguage set to English (United States). Check this and directly\nfail during ITS activity initialization and when processing ITS\ncommands.\nThe python script handling of socket errors must also be modified\nto appropriately notify users about this error condition.\n\nBug: 149922652\nTest: Manual using CtsVerifier app,\npython tests/scene0/test_metadata.py\n\nChange-Id: I3a2833e2fbc8e8863f5dd13600d39e7d77cea438\n```\n\nITS apk部分的源码建议去谷歌官网看.\n\n","tags":["Android","GMS","ITS"]},{"title":"Android编译概述","url":"/2024/11/10/Android/Android编译概述/","content":"\n所有的编译都要先source build/envsetup.sh\n\n然后lunch 对应的产品。\n\n整编就直接make\n\n# 1 概述\n\n- 在Andorid 7.0 之前都是使用GNU make,模块编译脚本使用Android.mk;\n\n- 之后,编译使用ninja,由kati工具把Andorid/mk转换为构建规范文件buildxxx.ninja;\n\n- Android 8.0 开始,引入编译脚本Android.bp,及工具blueprint和soong用于把Android.bp转换为buildxxx.ninja.\n\n  Android 编译脚本主要为Android.mk和Android.bp,在编译过程中都会转换为buildxxx.nija构建文件,加入到ninja构建系统中参与编译.\n\n  buildxxxx.ninja文件生成在out目录中,文件大小比较大,包含了编译中的所有配置信息.\n\n|      |                                               |\n| ---- | --------------------------------------------- |\n| m    | 编译整个源码,可以不用切换根目录               |\n| mm   | 编译当前目录下的源码.不包含他们的依赖模块     |\n| mmm  | 编译指定目录下的所有模块,不包含他们的依赖模块 |\n| mma  | 编译当前目录的下的源码,包含他们的依赖模块     |\n| mmma | 编译指定目录下的所有模块.包含他们的依赖项目   |\n\n编译环境初始化.\n\n由命令source build/envsetup.sh完成\n\n其中envsetup.sh主要做了下面几个事情.\n\n- 定义一些lunch /m /mm /mmm /provision等函数.\n\n- 确定当前的shell 环境.建立shell命令\n\n- 从device/vendor/product等目录遍历搜索vendorsetup.sh, 并source 进来\n\n- 将下面的bash文件导入到当前环境中\n\n  system/core/adb/adb.bash,\n\n  system/core/fastboot/fastboot.bash,\n\n  tools/asuite/asuite.sh\n\n# 1 image\n\n像system/vendor/dtbo/boot 这些\n\n可以直接\n\n```\nmake systemimage\nmake bootimage\nmake dtboimage\nmake vendorimage\nmake cts\n```\n\n# 2 framework\n\nframework部分内容是很复杂的一块的内容.\n\n关于cameraservice的部分可以用ninja编译 ,jni的部分也可以直接mma或者找到对应的so去编译\n\n下列命令是单编译对应的so.对于所有模块都是可以的.需要注意的是这种编译是不加依赖项的.所以会出现修改的Android.mk不生效. 对应的ninja工具需要在对应的项目内寻找.\n\n```\n ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-vnd_xxxx.ninja libcameraservice\n```\n这个路径下是apk层直接调用的硬件接口.可以用如下的命令直接编译生成framework.jar包.\n\nframeworks/base/core/java/android/hardware/\n\n```\nmake framework-minus-apex\n```\n\nadb push framework.jar system/framework/\n\n同时删除设备中system/framework目录下\n\noat,arm,arm64的三个文件夹.\n\n然后adb reboot. 不删除以上的三个文件，系统会一直处在开机动画中无法打开.\n\nframeworks/base/Android.bp的相关编译规则如下:\n\n```\njava_library {\n    name: \"framework-minus-apex\",\n    defaults: [\"framework-minus-apex-defaults\"],\n    installable: true,\n    // For backwards compatibility.\n    stem: \"framework\",\n    apex_available: [\"//apex_available:platform\"],\n    visibility: [\n        \"//frameworks/base\",\n        // TODO(b/147128803) remove the below lines\n        \"//frameworks/base/apex/appsearch/framework\",\n        \"//frameworks/base/apex/blobstore/framework\",\n        \"//frameworks/base/apex/jobscheduler/framework\",\n        \"//frameworks/base/packages/Tethering/tests/unit\",\n        \"//packages/modules/Connectivity/Tethering/tests/unit\",\n    ],\n    errorprone: {\n        javacflags: [\n            \"-Xep:AndroidFrameworkBinderIdentity:ERROR\",\n            \"-Xep:AndroidFrameworkCompatChange:ERROR\",\n            \"-Xep:AndroidFrameworkUid:ERROR\",\n        ],\n    },\n}\n```\n\n\n\n# 3 selinux\nadb shell setenforce 0会解放selinux权限\nAndroid 的selinux权限路径,但是这个是总的. 不同平台的编译本质上是编译这个路径.\n\nsystem/sepolicy\n\n```shell\nmake selinux_policy\n将编译生成的.cil相关文件push到设备中重启.\nadb push vendor/etc/selinux/* vendor/etc/selinux\n```\n\n\n\n\n\n","tags":["Android"]},{"title":"OpenGrok搭建笔记","url":"/2024/11/10/搭建/OpenGrok搭建笔记/","content":"# OpenGrok\n克隆仓库\n```\ngit clone https://github.com/JoeNero/OpenGrok.git\n```\n```\nvim ~/.bashrc\n```\n添加如下内容\n```\n#tomcat \nexport CATALINA_HOME=\"/home/xtt/OpenGrok/apache-tomcat-8.5.55\"\n\n#opengrok\nexport OPENGROK_TOMCAT_BASE=$CATALINA_HOME\n```\n保存后\n```\nsource ~/.bashrc\n```\n打开本地端口8080测试\n```\nhttp://localhost:8080\n```\n部署opengrok\n进入opengrok bin目录\n```\n./OpenGrok deploy\n```\n测试部署是否成功\n```\nhttp://localhost:8080/source\n```\n建立索引\n```\nsudo ./OpenGrok index /root/chrome  #代码存放的位置\n```\n最终生成的索引默认会存放在\n```\n/var/opengrok\n```\n\n# Ctags\n\n```\n./configure\nmake\nsudo make install\nctags --version\n```\n\n\n","tags":["openGrok"]},{"title":"数据结构 【vector】","url":"/2024/11/10/CPP/数据结构-vector/","content":"\n# 1 STL 简介\n\n> STL是Standard Template Library的简称，中文名标准模板库\nSTL可分为\n容器(containers)、\n迭代器(iterators)、\n空间配置器(allocator)、\n配接器(adapters)、\n算法(algorithms)、\n仿函数(functors)六个部分。\n\n\n选自百度词条[STL百度词条](https://baike.baidu.com/item/STL/70103?fr=aladdin)\nC++标准中，STL组件被组织命名为以下13个头文件\n\n>< algorithm>\n< deque>\n< functional>\n< iterator>\n< vector>\n< list>\n< map>\n< memory.h> \n< numeric>\n< queue> \n< set> \n< stack>\n< utility>\n# 2 容器 vector\n向量(vector) 连续存储的元素< vector>;\nvector是一个能够存放任意类型的动态数组，能够增加和压缩数据。\n为了更好理解，不用基础类型，自行定义一个MyInt结构体\n\n```cpp\nstruct MyInt\n{\n\tstring name;\t//用作标识符\n\tint Int;        //实际存储类型\n};\n```\n写一个打印函数如下\n```cpp\n/*\n功能: \t- vector类打印\n\t\t@param\n\t\t@param\n\t\t@param\n描述\t:\n示例\t:\n*/\nvoid printVector(vector<MyInt>& v)\n{\n\tfor (vector<MyInt>::iterator it = v.begin(); it != v.end(); it++)\n\t{\n\t\tcout << \"标识符为:\" << it->name << \" \";\n\t\tcout << \"数据为:\"<< it->Int << endl;\n\t}\n\tcout << endl;\n}\n```\n\n## 2.1 构造\nvector类构造demo\n```cpp\nvoid test01()\n{\n\tvector<MyInt> v1; //无参构造\n\tMyInt* myInt = new MyInt[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tmyInt[i].name = '0' + i;\n\t\tmyInt[i].Int = i;\n\t\tv1.push_back(myInt[i]);\n\t}\n\tprintVector(v1);\n\tvector<MyInt> v2(v1.begin(), v1.end());\n\tprintVector(v2);\n\tvector<MyInt>::iterator it = v1.begin();\n\tvector<MyInt> v3(it+1, v1.end());\n\tprintVector(v3);\n\tdelete[] myInt;\n}\n```\n运行结果如下，因为用了迭代器来访问v1.begin() + 1的位置 ，(非基础类型不能用v1[1]访问),所以打印v3容器输出的结果是1到9\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cd43e6bd2b8d53298c83d9d6dc3ff2b2.jpeg)\n## 2.2 成员函数\n基础访问操作:（注意v3.at[int index]适合访问基础类型,int,char等，自定义的类型还是用迭代器访问）\nvector不支持头插(push_front)\n```cpp\nv3.push_back(elem)  //在尾部插入一个elem数据。\nv3.pop_back()       //删除末尾的数据。\nv3.at(int index)\t//传回索引为index的数据,如果index越界\n\t\t\t\t\t//抛出out_of_range异常。\n\t\t\t\t\t//非基础类型需要通过迭代器访问\n```\n### 2.2.1 assgin\nv3.assign(beg,end)将[beg,end)一个左闭右开区间的数据赋值给v3。\n```cpp\n\tv3.assign(v1.begin(), v1.end());\n\tprintVector(v3);\n```\nv3.assign (n,elem)将n个elem的拷贝赋值给v3。\n```cpp\n\tv3.assign(2, myInt[2]);\n\tprintVector(v3);\n```\n输出结果如下:\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8f4409bb6edf35adcb6ebecb83746ac9.jpeg)\n### 2.2.2 数据大小操作\n#### 2.2.1.empty\nv1.empty() //  判空操作 \n先看empty()定义\n```cpp\n    _NODISCARD bool empty() const noexcept {\n        auto& _My_data = _Mypair._Myval2;\n        return _My_data._Myfirst == _My_data._Mylast;\n    }\n```\n测试容器空的状况:\n```cpp\n\tvector<MyInt> v1; //无参构造\n\tcout << v1.empty() << endl;\n```\n空返回1\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d1d724b0d342e5c785976127f9cb4a2f.jpeg)\n非空返回 0\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f681f1fda108aa3696c04aa80a2a0b76.jpeg)\n了解empty后修改打印函数(暂时不抛出异常)\n```cpp\nvoid printVector(vector<MyInt>& v)\n{\n\tif (v.empty())\n\t{\n\t\tcout << \"打印Vector为空\";\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tfor (vector<MyInt>::iterator it = v.begin(); it != v.end(); it++)\n\t\t{\n\t\t\tcout << \"标识符为:\" << it->name << \" \";\n\t\t\tcout << \"数据为:\" << it->Int << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\n```\n#### 2.2.2  容量\n参考链接[capacity用法](https://blog.csdn.net/JIEJINQUANIL/article/details/51166154)\n|函数|  功能|\n|--|--|\n|capacity() |  容器能存储 数据的个数(真实大小)|\n|size() |目前存在的元素个数|\n|  max_size  |    最大容量    |\n|resize()     | 重新指定大小 ，若指定的更小，超出部分元素被删除|\n|reserve |\t 预留空间|\n\n\n```cpp\n\tcout << \"v1真实的大小 = \" << v1.capacity() << endl;\t\t//真实的大小\n\tcout << \"v1的大小 = \" << v1.size() << endl;\n\tcout << \"v1最大容量 = \" << v1.max_size() << endl;\n```\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/67b826a0fe159edebbc23f08616daa89.jpeg)\nresize()使用，\n重新指定大小10的v1容器为12，多指定的空间重新插入内容myInt[2]；\n\n```cpp\n\tv1.resize(12, myInt[2]);\n\tprintVector(v1);\n```\n打印输出结果:\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5fa6feb23652dc4f316bd766deac09f6.jpeg)\n重新指定v1打下，删除超过索引的内容\n```cpp\n\tv1.resize(2);\n\tprintVector(v1);\n```\n输出结果\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8b63a542688e35cfd61689810353b8e5.jpeg)\n### 2.2.3 删除与插入操作\n|操作|说明  |\n|--|--|\n|  pop_back()\t|  尾删|\n|\tinsert（）|\t插入操作|\n|  \terase()  | 擦除    |\n|\t|\t|\n测试代码如下:\n\n```cpp\n\tvector<MyInt> v1; //无参构造\n\tMyInt* myInt = new MyInt[3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmyInt[i].name = '0' + i;\n\t\tmyInt[i].Int = i;\n\t\tv1.push_back(myInt[i]);\n\t}\n\tprintVector(v1);\n\t//尾删\n\tv1.pop_back();\n\tprintVector(v1);\n\t//插入\n\tvector<MyInt>::iterator it = v1.begin();\n\n\tv1.insert(it+1, myInt[1]);\n\tcout << \"\" << endl;\n\tprintVector(v1);\n\tv1.insert(v1.begin(), 2, myInt[2]);\n\tprintVector(v1);\n\t////删除\n\tv1.erase(v1.begin());\n\tcout << \"擦除头:\" << endl;\n\tprintVector(v1);\n\t////清空\n\t//v1.erase(v1.begin(), v1.end());\n\t//printVector(v1);\n\tv1.clear();\n\tprintVector(v1);\n\tdelete[] myInt;\n```\n打印输出结果\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/70b367434aee7da1b47c36dced4fab0f.jpeg)\n### 2.2.4 swap\n速览其定义:\n```cpp\n    void swap(vector& _Right) noexcept /* strengthened */ {\n        if (this != _STD addressof(_Right)) {\n            _Pocs(_Getal(), _Right._Getal());\n            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);\n        }\n```\n\nswap交换，直接看代码吧:两容器大小需要一致，否在会进入异常\n```cpp\n\tvector<MyInt> v1; \n\tvector<MyInt> v2;\n\tMyInt* myInt = new MyInt[3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmyInt[i].name = '0' + i;\n\t\tmyInt[i].Int = i;\n\t\tv1.push_back(myInt[i]);\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmyInt[i].name = '0' + i;\n\t\tmyInt[i].Int = 3 - i;\n\t\tv2.push_back(myInt[i]);\n\t}\n\tcout << \" v1 =\" << endl;\n\tprintVector(v1);\n\tcout << \" v2 =\" << endl;\n\tprintVector(v2);\n\t//互换容器\n\tcout << \"互换后\" << endl;\n\tv1.swap(v2);\n\tcout << \" v1 =\" << endl;\n\tprintVector(v1);\n\tcout << \" v2 =\" << endl;\n\tprintVector(v2);\n```\n输出打印结果如下:\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/76d01921df3a4cba71f040a84ae42ae5.jpeg)\n在实际应用中swap常常用于与自身交换来达到收缩内存的效果，这里不加累述\n[swap收缩内存参考链接](https://blog.csdn.net/liyazhen2011/article/details/103179974)\n#  3 vector总结\n|成员函数\t|  \t说明\t|\n|--|--|\n| \tpush_back | \t尾插\t |\n|\tassign|\t[assgin用法](https://blog.csdn.net/qq844352155/article/details/38583529)|\n|\tresize\t|\t重构大小\t|\n|\tcapacity|\t 容量(真实大小)|\n|\tsize|\t当前大小 |\n| max_size| 最大容量 |\n| pop_back\t|\t尾删\t |\n|  insert\t|\t插入\t|\n |erase \t|\t删除\t|\n |\t\tclear\t|\t清空|\n |\tswap\t\t|\t\t交换|\n |reserve  |\t\t预留空间|\n \n\n\n\n","tags":["cpp"]},{"title":"python爬取天气","url":"/2024/11/10/Python/python爬取天气/","content":"\n# 1 安装使用\n\nVSCode中安装相关的插件就可以配合chatgpt来实现一些简单的爬虫操作，只能应对比较简单的场景.\n安装插件\nchatGPT-ChatMoss\n\n# 2 实例\n\n给AI发送\npython 爬取无锡七日天气\n回复如下:\n要爬取无锡七日天气，可以使用Python中的第三方库 requests 和 Beautiful Soup。以下是详细步骤：\n\n1. 导入必要的库\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n```\n\n2. 发送GET请求获取网页内容\n\n```python\nurl = \"http://www.weather.com.cn/weather/101190201.shtml\"\nresponse = requests.get(url)\n```\n\n3. 解析网页内容\n\n```python\nsoup = BeautifulSoup(response.content, \"html.parser\")\n```\n\n4. 找到需要的天气信息所在的标签\n\n```python\nweather_data = soup.select(\".t>li\")\n```\n\n5. 提取天气信息并输出\n\n```python\nfor weather in weather_data:\n    # 获取日期、天气状况、最高温度和最低温度\n    date = weather.select_one(\".date\").get_text()\n    condition = weather.select_one(\".wea\").get_text()\n    high_temperature = weather.select_one(\".tem span\").get_text()\n    low_temperature = weather.select_one(\".tem i\").get_text()\n\n    # 打印天气信息\n    print(date, condition, high_temperature, low_temperature)\n```\n\n完整代码如下：\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = \"http://www.weather.com.cn/weather/101190201.shtml\"\n\nresponse = requests.get(url)\n\nsoup = BeautifulSoup(response.content, \"html.parser\")\n\nweather_data = soup.select(\".t>li\")\n\nfor weather in weather_data:\n    date = weather.select_one(\".date\").get_text()\n    condition = weather.select_one(\".wea\").get_text()\n    high_temperature = weather.select_one(\".tem span\").get_text()\n    low_temperature = weather.select_one(\".tem i\").get_text()\n\n    print(date, condition, high_temperature, low_temperature)\n```\n\n但是上述实际运行是存在一些小问题的。\n\n打印结果如下: 这个很明显就是date这个数据为None\n\n```powershell\nNone <p class=\"wea\" title=\"多云\">多云</p> <span>28</span> <i>17℃</i>\nNone <p class=\"wea\" title=\"多云\">多云</p> <span>27</span> <i>15℃</i>\nNone <p class=\"wea\" title=\"多云\">多云</p> <span>24</span> <i>12℃</i>\nNone <p class=\"wea\" title=\"阴转小雨\">阴转小雨</p> <span>20</span> <i>15℃</i>\nNone <p class=\"wea\" title=\"阴\">阴</p> <span>15</span> <i>13℃</i>\nNone <p class=\"wea\" title=\"小雨\">小雨</p> <span>19</span> <i>14℃</i>\nNone <p class=\"wea\" title=\"小雨转晴\">小雨转晴</p> <span>16</span> <i>8℃</i>\n```\n\n继续追问机器人:\n\n优化下代码，没有获取到天数，并且这个get_text有报错.\n\n机器人直接回复:\n\n以下是优化后的代码，已解决上述问题：\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = \"http://www.weather.com.cn/weather/101190201.shtml\"\n\nresponse = requests.get(url)\n\nsoup = BeautifulSoup(response.content, \"html.parser\")\n\nweather_data = soup.select(\".t li\")\n\nfor weather in weather_data:\n    # 获取日期、天气状况、最高温度和最低温度\n    date = weather.select_one(\"h1\").get_text()\n    condition = weather.select_one(\".wea\").get_text()\n    high_temperature = weather.select(\".tem span\")[0].get_text()\n    low_temperature = weather.select(\".tem i\")[0].get_text()\n\n    # 打印天气信息\n    print(date, condition, high_temperature, low_temperature)\n```\n\n\n在优化代码时，我们对原有代码进行了以下改进：\n\n- 将CSS选择器中的“>”删除，因为它只会选择直接子元素，导致无法获取到所有的天气信息。\n- 由于天数信息并不在 \".date\" 标签内，所以将日期信息从该标签中提取出来。在这里，我们使用了 h1 标签来获取日期信息。\n- 使用 select() 方法来选取多个元素，并且使用索引 [0] 来定位到需要的元素，因为 .select_one() 方法只能返回单个元素，如果要选取多个元素，需要使用 select() 方法。同时，我们还修改了 \".tem span\" 和 \".tem i\" 的类选择器，以便正确获取最高温度和最低温度。\n- 在使用 get_text() 方法时，需要确保该元素存在并且不为空。如果该元素不存在或为空，会导致 AttributeError 异常。\n\n\n这一次就非常好用了.\n\n打印出的结果如下:\n\n```powershell\n19日（今天） 多云 28 17℃\n20日（明天） 多云 27 15℃\n21日（后天） 多云 24 12℃\n22日（周六） 阴转小雨 20 15℃\n23日（周日） 阴 15 13℃\n24日（周一） 小雨 19 14℃\n25日（周二） 小雨转晴 16 8℃\n```\n\n","tags":["python"]},{"title":"CTS基础操作","url":"/2024/11/10/GMS/cts基础操作/","content":"# 手机端\n设置永久不锁屏\n# 1 CTS\n进入cts目录tools\n运行以下命令\n```\n./cts-tradefed\nadb devices找设备数串\n```\n```\n整跑\nrun cts -m CtsCameraTestCases --skip-preconditions\nrun cts -m CtsMediaTestCases\n单测格式如下 -t 后面是单跑的内容\nrun cts -m CtsCameraTestCases -t android.hardware.camera2.cts.StillCaptureTest#testAeCompensation --skip-preconditions\n```\n```\n查看设备状态\nl d\n查看报告状态\nl r\n查看当前命令\nl c\n打开报告\nnautilus ./\nrun retry --retry <session-number>\n重跑(注意:重跑需要同一个机子同一个版本)\nrun retry --retry session\nrun retry --retry 0\n```\n以上的是在环境中跑cts.\ncts 的本质是下载测试的apk到手机中（在谷歌释放包中CtsCameraTest.apk），这个apk集成了测试相关的内容来调用手机的一些功能完成测试项目\n以下命令在终端运行即可，替换成你需要跑的单项和abi\n```\nadb shell am instrument -e android.hardware.camera2.cts.CameraDeviceTest#testSessionParametersStateLeak --abi arm64-v8a  -w android.camera.cts/androidx.\n```\n# 2 VTS(需要镜像)\nvts 需要python 相关的环境包配置,相关命令如下:\n```\nsudo apt-get install python-dev\nsudo apt-get install python-protobuf\nsudo apt-get install protobuf-compiler\nsudo apt-get install python-virtualenv\nsudo apt-get install python-pip\nsudo apt-get install python-numpy\nsudo apt-get install python-scipy\nsudo apt-get install python-matplotlib\nsudo apt-get install python-opencv\n```\n## 2.1进入fastbootd模式\n```\nadb unroot\nadb reboot fastboot #进入这个模式刷system.img,bootloader模式没有这个分区\n```\n## 2.2 system.img\n刷入谷歌 system.img\n```\nfastboot flash system system.img\n```\n查看gsi版本日期\n```\nstrings system.img | grep ro.build.version.security_patch\n```\n```\nadb shell getprop ro.build.version.security_patch\n```\n重新进入fastboot\n```\nfastboot reboot bootloader\nfastboot -w\n```\n##  2.3 boot-debug.img\nvts需要debug的权限，所以需要刷debug的镜像,另外fastboot 的版本不能太旧,太久分区不对，刷system.img会破坏分区，导致无限重启无法进去到系统里面进去.\n```\nfastboot flash boot boot-debug.img\nfastboot -w\nfastboot reboot\n```\n## 2.4 手机配置\n进入设置打开开发者模式,usb调试模式,不锁定屏幕,语言设置成英语(这个语言无所谓)\n## 2.5 命令\n需要连接外网(电脑)\n```\n ./vts-tradefed\nVTS camera 相关的三个模块\nrun vts -m VtsHalCameraProviderV2_4Target --skip-preconditions\nrun vts -m VtsHalCameraProviderV2_5Target --skip-preconditions\nrun vts -m VtsHalCameraServiceV2_0Target --skip-preconditions\n单跑\nrun vts --include-filter VtsHalCameraProviderV2_4Target --include-filter VtsHalCameraProviderV2_5Target --include-filter VtsHalCameraServiceV2_0Target --include-filter VtsVndkDependency -s xxx；\n单跑命令\nrun vts -m xxx -t xxx -s xxx\nrun vts -s\n```\nvts常用命令\n列出所有的跑测结果\n```\nl  r\n```\n列出所有渐层到或已知的设备\n```\nl d\n列出当前运行的模块内容\nl i\n```\n单跑某个模块\n```\nrun vts -m <模块>\n```\n可用选项\n```\nrun vts -s <device_id> --logcat-on-failure --screenshot-on-failure --shard-count <shards>\n```\n# 3 ITS\nits以来python环境(不建议使用ubuntu20测试,默认python包可能太新，跑不起来)\n## 3.1 环境包\n```\nsudo apt install python-numpy\nsudo apt install python-scipy\nsudo apt install python-matplotlib\nsudo apt install python-opencv\n```\n## 3.2 手机端\n手机需要安装CtsVerifier.apk\n```\nadb install CtsVerifier.apk\n```\n进入到手机apk，所有的权限都打开，选择its测试项目\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/98bd0b0e3985e78f88f07014ebaf5ade.png#pic_center)\n\n然后选择测试的场景和摄像头\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5b08b61f99d217a0609f2e75a70e1800.jpeg#pic_center)\n\n## 3.3 电脑端\n进入到对应的tools目录下\n```\nandroid-cts-verifier/CameraITS\n```\n```\nsource ./build/envsetup.sh\n```\n整跑命令\n```\npython tools/run_all_tests.py device=017650f70401   camera=0 scenes=1\n```\n单跑命令\n```\npython ./tests/xxx/xxx.py camera=x（执行tests目录下的对应scenes的报错项）。\npython tools/run_all_tests.py camera=0 scenes=1\n```\n## 3.4 场景说明\n\n| 场景       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 场景0      | 无任何要求                                                   |\n| 场景1      | 相机位于三脚架上, 指向一个静态场景, 其中包含灰色卡和白色背景, 在恒定 (稳定) 相对明亮的光照源下。这是 CTS 验证程序物理设置上面描述的场景。镜头视野中，灰卡大致放在中间，周围为白色背景 |\n| 场景 2 | 这是测试人脸检测的场景。相机位于三脚架上, 指向一张包含3人脸的静态图片, 在恒定 (稳定) 相对明亮的照明光源下。 |\n| 场景3 | 这是测试图像清晰度的场景。相机位于三脚架上, 指向包含某些边缘的静态图片, 如打印的 ISO 12233 图表。现场应在一个恒定 (稳定) 相对明亮的照明源。 |\n| 场景4 | 这是测试纵横比的场景。相机位于三脚架上, 指向一个静态测试页, 其中包含一个黑色圆圈和一个方块。现场应在一个恒定 (稳定) 相对明亮的照明源 |\n| 场景5 | 这是测试镜头着色和颜色均匀性的场景。在摄像机前放置一个扩散器。相机位于三脚架上，指向恒定的 (稳定) 相对地明亮的照明源。 |\n我们这边就用的一张白色餐巾纸代替了扩散器，将镜头对着光源，用餐巾纸挡住镜头即可。（很好使，反正不用钱）场景的具体说明看its的官方文档\n## 3.5 创建报告\n单跑是空的，显示在终端上。暂不创建报告\n```\nadb shell\nappops set com.android.cts.verifier android:read_device_identifiers allow\nexit\nadb pull /storage/emulated/0/verifierReports ~/桌面/\n\n```\n# 4 GTS\n进入到tool目录下,手机电脑需要挂VPN 连接外网\n```\nrun gts -m GtsCameraTestCases -s xxx\nrun gts -m GtsCameraTestCases -s 008bcdcf0405\n```\n# 5 STS\n安全补丁包测试以后再说\n# 6 GSI\n需要烧录谷歌镜像\n进入fastboot模式\n```\nadb reboot fastboot\n```\n刷入对应的谷歌镜像system.img\n```\nfastboot flash system system.img\n```\n```\nfastboot reboot bootloader\nfastboot -w\nfastboot oem unlock\nadb reboot bootloader\nfastboot reboot\n```\n打开开发者选项,打开stay awake和USB debugging\n进入vts目录，运行     ./vts-tradefed\n```\n全跑      \nrun cts-on-gsi -m CtsCameraTestCases\n单跑\nrun cts-on-gsi --include-filter CtsCameraApi25TestCases --include-filter CtsCameraTestCases -s xxx\nrun cts-on-gsi -m CtsCameraTestCases -t xxx\nrun cts-on-gsi -o\n```\n\n\n\n","tags":["Android","cts","GMS"]},{"title":"数据结构 【链表】","url":"/2024/11/10/CPP/数据结构_链表/","content":"\n# 1 链表的创建\n链表是一种物理存储单元上非连续、非顺序的存储结构。[摘自百度百科](https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fr=aladdin)\n如下存储:\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f48f0f5139f85857d9312f68547090a9.png#pic_center)\n\n```cpp\nstruct Node\n{\n\tint data;  //数据域\n\tNode* next;//指针域\n\tNode():data(0),next(nullptr){}\n\tNode(int _data,Node* _next)\n\t{\n\t\tthis->data = _data;\n\t\tthis->next = _next;\n\t}\n};\n```\n## 1.1 头插\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/632c55adc58345acff9828e9156eccf8.png#pic_center)\n\n```cpp\nvoid pushFront(Node* head, int data)\n{\n\tNode* pNew= new Node();           //定义新节点头\n\tpNew->data = data;                //存储数据\n\tif (nullptr== head->next)\t\t\t//判断是不是只有头结点\n\t{\n\t\thead->next = pNew;                 \n\t}\n\tpNew->next = head->next;\n\thead->next = pNew;\n}\n```\n## 1.2 尾插\n尾插:\n申请一个新的节点pNew.将要插入的数据赋值给pNew节点的数据域.并且将pNew的指针域指向空.\n定义一个节点p指向head(实际操作时一般定义一个新的节点来操作,以便返回头结点)\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/32562b09f6b08b564462edc635094d76.png#pic_center)\n\n```cpp\nvoid pushBack(Node* head, int data)\n{\n\tNode* pNew = new Node;          //定义一个Node结点指针newNode\n\tpNew->next = NULL;              //定义newNode的数据域和指针域\n\tpNew->data = data;\n\tNode* p = head;                 //定义指针p指向头结点\n\tif (head == NULL)\n\t{                               //当头结点为空时，设置newNode为头结点\n\t\thead = pNew;\n\t}\n\telse                            //循环直到最后一个节点，将newNode放置在最后\n\t{\n\t\twhile (p->next != NULL)\n\t\t{\n\t\t\tp = p->next;\n\t\t}\n\t\tp->next = pNew;\n\t}\n}\n```\n## 1.3 获取链表长度\n```cpp\nint getLens(Node* head)\n{\n\tint lens = 0;\n\tif (head->next!=nullptr)\n\t{\n\t\tlens++;\n\t\thead = head->next;\n\t}\n\treturn lens;\n}\n```\n# 2 翻转链表\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8c9f8af8dce4ffb2b62ca9986fba3e80.png#pic_center)\n\n```cpp\nvoid reverse(Node* head)\n{\n\tif ((head->next == nullptr )||(head->next->next == nullptr))\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tNode* pCur = head->next;\n\t\tNode* pNext = pCur->next;\n\t\tNode* pre = nullptr;\n\t\twhile (pNext)\n\t\t{\n\t\t\tpCur->next = pre;\n\t\t\tpre = pCur;\n\t\t\tpCur = pNext;\n\t\t\tpNext = pCur->next;\n\t\t}\n\t\tpCur->next = pre;\n\t\thead->next = pCur;\n\t\treturn;\n\t}\n}\n```\n","tags":["cpp"]},{"title":"git的使用","url":"/2024/11/10/Linux/git的使用/","content":"\n# 1.git 下载\n最好是更新下镜像源\n\n```powershell\nsudo apt-get update\n```\n下载git\n```powershell\nsudo apt-get install git\n```\n![](https://i-blog.csdnimg.cn/blog_migrate/57610ea2389eed7f411f029a43c3c8b5.png)\n检测git下载成功的版本\n\n```powershell\ngit version\n```\n版本显示正确后执行再执行下一步\n![](https://i-blog.csdnimg.cn/blog_migrate/804594cf93c6f0f70dbe0f7e487fed39.png)\n# 2 ssh \nssh具体内容参考百度词条[ssh](https://baike.baidu.com/item/SSH/10407)\n执行\n\n```powershell\nsudo apt-get install ssh \n```\n显示如下\n![](https://i-blog.csdnimg.cn/blog_migrate/2d7bb5fce1275523d01140a2a1c01424.png)\n查看ssh服务\n```powershell\nps -e | grep sshd\n```\n显示sshd的话表示ssh-server已经启动\n![](https://i-blog.csdnimg.cn/blog_migrate/ccac9456c7008cd8439c45c645c8c26e.png)\n生成ssh-key\n```powershell\nssh-keygen -t rsa -C \"你的邮箱@qq.com\"\n```\n生成后默认就行，直接回车生成文件隐藏\n用下面命令检测是否在根目录下生存(上面建议默认，是直接在根目录下生成的)\n\n```powershell\n ls -al ~/.ssh\n```\n![](https://i-blog.csdnimg.cn/blog_migrate/de0994ad8d808f189ed4ec9030615e3b.png)\n然后打开显示隐藏文件\n![](https://i-blog.csdnimg.cn/blog_migrate/eb47eba16f9a712bd8047524f5f5eb84.png)找到\n![](https://i-blog.csdnimg.cn/blog_migrate/bcc065d14a29d13598f4d56647b41ed2.png)\n再进入到文件夹下找到以下文件，这个是公钥。\n打开这个文件将其内容复制(用记事本或者vim打开都行)\n![](https://i-blog.csdnimg.cn/blog_migrate/7c0c0e8b5c356f45ba34f74f38fd475a.png)\n![](https://i-blog.csdnimg.cn/blog_migrate/c787fd589d622eef983fe42f02857eff.png)打开你的github帐号，进入你的settings\n![](https://i-blog.csdnimg.cn/blog_migrate/c948ad84b69384cd61385fe7347ad056.png)找到ssh\n![](https://i-blog.csdnimg.cn/blog_migrate/978cb04f1e14a96e65df43568252c90d.png)\n新建一个ssh\n![](https://i-blog.csdnimg.cn/blog_migrate/df880886f641c1af1f64f360b189b121.png)将复制的内容粘贴进去后便是如上显示\n# 3 git 使用\n## 3.1 新建仓库\n![](https://i-blog.csdnimg.cn/blog_migrate/d9eb93e958f4078d7cbca14191487f6d.png)\n这部分比较简单(其实都不难)，直接看图说话吧。名字和描诉整干净后直接创建仓库\n\n![](https://i-blog.csdnimg.cn/blog_migrate/4eb16a6a5731d31d61aea7dca0a0c4eb.png)然后把地址复制下来\n![](https://i-blog.csdnimg.cn/blog_migrate/460b2d3f06233ee1b0a8aaade07a981e.png)\n## 3.2 git它！！！git就万事了\n在你自己的文件夹下git clone远程仓库\n```powershell\ngit clone 网址\n```\n然后进入到目录里初始化他\n![](https://i-blog.csdnimg.cn/blog_migrate/36735234074ff0312a22d082cb636779.png)\n在该目录下创建你自己的文件,这个随便你怎么建立，touch 是创建命令\n\n```cpp\ntouch README.md\n```\ngit add .  是有个空格后再家一个点。直接该该目录下的文件添加到暂存区域\ngit add 文件名  是直接将相应的文件添加到暂存区域\n```powershell\ngit add .\n#git add README.md\n```\n提交本次修改\ngit commit\n\n```powershell\ngit commit -m \"add readme file\" #提交本次修改\n```\n推送到远程仓库\n格式为 git push (brash) 我这里是直接推送到origin master\n```powershell\ngit push origin master\t#推送到远程仓库\n```\n\n\n\n![](https://i-blog.csdnimg.cn/blog_migrate/e1c8ad0468251a3f08b6c1b1de785d3e.png)\n输入你名字和密码\n![](https://i-blog.csdnimg.cn/blog_migrate/524377bf2fdf3cca28cc2a639e873c5a.png)\n刷新你的仓库，内容就提交上去了\n![](https://i-blog.csdnimg.cn/blog_migrate/d4fb82ae9b4940d3130cff0c98c91b05.png)\n\n\n更多笔记请访问\n[JoeNero私人博客](https://joenero.github.io)\n参考链接\n[参考链接1](https://blog.csdn.net/wxy540843763/article/details/80197301)\n[参考链接2](https://blog.csdn.net/qicheng777/article/details/74724015)\n","tags":["git"]},{"title":"Andoird camera app从零养成计划【一】","url":"/2024/11/10/Android/APP/APP_1/","content":"\n要创建一个基本的Camera App demo，我们将使用Android Studio和Java来编写一个应用，该应用能够打开相机预览，拍照，并保存照片到设备的存储中。这里将使用Android的Camera2 API，因为它提供了更丰富的功能和更好的性能，尽管它比Camera API（已弃用）更复杂一些。\n\n### 步骤 1: 创建一个新的Android项目\n\n1. 打开Android Studio，选择“Start a new Android Studio project”。\n2. 选择“Empty Activity”，然后点击“Next”。\n3. 填写你的应用名称（如 `CameraDemo`），选择你的保存位置，语言选择Java，最小API级别设置为21（因为Camera2 API在API 21（Android 5.0）上引入）。\n4. 点击“Finish”创建项目。\n\n### 步骤 2: 添加权限\n\n在你的 `AndroidManifest.xml` 文件中添加必要的权限：\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"你的包名\">\n\n    <uses-permission android:name=\"android.permission.CAMERA\"/>\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-feature android:name=\"android.hardware.camera\" android:required=\"true\"/>\n    <uses-feature android:name=\"android.hardware.camera.autofocus\"/>\n\n    <application\n        ...\n        >\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n```\n\n### 步骤 3: 布局文件\n\n修改 `res/layout/activity_main.xml` 文件来添加必要的视图控件（如TextureView用于显示相机预览，Button用于拍照）：\n\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <TextureView\n        android:id=\"@+id/textureView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:layout_above=\"@+id/button_capture\" />\n\n    <Button\n        android:id=\"@+id/button_capture\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentBottom=\"true\"\n        android:layout_centerHorizontal=\"true\"\n        android:text=\"拍照\" />\n\n</RelativeLayout>\n```\n\n### 步骤 4: 编写MainActivity\n\n由于Camera2 API较为复杂，这里不会详细展开全部代码，但会概述主要步骤和关键代码片段。\n\n1. **初始化Camera2 API**：打开相机，设置预览大小，创建CaptureSession等。\n2. **设置TextureView显示预览**。\n3. **处理拍照和保存**：在点击按钮时，捕获图像并保存到存储。\n\n你需要创建多个类来处理Camera2的不同部分，如CameraStateCallback、CaptureRequest等。\n\n### 示例代码片段（MainActivity部分）\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private TextureView textureView;\n    private CameraDevice cameraDevice;\n    private CaptureRequest.Builder previewRequestBuilder;\n    // 其他变量...\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        textureView = findViewById(R.id.textureView);\n        // 初始化相机，设置TextureView显示预览等...\n    }\n\n    // 拍照按钮点击事件\n    public void onCaptureButtonClick(View view) {\n        // 拍照逻辑...\n    }\n\n    // 相机打开，关闭等状态的回调\n    private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() {\n        @Override\n        public void onOpened(@NonNull CameraDevice camera) {\n            // 相机成功打开\n            cameraDevice = camera;\n        }\n\n        @Override\n        public void onDisconnected(@NonNull CameraDevice camera) {\n            // 相机被断开\n            cameraDevice.close();\n        }\n\n        @Override\n        public void onError(@NonNull CameraDevice camera, int error) {\n            // 相机发生错误\n            cameraDevice.close();\n            cameraDevice = null;\n        }\n    };\n\n    // 其他方法...\n}\n```\n\n### 步骤 5: 运行时权限请求\n\n由于Android 6.0（API 级别 23）及以上版本需要在运行时请求权限，你需要检查并在必要时请求权限。\n\n### 总结\n\n这里只提供了一个基本的框架和思路。Camera2 API 涉及很多复杂的步骤和概念，如处理相机状态、创建和管理CaptureRequests、SurfaceTexture等。为了完整实现功能，你需要深入研究Camera2 API的文档和示例代码。\n\n\n","tags":["Android","APP"]},{"title":"STL速学","url":"/2024/11/10/CPP/STL/","content":"# 1.容器\n\n## 1.1 array\n\n**array保存在栈中**\n\n```c++\nstd::array<int, 4> arr= {1,2,3,4};\n\nint len = 4;\nstd::array<int, len> arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式\n\nconst int len = 4;\nstd::array<int, len> arr = {1,2,3,4}; // 正确写法\n```\n\n## 1.2 vector\n\n不同的编译器实现的扩容方式不一样，vector 在VS2015中以1.5倍扩容，GCC以2倍扩容。\n\n**vector保存在堆中**\n\n```cpp\nvector<vector<int>> v;\n\nv.size();\t\t//返回行数\n\nv[0].size();\t//返回列数\n```\n\n\n\n\n## 1.3 list\n\nlist 是双向循环链表 记住！！！\n\nList的插入、删除或者拼合操作不会造成原有迭代器的失效。\n\nList不能用STL 中的sort函数进行排序，而是要用自身的sort函数。List仅支持随机访问迭代器，而List是双向迭代器。\n\n## 1.4 forward_list\n\n单向链表，标准库容器中唯一不提供size()方法的容器，当不需要双向迭代时，具备比list更高的空间利用率。\n## 1.5 stack\n\n基础示例:\n\n```cpp\n\tstack<int> s;\n\ts.push(10);\n\ts.push(20);\n\ts.push(30);\n\n\twhile (!s.empty())\n\t{\n\t\t//输出栈顶元素\n\t\tcout << \"栈顶元素\" << s.top() << endl;\n\t\t//弹出栈顶元素\n\t\ts.pop();\n\t}\n\tcout << \"栈的大小为:\" << s.size() << endl;\n```\nemplace ://emplace函数可以将一个元素加入栈中，与push的区别在于：emplace可以直接传入Node的构造函数的参数，并将构造的元素加入栈中\n```cpp\n#include <iostream>       \n#include <stack>\nusing namespace std;\n\nstruct Node {\n    int a,b;\n    Node (int x, int y) {\n        a = x; b = y;\n    }\n};\nint main ()\n{\n    stack<Node> mystack;\n    mystack.emplace(1,2);        \n    //mystack.push(1,2);        //编译不通过，要达到上面的效果需要手动构造，例如mystack.push(Node(1,2));\n    Node p = mystack.top();\n    cout << p.a << \" \" << p.b << endl;\n    \n    stack<Node> my2;\n    my2.swap(mystack);            //swap函数可以交换两个栈的元素\n    cout << mystack.size() << \" \" << my2.size() << endl;\n  return 0;\n}\n```\n# 2.智能指针\n\n对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator->”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。\n\n访问智能指针包含的裸指针则可以用 get() 函数。由于智能指针是一个对象，所以if (my_smart_object)永远为真，要判断智能指针的裸指针是否为空，需要这样判断：if (my_smart_object.get())。\n\n## 2.1\tauto_ptr\n\n**采用管理权转移，拷贝时会导致对象悬空，设计有缺陷，不建议使用**\n\n```c++\n//auto_ptr<int> p;//初始化为NULL\n//  错误写法  auto_ptr<int> p = new int(123);\nauto_ptr<int> p(new int(123));\ncout << *p;\n```\n\n```c++\n    auto_ptr<int> p(new int(123));\n    auto_ptr<int> p1(p);//将p的使用权转给p1,p1已经指向nullptr无法正常访问\n//    cout << *p << endl;\n    cout << *p1 << endl;\n```\n\n## 2.2\tunique_ptr\n\n**特点：防拷贝，简单粗暴，建议使用**\n\n**缺点：不能拷贝，可以转让**\n\n```c++\nunique_ptr<int> p(new int(123));\n*p = 7;\ncout << *p<< endl;\n```\n\n```c++\nunique_ptr<string> upt1=std::move(upt);  //控制权限转移\nif(upt.get()!=nullptr)\t\t\t\t\t//判空操作更安全\n{\n\t//do something\n}\n```\n\n```c++\nunique_ptr<int> p1;          //创建空的智能指针\np1.reset(new int(3));    //绑定动态对象\nunique_ptr<int> p2(new int(4)) ;        //创建时绑定动态对象\ncout << *p1 <<endl;\ncout << *p2 <<endl;\n//所有权发生变化\nint *p = p1.release();      //释放所有权\n\nunique_ptr<string> p_s1(new string(\"abc\"));\n//    unique_ptr<string> p_s2 = std::move(p_s1);\n    cout << *p_s1 <<endl;\n//    cout << p_s2 <<endl;\n```\n## 2.3\tshared_ptr\n\n shared_ptr的原理：通过引用计数的方式来实现多个shared_ptr对象之间共享资源。\n\n1. shared_ptr在其内部，给每个资源都维护了一份计数，用来记录该份资源被几个对象共享。\n2. 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。\n3. 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源。\n4. 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。\n\n```c++\nshared_ptr<int> p1(new int(123));\nshared_ptr<int> p2(p1);\nshared_ptr<int> p3(p2);\ncout << *p1 << \" \" << p1.use_count() << endl;\ncout << *p2 << \" \" << p2.use_count() << endl;\n```\n循环引用\n\n循坏引用分析：\n\n1. node1和node2两个智能指针对象指向两个结点，引用计数变成1，我们不需要手动delete。\n2. node1和_next指向node2，node2的_prev还指向下一个结点。但是_prev还指向上一个节点。\n3. node1和node2析构，引用计数减一，但是_next还指向下一个节点。但是_prev还指向上一个节点。\n4. 也就是说_next析构了，node2就释放了。\n5. 也就是说_prev析构了，node1就释放了。\n6. 但是_next属于node成员，node1释放了，_next才会析构，而node1由_prev管理，_prev属于node2成员，所以这就叫循环引用，谁也不会释放。\n\n```c++\n#include<memory>\n#include <iostream>\n\nusing namespace std;\n\nstruct ListNode {\n    int _data;\n    shared_ptr<ListNode> _prev;\n    shared_ptr<ListNode> _next;\n\n    ~ListNode() {\n        cout << \"~ListNode()\" << endl;\n    }\n\n};\n\nint main() {\n    shared_ptr<ListNode> node1(new ListNode);\n    shared_ptr<ListNode> node2(new ListNode);\n    cout << node1.use_count() << endl;\n    cout << node2.use_count() << endl;\n\n    node1->_next = node2;\n    node2->_prev = node1;\n    cout << node1.use_count() << endl;\n    cout << node2.use_count() << endl;\n    return 0;\n}\n```\n\n**解决方案：在引用计数的场景下，把节点中的_prev和_next改成weak_ptr就可以了**\n\n**原理：node1->_next = node2;和node2->_prev = node1;时weak_ptr的_next和_prev不会增加 node1和node2的引用计数。** \n\n## 2.4\tweak_ptr\n\nweak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造而来。weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-> ，因此取名为 weak，表明其是功能较弱的智能指针。它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。\n\n```c++\n#include<memory>\n#include <iostream>\n\nusing namespace std;\n\nstruct ListNode {\n    int _data;\n    weak_ptr<ListNode> _prev;\n    weak_ptr<ListNode> _next;\n\n~ListNode() {\n    cout << \"~ListNode()\" << endl;\n}\n\n};\n\nint main() {\n    shared_ptr<ListNode> node1(new ListNode);\n    shared_ptr<ListNode> node2(new ListNode);\n    cout << node1.use_count() << endl;\n    cout << node2.use_count() << endl;\n\n    node1->_next = node2;\n    node2->_prev = node1;\n    cout << node1.use_count() << endl;\n    cout << node2.use_count() << endl;\n    return 0;\n}\n```\n\n下面给出几个使用指南。\n（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：\n（a）的元素和最小的元素；\n（b）两个对象都包含指向第三个对象的指针；\n（c）STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr\n\n# 3.类型推导\n\n## 3.1 auto\n\n编程时候常常需要把表达式的值付给变量,需要在声明变量的时候清楚的知道变量是什么类型。然而做到这一点并非那么容易(特别是模板中)，有时候根本做不到。为了解决这个问题，C++11新标准就引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同。auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。\n\n```c++\nint i = 3;\nauto a = i,&b = i,*c = &i;//正确: a初始化为i的副本,b初始化为i的引用,c为i的指针.\nauto sz = 0, pi = 3.14;//错误,两个变量的类型不一样。\n```\n\n## 3.2 decltype\n\n`decltype` 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。\n\n```c++\nauto i = 1;\ndecltype(i) i2 = i;\ncout  << i << \"\\t\";\ncout << i2;\n```\n# 4.强制类型转换\nC++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast\n\n## 4.1 const_cast\n\n**const_cast<类型说明符> (变量或表达式)**\n\n 用于将const变量转换为非const类型\n\nconst_cast用于强制去掉const这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。\n\n## 4.2  static_cast\n\nstatic_cast<类型说明符> (变量或表达式)\n\n用于各种隐私转换，比如非const转const， void*转指针等， static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知。\n## 4.3 dynamic_cast\n\ndynamic_cast<类型说明符> (变量或表达式)\n\n用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向上转换：指的是子类向基类转换。 向下转换：指的是基类向子类转换。  他通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。    \n## 4.4 reinterpret_cast\n\nreinterpret_cast<类型说明符> (变量或表达式)\n\n几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用。\n\n改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。\n\n## 4.5 为什么不用C的强制转换？\nC的强制转换表面上看起来功能强大什么都能转换，但转化不够明确，不能进行错误检查，容易出错。\n\n# 委托构造函数\n\n```c++\nclass Base {\npublic:\n    int value1;\n    int value2;\n    Base() {\n        value1 = 1;\n    }\n    Base(int value) : Base() {  // 委托 Base() 构造函数\n        value2 = 2;\n    }\n};\n```\n\n\n\n# 继承构造\n\n在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。 \n 假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：\n\n```c++\nstruct A\n{\n  A(int i) {}\n  A(double d,int i){}\n  A(float f,int i,const char* c){}\n  //...等等系列的构造函数版本\n}；\nstruct B:A\n{\n  B(int i):A(i){}\n  B(double d,int i):A(d,i){}\n  B(folat f,int i,const char* c):A(f,i,e){}\n  //......等等好多个和基类构造函数对应的构造函数\n}；\n```\n\nC++11的继承构造：\n\n```c++\nstruct A\n{\n  A(int i) {}\n  A(double d,int i){}\n  A(float f,int i,const char* c){}\n  //...等等系列的构造函数版本\n}；\nstruct B:A\n{\n  using A::A;\n  //关于基类各构造函数的继承一句话搞定\n  //......\n}；\n```\n\n# lambda\n\n```\nint a = 0;\nauto f = [=] { return a; };\n\na+=1;\n\ncout << f() << endl;       //输出0\n\nint a = 0;\nauto f = [&a] { return a; };\n\na+=1;\n\ncout << f() <<endl;       //输出1\n```\n\n```c++\nint singleNumber(vector<int>& nums) {\n    if(nums.empty()) return 0;\n    int len = nums.size();\n    int temp = 0;\n    for(int i = 0 ; i < len ; i++){\n        temp ^=nums[i];\n    }\n    return temp;\n}\n```\n","tags":["cpp"]}]