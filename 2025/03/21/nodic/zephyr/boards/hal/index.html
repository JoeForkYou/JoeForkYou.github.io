<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Zephyr 硬件抽象层 | JoeNero的博客</title><meta name="author" content="JoeNero"><meta name="copyright" content="JoeNero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Zephyr 硬件抽象层版本信息 版本：V1.0 更新时间：2025年03月21日 00:30  本文档详细介绍了 Zephyr RTOS 的硬件抽象层 (HAL) 架构、驱动框架、中断管理和时钟系统等内容。 HAL 架构Zephyr 的硬件抽象层采用分层设计，从底层硬件到应用程序分为以下几层： 1. 架构层 (Architecture Layer)架构层提供了与 CPU 架构相关的抽象，如上下文">
<meta property="og:type" content="article">
<meta property="og:title" content="Zephyr 硬件抽象层">
<meta property="og:url" content="https://joeforkyou.github.io/2025/03/21/nodic/zephyr/boards/hal/index.html">
<meta property="og:site_name" content="JoeNero的博客">
<meta property="og:description" content="Zephyr 硬件抽象层版本信息 版本：V1.0 更新时间：2025年03月21日 00:30  本文档详细介绍了 Zephyr RTOS 的硬件抽象层 (HAL) 架构、驱动框架、中断管理和时钟系统等内容。 HAL 架构Zephyr 的硬件抽象层采用分层设计，从底层硬件到应用程序分为以下几层： 1. 架构层 (Architecture Layer)架构层提供了与 CPU 架构相关的抽象，如上下文">
<meta property="og:locale">
<meta property="og:image" content="https://joeforkyou.github.io/img/%E7%BE%8E%E5%A5%B3.jpg">
<meta property="article:published_time" content="2025-03-20T16:30:55.000Z">
<meta property="article:modified_time" content="2025-03-21T13:19:48.690Z">
<meta property="article:author" content="JoeNero">
<meta property="article:tag" content="zephyr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://joeforkyou.github.io/img/%E7%BE%8E%E5%A5%B3.jpg"><link rel="shortcut icon" href="/img/1.jpg"><link rel="canonical" href="https://joeforkyou.github.io/2025/03/21/nodic/zephyr/boards/hal/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"IZ845G3SQG","apiKey":"381e98702820650923216a5f47f18d71","indexName":"movie","hitsPerPage":6,"languages":{"input_placeholder":"Search for Posts","hits_empty":"No results found for: ${query}","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Zephyr 硬件抽象层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="JoeNero的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E7%BE%8E%E5%A5%B3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">126</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">JoeNero的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Zephyr 硬件抽象层</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Zephyr 硬件抽象层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-20T16:30:55.000Z" title="Created 2025-03-21 00:30:55">2025-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-21T13:19:48.690Z" title="Updated 2025-03-21 21:19:48">2025-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/zephyr/">zephyr</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Zephyr-硬件抽象层"><a href="#Zephyr-硬件抽象层" class="headerlink" title="Zephyr 硬件抽象层"></a>Zephyr 硬件抽象层</h1><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul>
<li>版本：V1.0</li>
<li>更新时间：2025年03月21日 00:30</li>
</ul>
<p>本文档详细介绍了 Zephyr RTOS 的硬件抽象层 (HAL) 架构、驱动框架、中断管理和时钟系统等内容。</p>
<h2 id="HAL-架构"><a href="#HAL-架构" class="headerlink" title="HAL 架构"></a>HAL 架构</h2><p>Zephyr 的硬件抽象层采用分层设计，从底层硬件到应用程序分为以下几层：</p>
<h3 id="1-架构层-Architecture-Layer"><a href="#1-架构层-Architecture-Layer" class="headerlink" title="1. 架构层 (Architecture Layer)"></a>1. 架构层 (Architecture Layer)</h3><p>架构层提供了与 CPU 架构相关的抽象，如上下文切换、中断处理、内存管理单元等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 架构层代码示例 (arch/arm/core/aarch32/cpu_idle.S)</span></span><br><span class="line">_ASM_FILE_PROLOGUE</span><br><span class="line"></span><br><span class="line"><span class="title function_">GTEXT</span><span class="params">(arch_cpu_idle)</span></span><br><span class="line"><span class="title function_">GTEXT</span><span class="params">(arch_cpu_atomic_idle)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">SECTION_FUNC</span><span class="params">(TEXT, arch_cpu_idle)</span></span><br><span class="line">    wfi</span><br><span class="line">    bx lr</span><br><span class="line"></span><br><span class="line"><span class="title function_">SECTION_FUNC</span><span class="params">(TEXT, arch_cpu_atomic_idle)</span></span><br><span class="line">    <span class="comment">// 禁用中断</span></span><br><span class="line">    cpsid i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待中断</span></span><br><span class="line">    wfi</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用中断</span></span><br><span class="line">    cpsie i</span><br><span class="line"></span><br><span class="line">    bx lr</span><br></pre></td></tr></table></figure>

<h3 id="2-SoC-层-System-on-Chip-Layer"><a href="#2-SoC-层-System-on-Chip-Layer" class="headerlink" title="2. SoC 层 (System on Chip Layer)"></a>2. SoC 层 (System on Chip Layer)</h3><p>SoC 层处理特定芯片系列的初始化和配置，包括时钟设置、电源管理和外设配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SoC 层代码示例 (soc/arm/nordic_nrf/nrf52/soc.c)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">z_arm_platform_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SystemInit();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NRF_ENABLE_ICACHE</span></span><br><span class="line">    <span class="comment">/* 启用指令缓存 */</span></span><br><span class="line">    NRF_NVMC-&gt;ICACHECNF = NVMC_ICACHECNF_CACHEEN_Enabled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SOC_DCDC_NRF52X)</span></span><br><span class="line">    <span class="comment">/* 启用 DC/DC 转换器 */</span></span><br><span class="line">    NRF_POWER-&gt;DCDCEN = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-板级层-Board-Layer"><a href="#3-板级层-Board-Layer" class="headerlink" title="3. 板级层 (Board Layer)"></a>3. 板级层 (Board Layer)</h3><p>板级层处理特定开发板的配置，包括引脚复用、外部组件初始化等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 板级层代码示例 (boards/arm/nrf52840dk_nrf52840/board.c)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_nrf52840dk_nrf52840_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = gpio_pin_configure(DEVICE_DT_GET(DT_NODELABEL(gpio0)),</span><br><span class="line">                           <span class="number">13</span>, GPIO_OUTPUT_ACTIVE);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYS_INIT(board_nrf52840dk_nrf52840_init, PRE_KERNEL_1,</span><br><span class="line">         CONFIG_BOARD_INIT_PRIORITY);</span><br></pre></td></tr></table></figure>

<h3 id="4-驱动层-Driver-Layer"><a href="#4-驱动层-Driver-Layer" class="headerlink" title="4. 驱动层 (Driver Layer)"></a>4. 驱动层 (Driver Layer)</h3><p>驱动层提供了与硬件外设交互的统一接口，如 GPIO、UART、SPI 等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动层代码示例 (drivers/gpio/gpio_nrfx.c)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_nrfx_port_get_raw</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">uint32_t</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    NRF_GPIO_Type *gpio = get_port_cfg(port)-&gt;gpio_base_addr;</span><br><span class="line"></span><br><span class="line">    *value = nrf_gpio_port_in_read(gpio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_nrfx_port_set_masked_raw</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *port,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> mask, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    NRF_GPIO_Type *gpio = get_port_cfg(port)-&gt;gpio_base_addr;</span><br><span class="line">    <span class="type">uint32_t</span> out = nrf_gpio_port_out_read(gpio);</span><br><span class="line"></span><br><span class="line">    nrf_gpio_port_out_write(gpio, (out &amp; ~mask) | (value &amp; mask));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-应用层-Application-Layer"><a href="#5-应用层-Application-Layer" class="headerlink" title="5. 应用层 (Application Layer)"></a>5. 应用层 (Application Layer)</h3><p>应用层使用驱动层提供的 API 实现具体功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用层代码示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">gpio_dev</span>;</span></span><br><span class="line">    </span><br><span class="line">    gpio_dev = DEVICE_DT_GET(DT_NODELABEL(gpio0));</span><br><span class="line">    <span class="keyword">if</span> (!device_is_ready(gpio_dev)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    gpio_pin_configure(gpio_dev, <span class="number">13</span>, GPIO_OUTPUT_ACTIVE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        gpio_pin_toggle(gpio_dev, <span class="number">13</span>);</span><br><span class="line">        k_sleep(K_MSEC(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><p>Zephyr 的驱动框架基于设备模型，提供了统一的接口和生命周期管理。</p>
<h3 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h3><p>设备模型的核心是 <code>struct device</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *config;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *api;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_DEVICE</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pm_device</span> *<span class="title">pm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>name</strong>: 设备名称</li>
<li><strong>config</strong>: 设备的静态配置信息</li>
<li><strong>api</strong>: 设备操作函数指针</li>
<li><strong>data</strong>: 设备的运行时数据</li>
<li><strong>pm</strong>: 电源管理相关信息</li>
</ul>
<h3 id="驱动注册"><a href="#驱动注册" class="headerlink" title="驱动注册"></a>驱动注册</h3><p>使用 <code>DEVICE_DEFINE</code> 宏注册设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE_DEFINE(my_dev,                  <span class="comment">// 设备名称</span></span><br><span class="line">              <span class="string">&quot;MY_DEVICE&quot;</span>,             <span class="comment">// 友好名称</span></span><br><span class="line">              my_device_init,          <span class="comment">// 初始化函数</span></span><br><span class="line">              my_device_pm_control,    <span class="comment">// 电源管理函数</span></span><br><span class="line">              &amp;my_device_data,         <span class="comment">// 设备数据</span></span><br><span class="line">              &amp;my_device_config,       <span class="comment">// 设备配置</span></span><br><span class="line">              POST_KERNEL,             <span class="comment">// 初始化级别</span></span><br><span class="line">              CONFIG_MY_DEVICE_INIT_PRIORITY, <span class="comment">// 初始化优先级</span></span><br><span class="line">              &amp;my_device_api);         <span class="comment">// 设备 API</span></span><br></pre></td></tr></table></figure>

<h3 id="设备初始化"><a href="#设备初始化" class="headerlink" title="设备初始化"></a>设备初始化</h3><p>设备初始化过程按照初始化级别和优先级顺序进行：</p>
<ol>
<li><code>PRE_KERNEL_1</code>: 基础硬件初始化</li>
<li><code>PRE_KERNEL_2</code>: 设备和驱动初始化</li>
<li><code>POST_KERNEL</code>: 需要内核服务的设备</li>
<li><code>APPLICATION</code>: 应用级设备</li>
<li><code>SMP</code>: 多处理器相关设备</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_device_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取配置和数据</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_device_config</span> *<span class="title">config</span> =</span> dev-&gt;config;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">data</span> =</span> dev-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化硬件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="驱动-API"><a href="#驱动-API" class="headerlink" title="驱动 API"></a>驱动 API</h3><p>每种类型的驱动程序定义了一组标准 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GPIO 驱动 API 示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_driver_api</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*pin_configure)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_pin_t</span> pin,</span><br><span class="line">                        <span class="type">gpio_flags_t</span> flags);</span><br><span class="line">    <span class="type">int</span> (*port_get_raw)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_port_value_t</span> *value);</span><br><span class="line">    <span class="type">int</span> (*port_set_masked_raw)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_port_pins_t</span> mask,</span><br><span class="line">                              <span class="type">gpio_port_value_t</span> value);</span><br><span class="line">    <span class="type">int</span> (*port_set_bits_raw)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_port_pins_t</span> pins);</span><br><span class="line">    <span class="type">int</span> (*port_clear_bits_raw)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_port_pins_t</span> pins);</span><br><span class="line">    <span class="type">int</span> (*port_toggle_bits)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_port_pins_t</span> pins);</span><br><span class="line">    <span class="type">int</span> (*pin_interrupt_configure)(<span class="type">const</span> <span class="keyword">struct</span> device *port, <span class="type">gpio_pin_t</span> pin,</span><br><span class="line">                                 <span class="keyword">enum</span> gpio_int_mode mode,</span><br><span class="line">                                 <span class="keyword">enum</span> gpio_int_trig trig);</span><br><span class="line">    <span class="type">int</span> (*manage_callback)(<span class="type">const</span> <span class="keyword">struct</span> device *port,</span><br><span class="line">                         <span class="keyword">struct</span> gpio_callback *callback, <span class="type">bool</span> <span class="built_in">set</span>);</span><br><span class="line">    <span class="type">uint32_t</span> (*get_pending_int)(<span class="type">const</span> <span class="keyword">struct</span> device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="设备使用"><a href="#设备使用" class="headerlink" title="设备使用"></a>设备使用</h3><p>应用程序通过 <code>DEVICE_DT_GET</code> 或 <code>device_get_binding</code> 获取设备实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用设备树获取设备</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(uart0));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查设备是否就绪</span></span><br><span class="line"><span class="keyword">if</span> (!device_is_ready(dev)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用设备 API</span></span><br><span class="line">uart_config(dev, &amp;uart_cfg);</span><br></pre></td></tr></table></figure>

<h2 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h2><p>Zephyr 提供了一套统一的中断管理接口，抽象了不同架构的中断控制器差异。</p>
<h3 id="中断配置"><a href="#中断配置" class="headerlink" title="中断配置"></a>中断配置</h3><p>使用 <code>IRQ_CONNECT</code> 宏连接中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IRQ_CONNECT(IRQ_NUM,           <span class="comment">// 中断号</span></span><br><span class="line">            IRQ_PRIO,          <span class="comment">// 中断优先级</span></span><br><span class="line">            irq_handler,       <span class="comment">// 中断处理函数</span></span><br><span class="line">            <span class="literal">NULL</span>,              <span class="comment">// 传递给处理函数的参数</span></span><br><span class="line">            IRQ_FLAGS);        <span class="comment">// 中断标志</span></span><br></pre></td></tr></table></figure>

<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>中断处理函数示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_handler</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">data</span> =</span> dev-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理中断</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除中断标志</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h3><p>控制中断的启用和禁用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用特定中断</span></span><br><span class="line">irq_enable(IRQ_NUM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用特定中断</span></span><br><span class="line">irq_disable(IRQ_NUM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用所有中断</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> key = irq_lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复中断状态</span></span><br><span class="line">irq_unlock(key);</span><br></pre></td></tr></table></figure>

<h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>设置中断优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置中断优先级</span></span><br><span class="line">irq_priority_set(IRQ_NUM, IRQ_PRIO);</span><br></pre></td></tr></table></figure>

<h2 id="时钟系统"><a href="#时钟系统" class="headerlink" title="时钟系统"></a>时钟系统</h2><p>Zephyr 的时钟系统提供了计时、延时和定时器功能。</p>
<h3 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h3><p>系统时钟是内核的基础计时单元：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取系统滴答计数</span></span><br><span class="line"><span class="type">uint32_t</span> ticks = k_cycle_get_32();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取系统启动后的时间（毫秒）</span></span><br><span class="line"><span class="type">int64_t</span> uptime = k_uptime_get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取系统启动后的时间（微秒）</span></span><br><span class="line"><span class="type">int64_t</span> uptime_us = k_uptime_get_32();</span><br></pre></td></tr></table></figure>

<h3 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h3><p>提供不同精度的延时功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延时指定的滴答数</span></span><br><span class="line">k_sleep(K_TICKS(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时指定的毫秒数</span></span><br><span class="line">k_msleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时指定的微秒数</span></span><br><span class="line">k_usleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>内核定时器用于延迟执行或周期性执行任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义定时器</span></span><br><span class="line">K_TIMER_DEFINE(my_timer, timer_expiry_function, timer_stop_function);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器（延迟 100ms 后到期，之后每 1000ms 触发一次）</span></span><br><span class="line">k_timer_start(&amp;my_timer, K_MSEC(<span class="number">100</span>), K_MSEC(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line">k_timer_stop(&amp;my_timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_expiry_function</span><span class="params">(<span class="keyword">struct</span> k_timer *timer_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定时器到期时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_stop_function</span><span class="params">(<span class="keyword">struct</span> k_timer *timer_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定时器停止时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬件定时器"><a href="#硬件定时器" class="headerlink" title="硬件定时器"></a>硬件定时器</h3><p>硬件定时器通过计数器驱动实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/counter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">counter_dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(timer0));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">counter_alarm_cfg</span> <span class="title">alarm_cfg</span> =</span> &#123;</span><br><span class="line">    .callback = alarm_callback,</span><br><span class="line">    .flags = <span class="number">0</span>,</span><br><span class="line">    .ticks = counter_us_to_ticks(counter_dev, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">counter_start(counter_dev);</span><br><span class="line">counter_set_alarm(counter_dev, <span class="number">0</span>, &amp;alarm_cfg);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alarm_callback</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev, <span class="type">uint8_t</span> chan_id,</span></span><br><span class="line"><span class="params">                         <span class="type">uint32_t</span> ticks, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 闹钟回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><p>Zephyr 的电源管理系统允许设备进入低功耗状态。</p>
<h3 id="设备电源管理"><a href="#设备电源管理" class="headerlink" title="设备电源管理"></a>设备电源管理</h3><p>设备可以实现电源管理回调：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_device_pm_control</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">                              <span class="keyword">enum</span> pm_device_action action)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> PM_DEVICE_ACTION_RESUME:</span><br><span class="line">        <span class="comment">// 唤醒设备</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PM_DEVICE_ACTION_SUSPEND:</span><br><span class="line">        <span class="comment">// 挂起设备</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义设备的电源管理支持</span></span><br><span class="line">PM_DEVICE_DEFINE(my_dev, my_device_pm_control);</span><br></pre></td></tr></table></figure>

<h3 id="系统电源管理"><a href="#系统电源管理" class="headerlink" title="系统电源管理"></a>系统电源管理</h3><p>系统级电源管理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置电源状态约束</span></span><br><span class="line">pm_constraint_set(PM_STATE_SUSPEND_TO_RAM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放电源状态约束</span></span><br><span class="line">pm_constraint_release(PM_STATE_SUSPEND_TO_RAM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置电源状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pm_state_info</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">    .state = PM_STATE_SUSPEND_TO_RAM,</span><br><span class="line">    .min_residency_us = <span class="number">1000</span>,</span><br><span class="line">    .exit_latency_us = <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line">pm_power_state_set(&amp;info);</span><br></pre></td></tr></table></figure>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li><p><strong>使用抽象接口</strong></p>
<ul>
<li>使用 Zephyr 提供的抽象 API，而不是直接访问硬件</li>
<li>这样可以提高代码的可移植性</li>
</ul>
</li>
<li><p><strong>正确处理错误</strong></p>
<ul>
<li>检查所有 API 调用的返回值</li>
<li>实现适当的错误恢复机制</li>
</ul>
</li>
<li><p><strong>遵循设备模型</strong></p>
<ul>
<li>使用标准的设备注册和初始化流程</li>
<li>实现所有必要的驱动 API 函数</li>
</ul>
</li>
<li><p><strong>中断处理</strong></p>
<ul>
<li>保持中断处理函数简短</li>
<li>使用工作队列处理耗时操作</li>
</ul>
</li>
<li><p><strong>电源管理</strong></p>
<ul>
<li>实现设备电源管理回调</li>
<li>在不需要时禁用外设</li>
</ul>
</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p><strong>设备初始化失败</strong></p>
<ul>
<li>检查依赖项是否已初始化</li>
<li>验证设备树配置是否正确</li>
<li>确认硬件连接是否正常</li>
</ul>
</li>
<li><p><strong>中断问题</strong></p>
<ul>
<li>检查中断优先级设置</li>
<li>验证中断向量表配置</li>
<li>确认中断处理函数注册是否正确</li>
</ul>
</li>
<li><p><strong>定时器不准确</strong></p>
<ul>
<li>检查系统时钟配置</li>
<li>验证定时器参数</li>
<li>考虑使用硬件定时器</li>
</ul>
</li>
<li><p><strong>电源管理问题</strong></p>
<ul>
<li>检查电源管理回调实现</li>
<li>验证设备状态转换逻辑</li>
<li>确认唤醒源配置</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Zephyr 的硬件抽象层提供了一套统一的接口，屏蔽了底层硬件差异，使应用程序可以在不同的硬件平台上运行。通过分层设计和标准化的驱动框架，Zephyr 实现了高度的可移植性和模块化。了解这些概念对于开发 Zephyr 应用程序和驱动程序至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://joeforkyou.github.io">JoeNero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://joeforkyou.github.io/2025/03/21/nodic/zephyr/boards/hal/">https://joeforkyou.github.io/2025/03/21/nodic/zephyr/boards/hal/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/zephyr/">zephyr</a></div><div class="post-share"><div class="social-share" data-image="/img/%E7%BE%8E%E5%A5%B3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/21/nodic/zephyr/boards/porting/" title="添加新板子到 Zephyr"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">添加新板子到 Zephyr</div></div><div class="info-2"><div class="info-item-1">添加新板子到 Zephyr版本信息 版本：V1.0 更新时间：2025年03月21日 00:45  本文档详细介绍了如何将新的开发板添加到 Zephyr RTOS 中，包括移植流程、设备树配置、驱动适配和调试方法。 移植流程概述 准备工作  收集硬件文档 确定 SoC 和 CPU 架构 检查现有的类似板子支持   创建板级支持包 (BSP)  添加新的板子目录 创建基本配置文件   配置设备树  定义板子特定的设备树 配置引脚复用和外设   适配驱动程序  确认所需驱动的可用性 修改或创建新的驱动程序   实现板级初始化  配置时钟系统 设置中断控制器 初始化关键外设   配置构建系统  更新 CMakeLists.txt 设置 Kconfig 选项   测试和调试  编译基本示例 使用调试工具验证功能   文档和示例  编写板级文档 创建板子特定的示例代码    详细步骤1. 准备工作 收集硬件文档  处理器数据手册 开发板原理图 引脚分配表   确定 SoC 和 CPU 架构 12345# 检查 Zephyr 支持的架构ls zephyr/arch# 检查 SoC 支持ls...</div></div></div></a><a class="pagination-related" href="/2025/03/21/nodic/zephyr/boards/README/" title="Zephyr 硬件支持"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Zephyr 硬件支持</div></div><div class="info-2"><div class="info-item-1">Zephyr 硬件支持版本信息 版本：V1.0 更新时间：2025年03月21日 00:15  本章节详细介绍了 Zephyr RTOS 支持的硬件平台、如何添加新的开发板支持以及硬件抽象层的实现。 目录 支持的开发板  添加新板子  硬件抽象层  开发板选择指南   添加新板子  移植流程 设备树配置 驱动适配 调试方法   硬件抽象层  HAL 架构 驱动框架 中断管理 时钟系统    硬件支持概述Zephyr RTOS 支持多种硬件架构和平台：  处理器架构  ARM Cortex-M ARM Cortex-R ARM Cortex-A x86 RISC-V ARC Xtensa   主要厂商支持  Nordic Semiconductor STMicroelectronics NXP Microchip Espressif Intel TI   硬件功能支持  处理器核心 内存管理 中断控制器 定时器 GPIO 串口 I2C&#x2F;SPI ADC&#x2F;DAC PWM 网络接口    开发板支持层次Zephyr 的硬件支持分为以下层次：  SoC...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/20/zephyer/zephyer1/" title="【Zephyr】【一】Zephyr RTOS 示例代码集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="info-item-2">【Zephyr】【一】Zephyr RTOS 示例代码集</div></div><div class="info-2"><div class="info-item-1">Zephyr RTOS 示例代码集1. 基础示例1.0 基础配置每个示例都需要一个 prj.conf 文件来配置项目。以下是各个示例所需的配置： 基础示例 prj.conf1234567891011# 控制台输出CONFIG_PRINTK=yCONFIG_SERIAL=yCONFIG_UART_CONSOLE=y# 日志系统CONFIG_LOG=yCONFIG_LOG_DEFAULT_LEVEL=3# 内核配置CONFIG_KERNEL_BIN_NAME=&quot;app&quot;  线程示例 prj.conf123456789# 基础配置CONFIG_PRINTK=yCONFIG_SERIAL=yCONFIG_UART_CONSOLE=y# 线程配置CONFIG_THREAD_NAME=yCONFIG_THREAD_MONITOR=yCONFIG_THREAD_STACK_INFO=y  1.1 Hello...</div></div></div></a><a class="pagination-related" href="/2025/03/20/zephyer/zephyr2/" title="【Zephyr】【二】Zephyr RTOS 系统架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="info-item-2">【Zephyr】【二】Zephyr RTOS 系统架构</div></div><div class="info-2"><div class="info-item-1"> mermaid.initialize({startOnLoad:true});  Zephyr RTOS 系统架构整体架构 graph TB     subgraph "应用层"         App1[应用1]         App2[应用2]         App3[应用3]     end     subgraph "系统服务层"         FS[文件系统]         Net[网络协议栈]         Shell[命令行界面]     end     subgraph "内核层"         Sched[调度器]         Mem[内存管理]         IPC[进程间通信]         Time[时间管理]     end     subgraph "硬件抽象层"         GPIO[GPIO驱动]         UART[串口驱动]         SPI[SPI驱动]         I2C[I2C驱动]     end     App1 & App2 & App3 --> FS & Net & Shell    ...</div></div></div></a><a class="pagination-related" href="/2023/12/21/nodic/zephyr/architecture/devicetree/" title="Zephyr 设备树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="info-item-2">Zephyr 设备树</div></div><div class="info-2"><div class="info-item-1">Zephyr 设备树版本信息 版本：V1.0 更新时间：2025年03月20日 23:15  设备树（Device Tree）是 Zephyr RTOS 用于描述硬件配置的机制。它提供了一种统一的方式来描述系统硬件，使得硬件配置与软件代码分离，提高了代码的可移植性和可维护性。 设备树概述什么是设备树设备树是一种描述硬件的数据结构，它以树形结构表示硬件设备及其属性。在 Zephyr 中，设备树用于：  描述硬件配置 生成设备驱动的初始化代码 配置中断和引脚复用 定义内存映射  设备树的优势 硬件描述与软件分离：便于硬件配置的修改和维护 跨平台兼容性：同一套代码可以适用于不同的硬件平台 动态配置：支持运行时修改设备配置 标准化：采用行业标准的描述方式，提高可读性和互操作性  设备树语法基本结构设备树文件（.dts）的基本结构如下： 123456789101112131415161718/dts-v1/;/ &#123;    model = &quot;Example Board&quot;;    compatible = &quot;example,board&quot;;  ...</div></div></div></a><a class="pagination-related" href="/2025/03/20/nodic/zephyr/architecture/README/" title="Zephyr RTOS 系统架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="info-item-2">Zephyr RTOS 系统架构</div></div><div class="info-2"><div class="info-item-1">Zephyr RTOS 系统架构版本信息 版本：V1.0 更新时间：2025年03月20日 22:30  Zephyr RTOS 是一个模块化、可扩展的实时操作系统，设计用于资源受限的嵌入式系统。本章节将介绍 Zephyr 的整体系统架构。 目录 内核架构 硬件支持 设备树 驱动模型  架构概览Zephyr 的系统架构主要包括以下几个部分：  微内核  提供基本的线程管理、同步原语和内存管理 支持抢占式多任务和协作式多任务 实现了实时调度器   硬件抽象层 (HAL)  提供统一的硬件访问接口 支持多种 CPU 架构和开发板   设备驱动框架  统一的驱动模型 支持动态加载和卸载驱动   网络协议栈  支持多种网络协议，如 TCP&#x2F;IP、Bluetooth、IEEE 802.15.4   文件系统  支持多种文件系统，如 FAT、LittleFS   电源管理  提供低功耗模式和动态频率调节   安全子系统  提供加密、认证和安全启动等功能    模块化设计Zephyr 采用高度模块化的设计，主要体现在：  内核模块化  核心功能和可选功能分离 通过 Kconfig...</div></div></div></a><a class="pagination-related" href="/2023/12/21/nodic/zephyr/README/" title="Zephyr RTOS 学习指南"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="info-item-2">Zephyr RTOS 学习指南</div></div><div class="info-2"><div class="info-item-1">Zephyr RTOS 学习指南版本信息 版本：V1.0 更新时间：2025年03月20日 22:09  目录结构 快速入门  环境搭建 Hello World 示例 基本概念   系统架构  内核架构 硬件支持 设备树 驱动模型   核心模块  内核模块 线程管理 内存管理 中断处理 定时器   驱动系统 GPIO UART SPI I2C   网络协议栈 文件系统 电源管理   开发指南  应用开发流程 驱动开发指南 调试技巧 测试框架 贡献指南   示例代码  基础示例 网络示例 传感器示例 蓝牙示例   硬件支持  支持的开发板 添加新板子 硬件抽象层   工具链  构建系统 IDE支持 调试工具 安装指南   常见问题  编译问题 运行问题 开发问题    文档说明本文档旨在帮助开发者快速上手 Zephyr RTOS，涵盖了从入门到进阶的完整学习路径。基于 Zephyr v2.9.1...</div></div></div></a><a class="pagination-related" href="/2025/03/20/nodic/zephyr/architecture/hardware/" title="Zephyr 硬件支持"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="info-item-2">Zephyr 硬件支持</div></div><div class="info-2"><div class="info-item-1">Zephyr 硬件支持版本信息 版本：V1.0 更新时间：2025年03月20日 23:00  Zephyr RTOS 提供了广泛的硬件平台支持，包括多种 CPU 架构和开发板。本文档将详细介绍 Zephyr 的硬件支持架构。 支持的硬件架构ARM 架构 Cortex-M 系列  Cortex-M0&#x2F;M0+ Cortex-M3 Cortex-M4 Cortex-M7 Cortex-M23 Cortex-M33   Cortex-R 系列  Cortex-R5 Cortex-R7   Cortex-A 系列  Cortex-A53 Cortex-A72    x86 架构 Intel IA-32  Intel Quark Intel Atom   x86_64  支持现代 x86_64 处理器    RISC-V RV32  RV32I RV32IM RV32IMC RV32IMAC   RV64  RV64I RV64IM RV64IMAC    其他架构 Xtensa  ESP32 ESP32-S2 ESP32-S3   ARC  EM 系列 HS...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E7%BE%8E%E5%A5%B3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">JoeNero</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">126</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JoeForkYou"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/JoeForkYou" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:17549663745@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">wow!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Zephyr-%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">Zephyr 硬件抽象层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">版本信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HAL-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">HAL 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%B6%E6%9E%84%E5%B1%82-Architecture-Layer"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 架构层 (Architecture Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SoC-%E5%B1%82-System-on-Chip-Layer"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. SoC 层 (System on Chip Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9D%BF%E7%BA%A7%E5%B1%82-Board-Layer"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 板级层 (Board Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A9%B1%E5%8A%A8%E5%B1%82-Driver-Layer"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 驱动层 (Driver Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 应用层 (Application Layer)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.</span> <span class="toc-text">驱动框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">设备模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">驱动注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">设备初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8-API"><span class="toc-number">1.3.4.</span> <span class="toc-text">驱动 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">设备使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.1.</span> <span class="toc-text">中断配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">中断处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">中断控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.4.</span> <span class="toc-text">中断优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">时钟系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">系统时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">延时函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">硬件定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">电源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">设备电源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">系统电源管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.7.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/21/nodic/zephyr/core/drivers/" title="drivers">drivers</a><time datetime="2025-03-21T12:49:56.000Z" title="Created 2025-03-21 20:49:56">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/21/nodic/zephyr/core/filesystem/" title="filesystem">filesystem</a><time datetime="2025-03-21T12:49:56.000Z" title="Created 2025-03-21 20:49:56">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/21/nodic/zephyr/core/hardware/" title="hardware">hardware</a><time datetime="2025-03-21T12:49:56.000Z" title="Created 2025-03-21 20:49:56">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/21/nodic/zephyr/core/kernel/" title="kernel">kernel</a><time datetime="2025-03-21T12:49:56.000Z" title="Created 2025-03-21 20:49:56">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/21/nodic/zephyr/core/networking/" title="networking">networking</a><time datetime="2025-03-21T12:49:56.000Z" title="Created 2025-03-21 20:49:56">2025-03-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By JoeNero</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>