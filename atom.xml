<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoeNero的博客</title>
  
  
  <link href="https://joeforkyou.github.io/atom.xml" rel="self"/>
  
  <link href="https://joeforkyou.github.io/"/>
  <updated>2025-03-16T04:54:45.779Z</updated>
  <id>https://joeforkyou.github.io/</id>
  
  <author>
    <name>JoeNero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础功能流程</title>
    <link href="https://joeforkyou.github.io/2025/03/16/nodic/doc/01_%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%86%E6%9E%90/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://joeforkyou.github.io/2025/03/16/nodic/doc/01_%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%86%E6%9E%90/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2025-03-16T04:52:39.000Z</published>
    <updated>2025-03-16T04:54:45.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础功能流程图"><a href="#基础功能流程图" class="headerlink" title="基础功能流程图"></a>基础功能流程图</h1><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li>版本：V1.1</li><li>更新时间：2025年03月16日 10:20</li></ul><h2 id="1-初始化流程"><a href="#1-初始化流程" class="headerlink" title="1. 初始化流程"></a>1. 初始化流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[开始初始化] --&gt; B[获取I2C设备]</span><br><span class="line">    B --&gt; C&#123;设备就绪检查&#125;</span><br><span class="line">    C --&gt;|不就绪| D[返回错误]</span><br><span class="line">    C --&gt;|就绪| E[执行芯片ID验证]</span><br><span class="line">    E --&gt; F&#123;ID验证结果&#125;</span><br><span class="line">    F --&gt;|验证失败| G[返回错误]</span><br><span class="line">    F --&gt;|验证成功| H[加载默认参数配置]</span><br><span class="line">    H --&gt; I[配置AFE寄存器]</span><br><span class="line">    I --&gt; J[配置DSP寄存器]</span><br><span class="line">    J --&gt; K[设置中断和触发条件]</span><br><span class="line">    K --&gt; L[配置工作模式]</span><br><span class="line">    L --&gt; M[初始化成功]</span><br></pre></td></tr></table></figure><h2 id="2-芯片ID验证流程"><a href="#2-芯片ID验证流程" class="headerlink" title="2. 芯片ID验证流程"></a>2. 芯片ID验证流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[开始验证] --&gt; B[读取CHIP_ID寄存器]</span><br><span class="line">    B --&gt; C[获取32位芯片ID]</span><br><span class="line">    C --&gt; D&#123;匹配芯片型号&#125;</span><br><span class="line">    D --&gt;|0xA9630340| E[AW93303FDR]</span><br><span class="line">    D --&gt;|0xA9630520| F[AW93305DNR]</span><br><span class="line">    D --&gt;|0xA9330710| G[AW93307QNR]</span><br><span class="line">    D --&gt;|0xA9331010| H[AW93310QNR]</span><br><span class="line">    D --&gt;|0xA9331210| I[AW93312QNR]</span><br><span class="line">    D --&gt;|其他| J[未知芯片]</span><br><span class="line">    E --&gt; K[验证成功]</span><br><span class="line">    F --&gt; K</span><br><span class="line">    G --&gt; K</span><br><span class="line">    H --&gt; K</span><br><span class="line">    I --&gt; K</span><br><span class="line">    J --&gt; L[验证失败]</span><br></pre></td></tr></table></figure><h2 id="3-I2C通信流程"><a href="#3-I2C通信流程" class="headerlink" title="3. I2C通信流程"></a>3. I2C通信流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[开始I2C操作] --&gt; B&#123;读或写?&#125;</span><br><span class="line">    B --&gt;|读取| C[准备16位寄存器地址]</span><br><span class="line">    B --&gt;|写入| D[准备寄存器地址和数据]</span><br><span class="line">    C --&gt; E[执行I2C写后读]</span><br><span class="line">    D --&gt; F[执行I2C写入]</span><br><span class="line">    E --&gt; G[组合4字节数据]</span><br><span class="line">    F --&gt; H[检查写入结果]</span><br><span class="line">    G --&gt; I[返回32位值]</span><br><span class="line">    H --&gt; J[返回操作状态]</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>初始化流程中，确保每个步骤都有适当的错误处理机制。</li><li>芯片ID验证流程应该考虑到未来可能添加的新芯片型号。</li><li>I2C通信流程应该包含超时处理和重试机制。</li><li>所有流程都应该考虑到并发操作的可能性，确保线程安全。</li></ol><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><a href="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md">错误处理流程</a></li><li><a href="%E5%9B%BA%E4%BB%B6%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.md#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B">参数配置流程</a></li></ul><h2 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h2><ul><li>V1.0 (2025-03-16 08:30): 初始创建</li><li>V1.1 (2025-03-16 10:20): 移动到新的目录结构，添加注意事项和相关文档链接</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础功能流程图&quot;&gt;&lt;a href=&quot;#基础功能流程图&quot; class=&quot;headerlink&quot; title=&quot;基础功能流程图&quot;&gt;&lt;/a&gt;基础功能流程图&lt;/h1&gt;&lt;h2 id=&quot;版本信息&quot;&gt;&lt;a href=&quot;#版本信息&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="传感器" scheme="https://joeforkyou.github.io/categories/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
    
    <category term="传感器" scheme="https://joeforkyou.github.io/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>流程图总览</title>
    <link href="https://joeforkyou.github.io/2025/03/16/nodic/doc/01_%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%86%E6%9E%90/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%80%BB%E8%A7%88/"/>
    <id>https://joeforkyou.github.io/2025/03/16/nodic/doc/01_%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%86%E6%9E%90/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%80%BB%E8%A7%88/</id>
    <published>2025-03-16T04:50:07.000Z</published>
    <updated>2025-03-16T04:54:45.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AW933XX驱动程序流程图总览"><a href="#AW933XX驱动程序流程图总览" class="headerlink" title="AW933XX驱动程序流程图总览"></a>AW933XX驱动程序流程图总览</h1><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li>版本：V1.0</li><li>更新时间：2025年03月16日 10:15</li></ul><h2 id="流程图文档组织"><a href="#流程图文档组织" class="headerlink" title="流程图文档组织"></a>流程图文档组织</h2><p>本文档是AW933XX驱动程序所有流程图的总览索引。为了便于管理和阅读，我们将流程图按功能分类组织在以下文件中：</p><ol><li><p><a href="%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%81%E7%A8%8B.md">基础功能流程</a></p><ul><li>初始化流程</li><li>芯片ID验证流程</li><li>I2C通信流程</li></ul></li><li><p><a href="%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md">事件处理流程</a></p><ul><li>事件处理主流程</li><li>数据采集流程</li><li>中断处理流程</li><li>工作模式切换流程</li></ul></li><li><p><a href="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.md">错误处理流程</a></p><ul><li>错误处理主流程</li><li>自动恢复机制流程</li><li>自检流程</li></ul></li><li><p><a href="%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B.md">调试与优化流程</a></p><ul><li>调试和日志流程</li><li>电源管理流程</li><li>性能优化流程</li></ul></li><li><p><a href="%E5%9B%BA%E4%BB%B6%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.md">固件管理流程</a></p><ul><li>固件更新流程</li><li>参数配置流程</li></ul></li></ol><h2 id="流程图分类说明"><a href="#流程图分类说明" class="headerlink" title="流程图分类说明"></a>流程图分类说明</h2><h3 id="基础功能流程"><a href="#基础功能流程" class="headerlink" title="基础功能流程"></a>基础功能流程</h3><p>包含驱动程序的基本操作流程，是其他所有功能的基础。这些流程描述了驱动程序如何与硬件交互，以及基本的初始化和通信机制。</p><h3 id="事件处理流程"><a href="#事件处理流程" class="headerlink" title="事件处理流程"></a>事件处理流程</h3><p>描述了驱动程序如何处理各种触控事件，包括数据采集、中断处理和不同工作模式之间的切换。这些流程是驱动程序的核心功能部分。</p><h3 id="错误处理流程"><a href="#错误处理流程" class="headerlink" title="错误处理流程"></a>错误处理流程</h3><p>涵盖了驱动程序在遇到各种错误情况时的处理机制，包括错误检测、恢复和自检机制。这些流程保证了驱动程序的稳定性和可靠性。</p><h3 id="调试与优化流程"><a href="#调试与优化流程" class="headerlink" title="调试与优化流程"></a>调试与优化流程</h3><p>包含了用于调试、监控和优化驱动程序性能的各种流程。这些流程帮助开发者诊断问题并提升驱动程序的性能。</p><h3 id="固件管理流程"><a href="#固件管理流程" class="headerlink" title="固件管理流程"></a>固件管理流程</h3><p>描述了固件更新和参数配置的相关流程，确保驱动程序可以正确地更新和配置芯片。</p><h2 id="流程图更新记录"><a href="#流程图更新记录" class="headerlink" title="流程图更新记录"></a>流程图更新记录</h2><h3 id="基础功能流程-1"><a href="#基础功能流程-1" class="headerlink" title="基础功能流程"></a>基础功能流程</h3><ul><li>V1.0 (2025-03-16 08:15): 初始创建</li><li>V1.1 (2025-03-16 10:15): 移动到新的目录结构</li></ul><h3 id="事件处理流程-1"><a href="#事件处理流程-1" class="headerlink" title="事件处理流程"></a>事件处理流程</h3><ul><li>V1.0 (2025-03-16 08:15): 初始创建</li><li>V1.1 (2025-03-16 10:15): 移动到新的目录结构</li></ul><h3 id="错误处理流程-1"><a href="#错误处理流程-1" class="headerlink" title="错误处理流程"></a>错误处理流程</h3><ul><li>V1.0 (2025-03-16 08:15): 初始创建</li><li>V1.1 (2025-03-16 10:15): 移动到新的目录结构</li></ul><h3 id="调试与优化流程-1"><a href="#调试与优化流程-1" class="headerlink" title="调试与优化流程"></a>调试与优化流程</h3><ul><li>V1.0 (2025-03-16 08:15): 初始创建</li><li>V1.1 (2025-03-16 10:15): 移动到新的目录结构</li></ul><h3 id="固件管理流程-1"><a href="#固件管理流程-1" class="headerlink" title="固件管理流程"></a>固件管理流程</h3><ul><li>V1.0 (2025-03-16 08:15): 初始创建</li><li>V1.1 (2025-03-16 10:15): 移动到新的目录结构</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>所有流程图使用Mermaid语法编写，确保在支持Markdown的查看器中可以正确显示</li><li>流程图的更新需要同步更新版本历史</li><li>如需添加新的流程图，请在相应的分类文件中添加，并更新本总览文档</li><li>保持流程图的简洁性和可读性，必要时可以将复杂流程拆分为多个子流程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AW933XX驱动程序流程图总览&quot;&gt;&lt;a href=&quot;#AW933XX驱动程序流程图总览&quot; class=&quot;headerlink&quot; title=&quot;AW933XX驱动程序流程图总览&quot;&gt;&lt;/a&gt;AW933XX驱动程序流程图总览&lt;/h1&gt;&lt;h2 id=&quot;版本信息&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="传感器" scheme="https://joeforkyou.github.io/categories/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
    
    <category term="传感器" scheme="https://joeforkyou.github.io/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>nRF52832开发入门【三】MPU6050六轴传感器应用</title>
    <link href="https://joeforkyou.github.io/2025/03/14/nodic/3_nodic_MPU6050/"/>
    <id>https://joeforkyou.github.io/2025/03/14/nodic/3_nodic_MPU6050/</id>
    <published>2025-03-14T12:11:26.000Z</published>
    <updated>2025-03-14T12:13:01.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h1><p>MPU6050是一款广泛使用的6轴运动跟踪设备，由InvenSense公司开发。它集成了3轴加速度计和3轴陀螺仪，能够精确测量物体的加速度和角速度。</p><p>在Zephyr RTOS中的实现：</p><ul><li>驱动文件位置：<code>zephyr/drivers/sensor/tdk/mpu6050/</code></li><li>主要文件：<ul><li><code>mpu6050.c</code>：主驱动实现</li><li><code>mpu6050.h</code>：头文件定义</li><li><code>mpu6050_trigger.c</code>：中断触发相关功能</li><li><code>Kconfig</code>：驱动配置选项</li></ul></li></ul><p>官方有MPU6050的示例demo，路径如下:</p><p>C:\ncs\v2.9.1\zephyr\samples\sensor\mpu6050</p><p>拿到这个代码，在这个代码的基础上创建创建自己的工程文件。</p><p>代码结构很简单,其中多一个boards文件夹，下面有个nrf52dk_nrf52832.overlay文件，方便我们对自己板子的内容进行重构.</p><p>目标是剥离出6050的相关驱动，使得main.c中仅仅保留干净的代码</p><h1 id="2-引脚配置"><a href="#2-引脚配置" class="headerlink" title="2 引脚配置"></a>2 引脚配置</h1><p>官方默认的dts配置是</p><table><thead><tr><th>i2c0</th><th></th></tr></thead><tbody><tr><td>SDA</td><td>P0.26</td></tr><tr><td>SCL</td><td>P0.27</td></tr></tbody></table><p>详细的dts路劲和内容如下:</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/14/13f20d95ff33c829.png"></p><p>根据实际上自己板子上的外设连接的GPIO脚进行修改后保存</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/14/75c2423959e4eabd.png"></p><p>对应的dts文件</p><p>nrf52dk_nrf52832.overlay 也会新增相关的内容如下:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2019 Nordic Semiconductor ASA</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;i2c0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="title class_">mpu6050@68</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;invensense,mpu6050&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x68</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">int-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">11</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;i2c0_default</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="title class_">group1</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">psels</span> <span class="operator">=</span> <span class="params">&lt;NRF_PSEL(TWIM_SDA, <span class="number">0</span>, <span class="number">27</span>)&gt;</span>, <span class="params">&lt;NRF_PSEL(TWIM_SCL, <span class="number">0</span>, <span class="number">25</span>)&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>因为我的外设连接SDA是P027,SCL是P025,所以做如上的修改.</p><h1 id="3-项目配置"><a href="#3-项目配置" class="headerlink" title="3 项目配置"></a>3 项目配置</h1><p>我只是做个demo看数据，先把触发模式关掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MPU6050_TRIGGER_NONE=y</span><br></pre></td></tr></table></figure><h1 id="4-项目说明"><a href="#4-项目说明" class="headerlink" title="4 项目说明"></a>4 项目说明</h1><p>官方demo是直接放在</p><p>process_mpu6050 函数中获取不同通道的数据.</p><p>直接看我重构后的代码</p><p>mpu6050.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mpu6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">now_str</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">/* ...HH:MM:SS.MMM */</span></span><br><span class="line">    <span class="type">uint32_t</span> now = k_uptime_get_32();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ms = now % MSEC_PER_SEC;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line">    now /= MSEC_PER_SEC;</span><br><span class="line">    s = now % <span class="number">60U</span>;</span><br><span class="line">    now /= <span class="number">60U</span>;</span><br><span class="line">    min = now % <span class="number">60U</span>;</span><br><span class="line">    now /= <span class="number">60U</span>;</span><br><span class="line">    h = now;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%u:%02u:%02u.%03u&quot;</span>,</span><br><span class="line">             h, min, s, ms);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">process_mpu6050</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_value</span> <span class="title">temperature</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_value</span> <span class="title">accel</span>[3];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_value</span> <span class="title">gyro</span>[3];</span></span><br><span class="line">    <span class="type">int</span> rc = sensor_sample_fetch(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ,</span><br><span class="line">                                accel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = sensor_channel_get(dev, SENSOR_CHAN_GYRO_XYZ,</span><br><span class="line">                                gyro);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = sensor_channel_get(dev, SENSOR_CHAN_DIE_TEMP,</span><br><span class="line">                                &amp;temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s]:%g Cel\n&quot;</span></span><br><span class="line">               <span class="string">&quot;  accel %f %f %f m/s/s\n&quot;</span></span><br><span class="line">               <span class="string">&quot;  gyro  %f %f %f rad/s\n&quot;</span>,</span><br><span class="line">               now_str(),</span><br><span class="line">               sensor_value_to_double(&amp;temperature),</span><br><span class="line">               sensor_value_to_double(&amp;accel[<span class="number">0</span>]),</span><br><span class="line">               sensor_value_to_double(&amp;accel[<span class="number">1</span>]),</span><br><span class="line">               sensor_value_to_double(&amp;accel[<span class="number">2</span>]),</span><br><span class="line">               sensor_value_to_double(&amp;gyro[<span class="number">0</span>]),</span><br><span class="line">               sensor_value_to_double(&amp;gyro[<span class="number">1</span>]),</span><br><span class="line">               sensor_value_to_double(&amp;gyro[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sample fetch/get failed: %d\n&quot;</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MPU6050_TRIGGER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensor_trigger</span> <span class="title">trigger</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_mpu6050_drdy</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="keyword">struct</span> sensor_trigger *trig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc = process_mpu6050(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cancelling trigger due to failure: %d\n&quot;</span>, rc);</span><br><span class="line">        (<span class="type">void</span>)sensor_trigger_set(dev, trig, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_MPU6050_TRIGGER */</span></span></span><br></pre></td></tr></table></figure><p>mpu6050.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __MPU6050_H__</span><br><span class="line">#define __MPU6050_H__</span><br><span class="line"></span><br><span class="line">#include &lt;zephyr/types.h&gt;</span><br><span class="line">#include &lt;zephyr/kernel.h&gt;</span><br><span class="line">#include &lt;zephyr/device.h&gt;</span><br><span class="line">#include &lt;zephyr/drivers/sensor.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">const char *now_str(void);</span><br><span class="line">int process_mpu6050(const struct device *dev);</span><br><span class="line">#ifdef CONFIG_MPU6050_TRIGGER</span><br><span class="line">extern struct sensor_trigger trigger;</span><br><span class="line">void handle_mpu6050_drdy(const struct device *dev,const struct sensor_trigger *trig);</span><br><span class="line">#endif</span><br><span class="line">#endif /* __MPU6050_H__ */</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2019 Nordic Semiconductor ASA</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/sensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mpu6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">const</span> <span class="title">mpu6050</span> =</span> DEVICE_DT_GET_ONE(invensense_mpu6050);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!device_is_ready(mpu6050))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Device %s is not ready\n&quot;</span>, mpu6050-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MPU6050_TRIGGER</span></span><br><span class="line">    trigger = (<span class="keyword">struct</span> sensor_trigger)&#123;</span><br><span class="line">        .type = SENSOR_TRIG_DATA_READY,</span><br><span class="line">        .chan = SENSOR_CHAN_ALL,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (sensor_trigger_set(mpu6050, &amp;trigger,</span><br><span class="line">                           handle_mpu6050_drdy) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot configure trigger\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;Configured for triggered sampling.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!IS_ENABLED(CONFIG_MPU6050_TRIGGER))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> rc = process_mpu6050(mpu6050);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k_sleep(K_SECONDS(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* triggered runs with its own thread after exit */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-驱动说明"><a href="#5-驱动说明" class="headerlink" title="5 驱动说明"></a>5 驱动说明</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOG_MODULE_REGISTER(MPU6050, CONFIG_SENSOR_LOG_LEVEL);</span><br></pre></td></tr></table></figure><p>这是官方内部配置的驱动.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mpu6050_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mpu6050_data</span> *<span class="title">drv_data</span> =</span> dev-&gt;data;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mpu6050_config</span> *<span class="title">cfg</span> =</span> dev-&gt;config;</span><br><span class="line"><span class="type">uint8_t</span> id, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!device_is_ready(cfg-&gt;i2c.bus)) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Bus device is not ready&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check chip ID */</span></span><br><span class="line"><span class="keyword">if</span> (i2c_reg_read_byte_dt(&amp;cfg-&gt;i2c, MPU6050_REG_CHIP_ID, &amp;id) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Failed to read chip ID.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id == MPU6050_CHIP_ID || id == MPU9250_CHIP_ID || id == MPU6880_CHIP_ID) &#123;</span><br><span class="line">LOG_DBG(<span class="string">&quot;MPU6050/MPU9250/MPU6880 detected&quot;</span>);</span><br><span class="line">drv_data-&gt;device_type = DEVICE_TYPE_MPU6050;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == MPU6500_CHIP_ID) &#123;</span><br><span class="line">LOG_DBG(<span class="string">&quot;MPU6500 detected&quot;</span>);</span><br><span class="line">drv_data-&gt;device_type = DEVICE_TYPE_MPU6500;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Invalid chip ID.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wake up chip */</span></span><br><span class="line"><span class="keyword">if</span> (i2c_reg_update_byte_dt(&amp;cfg-&gt;i2c, MPU6050_REG_PWR_MGMT1,</span><br><span class="line">   MPU6050_SLEEP_EN, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Failed to wake up chip.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set accelerometer full-scale range */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0U</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (BIT(i+<span class="number">1</span>) == CONFIG_MPU6050_ACCEL_FS) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">4U</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Invalid value for accel full-scale range.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i2c_reg_write_byte_dt(&amp;cfg-&gt;i2c, MPU6050_REG_ACCEL_CFG,</span><br><span class="line">  i &lt;&lt; MPU6050_ACCEL_FS_SHIFT) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Failed to write accel full-scale range.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drv_data-&gt;accel_sensitivity_shift = <span class="number">14</span> - i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set gyroscope full-scale range */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0U</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (BIT(i) * <span class="number">250</span> == CONFIG_MPU6050_GYRO_FS) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">4U</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Invalid value for gyro full-scale range.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i2c_reg_write_byte_dt(&amp;cfg-&gt;i2c, MPU6050_REG_GYRO_CFG,</span><br><span class="line">  i &lt;&lt; MPU6050_GYRO_FS_SHIFT) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Failed to write gyro full-scale range.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drv_data-&gt;gyro_sensitivity_x10 = mpu6050_gyro_sensitivity_x10[i];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MPU6050_TRIGGER</span></span><br><span class="line"><span class="keyword">if</span> (cfg-&gt;int_gpio.port) &#123;</span><br><span class="line"><span class="keyword">if</span> (mpu6050_init_interrupt(dev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">LOG_DBG(<span class="string">&quot;Failed to initialize interrupts.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="干净点的重构说明"><a href="#干净点的重构说明" class="headerlink" title="干净点的重构说明"></a>干净点的重构说明</h1><p>仅保留main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/sys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/sensor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME i2c_module</span></span><br><span class="line"></span><br><span class="line">LOG_MODULE_REGISTER(i2c_module, LOG_LEVEL_INF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDR 0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_PWR_MGMT1_REG 0x6B</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_INF(<span class="string">&quot;Starting MPU6050 application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取MPU6050设备</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">mpu</span> =</span> DEVICE_DT_GET_ONE(invensense_mpu6050);</span><br><span class="line">    <span class="keyword">if</span> (!device_is_ready(mpu))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;MPU6050 device not ready&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_INF(<span class="string">&quot;MPU6050 device %s is ready&quot;</span>, mpu-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取传感器数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_value</span> <span class="title">accel</span>[3], <span class="title">gyro</span>[3], <span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取传感器数据</span></span><br><span class="line">        <span class="keyword">if</span> (sensor_sample_fetch(mpu) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERR(<span class="string">&quot;Failed to fetch sensor data&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取加速度数据</span></span><br><span class="line">        sensor_channel_get(mpu, SENSOR_CHAN_ACCEL_XYZ, accel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取陀螺仪数据</span></span><br><span class="line">        sensor_channel_get(mpu, SENSOR_CHAN_GYRO_XYZ, gyro);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取温度数据</span></span><br><span class="line">        sensor_channel_get(mpu, SENSOR_CHAN_DIE_TEMP, &amp;temp);</span><br><span class="line"></span><br><span class="line">        LOG_INF(<span class="string">&quot;Accel (m/s^2): X=%d.%06d, Y=%d.%06d, Z=%d.%06d&quot;</span>,</span><br><span class="line">                accel[<span class="number">0</span>].val1, accel[<span class="number">0</span>].val2, accel[<span class="number">1</span>].val1, accel[<span class="number">1</span>].val2, accel[<span class="number">2</span>].val1, accel[<span class="number">2</span>].val2);</span><br><span class="line"></span><br><span class="line">        LOG_INF(<span class="string">&quot;Gyro (dps): X=%d.%06d, Y=%d.%06d, Z=%d.%06d&quot;</span>,</span><br><span class="line">                gyro[<span class="number">0</span>].val1, gyro[<span class="number">0</span>].val2, gyro[<span class="number">1</span>].val1, gyro[<span class="number">1</span>].val2, gyro[<span class="number">2</span>].val1, gyro[<span class="number">2</span>].val2);</span><br><span class="line"></span><br><span class="line">        LOG_INF(<span class="string">&quot;Temperature (Celsius): %d.%06d&quot;</span>, temp.val1, temp.val2);</span><br><span class="line"></span><br><span class="line">        k_sleep(K_MSEC(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-说明&quot;&gt;&lt;a href=&quot;#1-说明&quot; class=&quot;headerlink&quot; title=&quot;1 说明&quot;&gt;&lt;/a&gt;1 说明&lt;/h1&gt;&lt;p&gt;MPU6050是一款广泛使用的6轴运动跟踪设备，由InvenSense公司开发。它集成了3轴加速度计和3轴陀螺仪，能够精确测</summary>
      
    
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/categories/nodic/"/>
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/tags/nodic/"/>
    
  </entry>
  
  <entry>
    <title>nRF52832开发入门【二】模块化</title>
    <link href="https://joeforkyou.github.io/2025/03/09/nodic/2_nodic%E6%9E%B6%E6%9E%84%E5%8C%96/"/>
    <id>https://joeforkyou.github.io/2025/03/09/nodic/2_nodic%E6%9E%B6%E6%9E%84%E5%8C%96/</id>
    <published>2025-03-09T09:22:17.000Z</published>
    <updated>2025-03-09T10:49:10.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>我们实际开发过程中往往会很复杂，为了更好的管理代码，我们需要模块化。模块化的好处有很多，比如：</p><ol><li>降低耦合度：模块化可以降低模块间的耦合度，使得代码更容易维护和修改。</li><li>复用性：模块化可以提高代码的复用性，可以节省开发时间。</li><li>降低成本：模块化可以降低开发成本，可以节省开发成本。</li></ol><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h1><p>VCode安装插件:<br>1.nRF Connect for VS Code<br>2.CMake<br>先创建一个空的工程文件<br><img src="https://s3.bmp.ovh/imgs/2025/03/09/b636b2557bf0f419.png"></p><p>创建完,默认会创建一些最基础的配置文件</p><p>CMakeLists.txt和prj.conf</p><p>然后给这个app添加build配置</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/09/c14f1a613b73d198.png"></p><p>除了板子是你对应的手上的板子，其他一路默认即可</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/09/8cf7a733fee00a46.png"></p><p>然后开始build即可.</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/09/0ceb7b5e3a3cc9fb.png"></p><p>插上对应的板子 烧录build flash即可</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/09/e4904e2310b08942.png"></p><p>提供的默认空工程没啥东西，我这边按照我的自己的习惯对齐进行分模块，有的人习惯是把c文件放一块,h文件放一块,也可以每个模块都单独一个文件夹</p><p>我是习惯后者.前者是可以省去CMakeList.txt文件添加的麻烦，但是我觉得这就不算真正意义上的模块化了.</p><p>将src文件中的main.c挪出来，删掉src文件，并且添加自己想要添加的模块内容如下示例:</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/09/230c1b8e5b9dbd41.png"></p><p>另外再CMakeLists.txt中添加相关的编译说明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory (led/ led_path)</span><br><span class="line">aux_source_directory (button/ button_path)</span><br><span class="line">aux_source_directory (bluetooth/ bluetooth_path)</span><br><span class="line"></span><br><span class="line">target_sources(app PRIVATE main.c</span><br><span class="line">                    $&#123;led_path&#125;</span><br><span class="line">                    $&#123;button_path&#125;</span><br><span class="line">                    $&#123;bluetooth_path&#125;)</span><br></pre></td></tr></table></figure><p>这样就能把每个模块单独分开,互相解藕</p><h1 id="3-输出"><a href="#3-输出" class="headerlink" title="3 输出"></a>3 输出</h1><p>输出一般单片或者嵌入式都是以led作为参考的示例.</p><p>非常的简单操作就是对led的节点 做dts检查后初始化,然后就可以输出高低电平了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpio_is_ready_dt(&amp;led1);</span><br><span class="line">gpio_pin_configure_dt(&amp;led0, GPIO_OUTPUT);</span><br><span class="line">gpio_pin_set_dt(&amp;led0, <span class="number">1</span>);<span class="comment">//高电平</span></span><br><span class="line">gpio_pin_set_dt(&amp;led0, <span class="number">0</span>);<span class="comment">//低电平</span></span><br></pre></td></tr></table></figure><p>更详细gpio定制化dts可以参考这个工程<strong>custom_dts_binding</strong></p><h1 id="4-输入"><a href="#4-输入" class="headerlink" title="4 输入"></a>4 输入</h1><p>输出拿按钮button举例:</p><p>输入和输出相似 也是先做ready_dt check 然后配置成输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpio_is_ready_dt(&amp;button0);</span><br><span class="line">gpio_pin_configure_dt(&amp;button0, GPIO_INPUT);</span><br><span class="line"><span class="comment">//设置中断配置</span></span><br><span class="line">gpio_pin_interrupt_configure_dt(&amp;button,GPIO_INT_EDGE_TO_ACTIVE);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;我们实际开发过程中往往会很复杂，为了更好的管理代码，我们需要模块化。模块化的好处有很多，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/categories/nodic/"/>
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/tags/nodic/"/>
    
  </entry>
  
  <entry>
    <title>nRF52832开发入门【一】</title>
    <link href="https://joeforkyou.github.io/2025/03/07/nodic/1_nodic%E5%9F%BA%E7%A1%80/"/>
    <id>https://joeforkyou.github.io/2025/03/07/nodic/1_nodic%E5%9F%BA%E7%A1%80/</id>
    <published>2025-03-07T11:59:40.000Z</published>
    <updated>2025-03-07T12:16:59.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Zephyr简要说明"><a href="#1-Zephyr简要说明" class="headerlink" title="1 Zephyr简要说明"></a>1 Zephyr简要说明</h1><p>官方没有log 加载的机制说明</p><p>只能自己对着代码看了,mark下做个记录</p><p>Zephyr 是一个开源的实时操作系统（RTOS），专为资源受限的设备和物联网应用设计。它支持多种硬件平台，并提供了丰富的功能和模块来简化嵌入式开发。以下是一些关于 Zephyr 的关键点和使用技巧：</p><h3 id="1-Zephyr-基本概念"><a href="#1-Zephyr-基本概念" class="headerlink" title="1. Zephyr 基本概念"></a>1. Zephyr 基本概念</h3><ul><li><strong>内核</strong>：Zephyr 提供了一个轻量级的实时内核，支持多线程、中断处理、定时器等功能。</li><li><strong>模块</strong>：Zephyr 包含了大量的模块，如蓝牙、Wi-Fi、USB、文件系统等，方便开发者快速集成各种功能。</li><li><strong>配置系统</strong>：Zephyr 使用 Kconfig 和 CMake 来管理项目的配置和构建过程。</li></ul><h3 id="2-日志系统"><a href="#2-日志系统" class="headerlink" title="2. 日志系统"></a>2. 日志系统</h3><p>Zephyr 提供了强大的日志系统，可以帮助开发者调试和监控应用程序。以下是使用日志系统的步骤：</p><h4 id="2-1-配置日志系统"><a href="#2-1-配置日志系统" class="headerlink" title="2.1 配置日志系统"></a>2.1 配置日志系统</h4><p>在 <code>prj.conf</code> 文件中启用日志功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_LOG=y</span><br><span class="line">CONFIG_LOG_DEFAULT_LEVEL=4  # 4 表示信息级别 (INFO)</span><br><span class="line">CONFIG_LOG_BACKEND_UART=y   # 使用 UART 输出日志</span><br><span class="line">CONFIG_UART_CONSOLE=y       # 启用 UART 控制台</span><br></pre></td></tr></table></figure><h4 id="2-2-注册日志模块"><a href="#2-2-注册日志模块" class="headerlink" title="2.2 注册日志模块"></a>2.2 注册日志模块</h4><p>在源文件中注册日志模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME my_module</span></span><br><span class="line">LOG_MODULE_REGISTER(LOG_MODULE_NAME);</span><br></pre></td></tr></table></figure><h4 id="2-3-使用日志宏"><a href="#2-3-使用日志宏" class="headerlink" title="2.3 使用日志宏"></a>2.3 使用日志宏</h4><p>在代码中使用不同的日志宏输出信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOG_INF(<span class="string">&quot;This is an info message&quot;</span>);</span><br><span class="line">LOG_DBG(<span class="string">&quot;This is a debug message&quot;</span>);</span><br><span class="line">LOG_ERR(<span class="string">&quot;This is an error message&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-蓝牙功能"><a href="#3-蓝牙功能" class="headerlink" title="3. 蓝牙功能"></a>3. 蓝牙功能</h3><p>Zephyr 支持蓝牙低功耗（BLE）协议栈，可以用于开发各种蓝牙设备。以下是一个简单的 BLE 外设示例：</p><h4 id="3-1-初始化蓝牙"><a href="#3-1-初始化蓝牙" class="headerlink" title="3.1 初始化蓝牙"></a>3.1 初始化蓝牙</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err = bt_enable(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    printk(<span class="string">&quot;Bluetooth init failed (err %d)\n&quot;</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;Bluetooth initialized\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-广播设置"><a href="#3-2-广播设置" class="headerlink" title="3.2 广播设置"></a>3.2 广播设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_data</span> <span class="title">ad</span>[] =</span> &#123;</span><br><span class="line">    BT_DATA_BYTES(BT_DATA_GAP_APPEARANCE,</span><br><span class="line">                  (CONFIG_BT_DEVICE_APPEARANCE &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>,</span><br><span class="line">                  (CONFIG_BT_DEVICE_APPEARANCE &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>),</span><br><span class="line">    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),</span><br><span class="line">    BT_DATA_BYTES(BT_DATA_UUID16_ALL, BT_UUID_16_ENCODE(BT_UUID_HIDS_VAL),</span><br><span class="line">                                  BT_UUID_16_ENCODE(BT_UUID_BAS_VAL)),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_data</span> <span class="title">sd</span>[] =</span> &#123;</span><br><span class="line">    BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-3-连接回调"><a href="#3-3-连接回调" class="headerlink" title="3.3 连接回调"></a>3.3 连接回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">connected</span><span class="params">(<span class="keyword">struct</span> bt_conn *conn, <span class="type">uint8_t</span> err)</span> &#123;</span><br><span class="line">    <span class="type">char</span> addr[BT_ADDR_LE_STR_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Connection failed (err %d)\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    printk(<span class="string">&quot;Connected to %s\n&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BT_CONN_CB_DEFINE(conn_callbacks) = &#123;</span><br><span class="line">    .connected = connected,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-工作队列和消息队列"><a href="#4-工作队列和消息队列" class="headerlink" title="4. 工作队列和消息队列"></a>4. 工作队列和消息队列</h3><p>Zephyr 提供了工作队列和消息队列机制，方便任务调度和异步处理。</p><h4 id="4-1-定义和初始化工作队列"><a href="#4-1-定义和初始化工作队列" class="headerlink" title="4.1 定义和初始化工作队列"></a>4.1 定义和初始化工作队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">k_work</span> <span class="title">hids_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mouse_handler</span><span class="params">(<span class="keyword">struct</span> k_work *work)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理鼠标事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 函数中初始化工作队列</span></span><br><span class="line">k_work_init(&amp;hids_work, mouse_handler);</span><br></pre></td></tr></table></figure><h4 id="4-2-消息队列"><a href="#4-2-消息队列" class="headerlink" title="4.2 消息队列"></a>4.2 消息队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">K_MSGQ_DEFINE(hids_queue, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mouse_pos), HIDS_QUEUE_SIZE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mouse_pos</span> <span class="title">pos</span>;</span></span><br><span class="line">pos.x_val = <span class="number">10</span>;</span><br><span class="line">pos.y_val = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息到队列</span></span><br><span class="line">k_msgq_put(&amp;hids_queue, &amp;pos, K_NO_WAIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中获取消息</span></span><br><span class="line">k_msgq_get(&amp;hids_queue, &amp;pos, K_NO_WAIT);</span><br></pre></td></tr></table></figure><h3 id="5-配置系统"><a href="#5-配置系统" class="headerlink" title="5. 配置系统"></a>5. 配置系统</h3><p>Zephyr 使用 Kconfig 和 CMake 来管理项目的配置和构建过程。</p><h4 id="5-1-Kconfig-配置"><a href="#5-1-Kconfig-配置" class="headerlink" title="5.1 Kconfig 配置"></a>5.1 Kconfig 配置</h4><p>在 <code>prj.conf</code> 文件中添加或修改配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_BT=y</span><br><span class="line">CONFIG_LOG=y</span><br><span class="line">CONFIG_LOG_DEFAULT_LEVEL=4</span><br><span class="line">CONFIG_UART_CONSOLE=y</span><br></pre></td></tr></table></figure><h4 id="5-2-CMake-构建"><a href="#5-2-CMake-构建" class="headerlink" title="5.2 CMake 构建"></a>5.2 CMake 构建</h4><p>在 <code>CMakeLists.txt</code> 文件中指定项目名称和源文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.13</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Zephyr REQUIRED HINTS $ENV&#123;ZEPHYR_BASE&#125;)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(app PRIVATE src/main.c)</span><br></pre></td></tr></table></figure><h3 id="6-常见问题排查"><a href="#6-常见问题排查" class="headerlink" title="6. 常见问题排查"></a>6. 常见问题排查</h3><ul><li><strong>日志无法输出</strong>：检查 <code>prj.conf</code> 中的日志配置是否正确，确保日志模块已注册并初始化。</li><li><strong>蓝牙连接失败</strong>：检查广播数据和连接回调函数是否正确配置，确保蓝牙已成功初始化。</li><li><strong>内存不足</strong>：优化代码，减少不必要的内存分配，检查堆栈大小配置。</li></ul><p>通过以上介绍，你应该对 Zephyr 有了更深入的了解，并能够更好地利用其功能进行嵌入式开发。如果遇到具体问题，可以根据上述步骤进行排查和解决。</p><p>官方基础示例的代码路径如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ncs\v2.9.1\zephyr\samples\basic</span><br></pre></td></tr></table></figure><h1 id="2-实操"><a href="#2-实操" class="headerlink" title="2 实操"></a>2 实操</h1><p>按照如下的步骤先建立一个新的干净的工程.</p><p><img src="https://s3.bmp.ovh/imgs/2025/03/07/eb96cab6ffd0eee0.png"></p><p><img src="https://s3.bmp.ovh/imgs/2025/03/07/dd1c851959223afa.png"></p><p>先创建一个空的工程</p><h4 id="2-1-配置日志系统-1"><a href="#2-1-配置日志系统-1" class="headerlink" title="2.1 配置日志系统"></a>2.1 配置日志系统</h4><p>在 <code>prj.conf</code> 文件中启用日志功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_LOG=y</span><br><span class="line">CONFIG_LOG_DEFAULT_LEVEL=3  # 4 表示信息级别 (INFO)</span><br><span class="line">CONFIG_LOG_BACKEND_UART=y   # 使用 UART 输出日志</span><br><span class="line">CONFIG_UART_CONSOLE=y       # 启用 UART 控制台</span><br></pre></td></tr></table></figure><h4 id="2-2-注册日志模块-1"><a href="#2-2-注册日志模块-1" class="headerlink" title="2.2 注册日志模块"></a>2.2 注册日志模块</h4><p>在源文件中注册日志模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME my_module</span></span><br><span class="line">LOG_MODULE_REGISTER(LOG_MODULE_NAME);</span><br></pre></td></tr></table></figure><h4 id="2-3-使用日志宏-1"><a href="#2-3-使用日志宏-1" class="headerlink" title="2.3 使用日志宏"></a>2.3 使用日志宏</h4><p>在代码中使用不同的日志宏输出信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class="line">LOG_INF(<span class="string">&quot;This is an info message&quot;</span>);</span><br><span class="line">LOG_DBG(<span class="string">&quot;This is a debug message&quot;</span>);</span><br><span class="line">LOG_ERR(<span class="string">&quot;This is an error message&quot;</span>);</span><br></pre></td></tr></table></figure><p>添加如上信息后发现日志打不完整<br>[00:00:00.384,246] <dbg> os: k_sched_unlock: scheduler unlocked (0x20000b30:0)<br>[00:00:00.384,246] <inf> my_module: This is an info1 message<br>[00:00:00.384,246] <inf> my_module: This is [0m</p><p>然后我修改下log等级,并且添加缓冲区，就能正确打印log了.</p><p>CONFIG_LOG_DEFAULT_LEVEL&#x3D;3 # 等级3为LOG_INF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_LOG_BUFFER_SIZE=4096</span><br></pre></td></tr></table></figure><p>在 Zephyr 中，日志级别通常定义如下（数值越小，级别越低，日志输出少）：</p><ul><li>0: OFF（关闭日志）</li><li>1: ERROR（错误日志）</li><li>2: WARNING（警告日志）</li><li>3: INFO（信息日志）</li><li>4: DEBUG（调试日志）</li></ul><h1 id="3-LED"><a href="#3-LED" class="headerlink" title="3 LED"></a>3 LED</h1><p>由于到鼠标之前 还要掌握不少的内容，就边写 边加(注意这边prj.conf已经添加了log相关使能)</p><p>先load 官方demo <strong>blinky</strong></p><h2 id="3-1-官方demo"><a href="#3-1-官方demo" class="headerlink" title="3.1 官方demo"></a>3.1 官方demo</h2><p>官方的路径默认在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ncs\v2.9.1\zephyr\samples\basic\blinky</span><br></pre></td></tr></table></figure><p>这边看了官方默认的例子就是单led的闪烁,还是比较简单的 ，可以根据相关的dts，把其他led补上去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_NODE DT_ALIAS(led0)</span></span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">led0 = <span class="variable">&amp;led0</span><span class="punctuation">;</span></span><br><span class="line">led1 = <span class="variable">&amp;led1</span><span class="punctuation">;</span></span><br><span class="line">led2 = <span class="variable">&amp;led2</span><span class="punctuation">;</span></span><br><span class="line">led3 = <span class="variable">&amp;led3</span><span class="punctuation">;</span></span><br><span class="line">pwm-led0 = <span class="variable">&amp;pwm_led0</span><span class="punctuation">;</span></span><br><span class="line">sw0 = <span class="variable">&amp;button0</span><span class="punctuation">;</span></span><br><span class="line">sw1 = <span class="variable">&amp;button1</span><span class="punctuation">;</span></span><br><span class="line">sw2 = <span class="variable">&amp;button2</span><span class="punctuation">;</span></span><br><span class="line">sw3 = <span class="variable">&amp;button3</span><span class="punctuation">;</span></span><br><span class="line">bootloader-led0 = <span class="variable">&amp;led0</span><span class="punctuation">;</span></span><br><span class="line">mcuboot-button0 = <span class="variable">&amp;button0</span><span class="punctuation">;</span></span><br><span class="line">mcuboot-led0 = <span class="variable">&amp;led0</span><span class="punctuation">;</span></span><br><span class="line">watchdog0 = <span class="variable">&amp;wdt0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>led相关dts配置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">leds</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;gpio-leds&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">led0:</span> <span class="title class_">led_0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">17</span> GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Green LED 0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">led1:</span> <span class="title class_">led_1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">18</span> GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Green LED 1&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">led2:</span> <span class="title class_">led_2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">19</span> GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Green LED 2&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">led3:</span> <span class="title class_">led_3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">20</span> GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Green LED 3&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>修修改改完整的led代码如下,可以同时使用四盏灯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2016 Intel Corporation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1000 msec = 1 sec */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEP_TIME_MS   1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The devicetree node identifier for the &quot;led0&quot; alias. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_NODE DT_ALIAS(led0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_NODE DT_ALIAS(led1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_NODE DT_ALIAS(led2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_NODE DT_ALIAS(led3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME my_module</span></span><br><span class="line">LOG_MODULE_REGISTER(LOG_MODULE_NAME);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A build error on this line means your board is unsupported.</span></span><br><span class="line"><span class="comment"> * See the sample documentation for information on how to fix this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led0</span> =</span> GPIO_DT_SPEC_GET(LED0_NODE, gpios);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led1</span> =</span> GPIO_DT_SPEC_GET(LED1_NODE, gpios);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led2</span> =</span> GPIO_DT_SPEC_GET(LED2_NODE, gpios);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led3</span> =</span> GPIO_DT_SPEC_GET(LED3_NODE, gpios);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> led_state = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gpio_is_ready_dt(&amp;led0)||!gpio_is_ready_dt(&amp;led1)||!gpio_is_ready_dt(&amp;led2)||!gpio_is_ready_dt(&amp;led3)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_pin_configure_dt(&amp;led0, GPIO_OUTPUT_ACTIVE);</span><br><span class="line">    gpio_pin_configure_dt(&amp;led1, GPIO_OUTPUT_ACTIVE);</span><br><span class="line">    gpio_pin_configure_dt(&amp;led2, GPIO_OUTPUT_ACTIVE);</span><br><span class="line">    gpio_pin_configure_dt(&amp;led3, GPIO_OUTPUT_ACTIVE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">gpio_pin_toggle_dt(&amp;led0);</span><br><span class="line">        gpio_pin_toggle_dt(&amp;led1);</span><br><span class="line">        gpio_pin_toggle_dt(&amp;led2); </span><br><span class="line">        gpio_pin_toggle_dt(&amp;led3);</span><br><span class="line"></span><br><span class="line">led_state = !led_state;</span><br><span class="line">printk(<span class="string">&quot;LED state: %s\n&quot;</span>, led_state ? <span class="string">&quot;ON&quot;</span> : <span class="string">&quot;OFF&quot;</span>);</span><br><span class="line">k_msleep(SLEEP_TIME_MS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的函数并不知道.详细的操作，只是依样画葫芦</p><h2 id="3-2-GPIO"><a href="#3-2-GPIO" class="headerlink" title="3.2 GPIO"></a>3.2 GPIO</h2><p>然后这边是我问AI的回答</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设gpio_dev是你的GPIO设备指针，pin_number是你想要控制的引脚号</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">gpio_dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(gpio0)); <span class="comment">// 根据你的设备树配置获取设备指针</span></span><br><span class="line"><span class="type">gpio_pin_t</span> pin_number = <span class="number">13</span>; <span class="comment">// 引脚号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置引脚为输出</span></span><br><span class="line"><span class="type">int</span> ret = gpio_pin_configure(gpio_dev, pin_number, GPIO_OUTPUT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置引脚输出高电平（逻辑1）</span></span><br><span class="line">ret = gpio_pin_set(gpio_dev, pin_number, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置引脚输出低电平（逻辑0）</span></span><br><span class="line">ret = gpio_pin_set(gpio_dev, pin_number, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对着AI的回复，能看懂基本的信息，然后我这边使用的是led1，是已经配置好相关的Dts,</p><p>所以直接看代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2016 Intel Corporation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The devicetree node identifier for the &quot;led1&quot; alias. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> led1_NODE DT_ALIAS(led1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME my_module</span></span><br><span class="line">LOG_MODULE_REGISTER(LOG_MODULE_NAME);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A build error on this line means your board is unsupported.</span></span><br><span class="line"><span class="comment"> * See the sample documentation for information on how to fix this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led1</span> =</span> GPIO_DT_SPEC_GET(led1_NODE, gpios);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_ready_dt(&amp;led1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//因为已经官方已经配置好dts这边使用的gpio_pin_configure_dt函数</span></span><br><span class="line">    <span class="comment">//gpio_pin_configure是要指定对应的gpio脚</span></span><br><span class="line">    gpio_pin_configure_dt(&amp;led1, GPIO_OUTPUT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        gpio_pin_set_dt(&amp;led1, <span class="number">1</span>);</span><br><span class="line">        k_msleep(<span class="number">1000</span>);</span><br><span class="line">        gpio_pin_set_dt(&amp;led1, <span class="number">0</span>);</span><br><span class="line">        k_msleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-3-PWM"><a href="#3-3-PWM" class="headerlink" title="3.3 PWM"></a>3.3 PWM</h2><p>灯的基本操作看完了，这边直接看pwm相关的操作.</p><p>pwm就不赘述了.</p><p>官网的例子路径如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ncs\v2.9.1\zephyr\samples\drivers\led\pwm</span><br></pre></td></tr></table></figure><p>官方写的内容有好几个，我这边专注pwm的实现，所以删了不少的内容</p><p>下面是对<code>main.c</code>文件中每个地方的注释的详细解释：</p><h3 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/led.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/sys/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class="line">LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);</span><br></pre></td></tr></table></figure><ul><li>**<code>&lt;zephyr/device.h&gt;</code>**：包含设备驱动程序的通用接口。</li><li>**<code>&lt;zephyr/devicetree.h&gt;</code>**：包含设备树相关的宏和函数。</li><li>**<code>&lt;errno.h&gt;</code>**：包含错误号定义。</li><li>**<code>&lt;zephyr/drivers/led.h&gt;</code>**：包含LED驱动程序的API。</li><li>**<code>&lt;zephyr/sys/util.h&gt;</code>**：包含一些通用的系统工具宏。</li><li>**<code>&lt;zephyr/kernel.h&gt;</code>**：包含内核相关的API。</li><li>**<code>&lt;zephyr/logging/log.h&gt;</code>**：包含日志记录相关的API。</li><li>**<code>LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);</code>**：注册日志模块，设置日志级别为默认级别。</li></ul><h3 id="定义LED-PWM节点"><a href="#定义LED-PWM节点" class="headerlink" title="定义LED PWM节点"></a>定义LED PWM节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PWM_NODE_ID DT_COMPAT_GET_ANY_STATUS_OKAY(pwm_leds)</span></span><br></pre></td></tr></table></figure><ul><li>**<code>LED_PWM_NODE_ID</code>**：使用设备树宏<code>DT_COMPAT_GET_ANY_STATUS_OKAY</code>获取兼容性为<code>pwm_leds</code>且状态为<code>okay</code>的节点ID。</li></ul><h3 id="定义LED标签数组"><a href="#定义LED标签数组" class="headerlink" title="定义LED标签数组"></a>定义LED标签数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *led_label[] = &#123;</span><br><span class="line">DT_FOREACH_CHILD_SEP_VARGS(LED_PWM_NODE_ID, DT_PROP_OR, (,), label, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num_leds = ARRAY_SIZE(led_label);</span><br></pre></td></tr></table></figure><ul><li>**<code>led_label</code>**：使用设备树宏<code>DT_FOREACH_CHILD_SEP_VARGS</code>遍历<code>LED_PWM_NODE_ID</code>的所有子节点，获取每个子节点的<code>label</code>属性，并将其存储在数组中。</li><li>**<code>num_leds</code>**：计算<code>led_label</code>数组的大小，即LED的数量。</li></ul><h3 id="定义亮度和延迟"><a href="#定义亮度和延迟" class="headerlink" title="定义亮度和延迟"></a>定义亮度和延迟</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BRIGHTNESS 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FADE_DELAY_MS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FADE_DELAY K_MSEC(FADE_DELAY_MS)</span></span><br></pre></td></tr></table></figure><ul><li>**<code>MAX_BRIGHTNESS</code>**：定义LED的最大亮度为100。</li><li>**<code>FADE_DELAY_MS</code>**：定义亮度变化的延迟时间为10毫秒。</li><li>**<code>FADE_DELAY</code>**：将<code>FADE_DELAY_MS</code>转换为内核时间单位（毫秒）。</li></ul><h3 id="运行LED测试函数"><a href="#运行LED测试函数" class="headerlink" title="运行LED测试函数"></a>运行LED测试函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Run tests on a single LED using the LED API syscalls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param led_pwm LED PWM device.</span></span><br><span class="line"><span class="comment"> * @param led Number of the LED to test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_led_test</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *led_pwm, <span class="type">uint8_t</span> led)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">uint16_t</span> level;</span><br><span class="line"><span class="comment">/* Increase LED brightness gradually up to the maximum level. */</span></span><br><span class="line">LOG_INF(<span class="string">&quot;  Increasing brightness gradually&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (level = <span class="number">0</span>; level &lt;= MAX_BRIGHTNESS; level++) &#123;</span><br><span class="line">err = led_set_brightness(led_pwm, led, level);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;err=%d brightness=%d\n&quot;</span>, err, level);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">k_sleep(FADE_DELAY);</span><br><span class="line">&#125;</span><br><span class="line">k_sleep(K_MSEC(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数说明</strong>：<code>run_led_test</code>函数用于对单个LED进行测试。</li><li><strong>参数</strong>：<ul><li><code>led_pwm</code>：LED PWM设备指针。</li><li><code>led</code>：要测试的LED编号。</li></ul></li><li><strong>功能</strong>：<ul><li>使用<code>led_set_brightness</code>函数逐渐增加LED的亮度，直到达到最大亮度。</li><li>每次设置亮度后，使用<code>k_sleep(FADE_DELAY)</code>延迟一段时间。</li><li>达到最大亮度后，再延迟1000毫秒。</li></ul></li></ul><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">led_pwm</span>;</span></span><br><span class="line"><span class="type">uint8_t</span> led;</span><br><span class="line"></span><br><span class="line">led_pwm = DEVICE_DT_GET(LED_PWM_NODE_ID);</span><br><span class="line"><span class="keyword">if</span> (!device_is_ready(led_pwm)) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;Device %s is not ready&quot;</span>, led_pwm-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!num_leds) &#123;</span><br><span class="line">LOG_ERR(<span class="string">&quot;No LEDs found for %s&quot;</span>, led_pwm-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//我这边打印看了 只做了一个led支持pwm，需要自己看实际demo添加，实际demo我晚点研究</span></span><br><span class="line">        LOG_ERR(<span class="string">&quot;num_leds %d&quot;</span>,num_leds);</span><br><span class="line"><span class="keyword">for</span> (led = <span class="number">0</span>; led &lt; num_leds; led++) &#123;</span><br><span class="line">run_led_test(led_pwm, led);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：<ul><li>获取LED PWM设备指针<code>led_pwm</code>。</li><li>检查设备是否准备好，如果未准备好则记录错误日志并退出。</li><li>检查是否有LED，如果没有找到LED则记录错误日志并退出。</li><li>使用<code>do-while</code>循环无限循环地对每个LED进行测试。</li><li>调用<code>run_led_test</code>函数对每个LED进行亮度变化测试。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个文件的主要功能是对通过PWM控制的LED进行亮度变化测试。通过设备树获取LED设备和标签信息，并使用LED API设置LED的亮度，实现亮度的逐渐变化效果。</p><h1 id="4-Button"><a href="#4-Button" class="headerlink" title="4 Button"></a>4 Button</h1><p>led作为输出的入门,输入的入门当然是按钮。</p><p>官方示例代码路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ncs\v2.9.1\zephyr\samples\basic\button</span><br></pre></td></tr></table></figure><p>按键官方默认映射了四个脚别名，可以直接使用,相关路径如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ncs\v2.9.1\zephyr\boards\nordic\nrf52dk\nrf52dk_nrf52832-pinctrl.dtsi</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">led0 = <span class="variable">&amp;led0</span><span class="punctuation">;</span></span><br><span class="line">led1 = <span class="variable">&amp;led1</span><span class="punctuation">;</span></span><br><span class="line">led2 = <span class="variable">&amp;led2</span><span class="punctuation">;</span></span><br><span class="line">led3 = <span class="variable">&amp;led3</span><span class="punctuation">;</span></span><br><span class="line">pwm-led0 = <span class="variable">&amp;pwm_led0</span><span class="punctuation">;</span></span><br><span class="line">sw0 = <span class="variable">&amp;button0</span><span class="punctuation">;</span></span><br><span class="line">sw1 = <span class="variable">&amp;button1</span><span class="punctuation">;</span></span><br><span class="line">sw2 = <span class="variable">&amp;button2</span><span class="punctuation">;</span></span><br><span class="line">sw3 = <span class="variable">&amp;button3</span><span class="punctuation">;</span></span><br><span class="line">bootloader-led0 = <span class="variable">&amp;led0</span><span class="punctuation">;</span></span><br><span class="line">mcuboot-button0 = <span class="variable">&amp;button0</span><span class="punctuation">;</span></span><br><span class="line">mcuboot-led0 = <span class="variable">&amp;led0</span><span class="punctuation">;</span></span><br><span class="line">watchdog0 = <span class="variable">&amp;wdt0</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>看下buttons的引脚定义</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">buttons</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;gpio-keys&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">button0:</span> <span class="title class_">button_0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">13</span> (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Push button switch 0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">zephyr,code</span> <span class="operator">=</span> <span class="params">&lt;INPUT_KEY_0&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">button1:</span> <span class="title class_">button_1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">14</span> (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Push button switch 1&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">zephyr,code</span> <span class="operator">=</span> <span class="params">&lt;INPUT_KEY_1&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">button2:</span> <span class="title class_">button_2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">15</span> (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Push button switch 2&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">zephyr,code</span> <span class="operator">=</span> <span class="params">&lt;INPUT_KEY_2&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">button3:</span> <span class="title class_">button_3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">16</span> (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">label</span> <span class="operator">=</span> <span class="string">&quot;Push button switch 3&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">zephyr,code</span> <span class="operator">=</span> <span class="params">&lt;INPUT_KEY_3&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>以下是 <code>main.c</code> 文件的流程解释，跳过了文件开头的版本信息部分：</p><hr><h3 id="1-引入头文件"><a href="#1-引入头文件" class="headerlink" title="1. 引入头文件"></a><strong>1. 引入头文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/sys/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>引入了 Zephyr RTOS 的核心头文件和 GPIO 驱动相关的头文件。</li><li>用于操作设备、GPIO 配置、日志记录等功能。</li></ul><hr><h3 id="2-定义常量和模块名称"><a href="#2-定义常量和模块名称" class="headerlink" title="2. 定义常量和模块名称"></a><strong>2. 定义常量和模块名称</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEP_TIME_MS1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME my_module</span></span><br><span class="line">LOG_MODULE_REGISTER(LOG_MODULE_NAME);</span><br></pre></td></tr></table></figure><ul><li>定义了休眠时间（1 毫秒）。</li><li>注册了一个日志模块，名称为 <code>my_module</code>，用于调试和日志输出。</li></ul><hr><h3 id="3-获取按钮配置"><a href="#3-获取按钮配置" class="headerlink" title="3. 获取按钮配置"></a><strong>3. 获取按钮配置</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SW0_NODEDT_ALIAS(sw0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DT_NODE_HAS_STATUS_OKAY(SW0_NODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unsupported board: sw0 devicetree alias is not defined&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">button</span> =</span> GPIO_DT_SPEC_GET_OR(SW0_NODE, gpios, &#123;<span class="number">0</span>&#125;);</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_callback</span> <span class="title">button_cb_data</span>;</span></span><br></pre></td></tr></table></figure><ul><li>使用 Devicetree (<code>sw0</code> 别名) 获取按钮的 GPIO 配置。</li><li>如果 <code>sw0</code> 别名未定义，则编译报错。</li><li>将按钮的 GPIO 配置存储在 <code>button</code> 变量中，并初始化一个 GPIO 回调数据结构 <code>button_cb_data</code>。</li></ul><hr><h3 id="4-获取-LED-配置（可选）"><a href="#4-获取-LED-配置（可选）" class="headerlink" title="4. 获取 LED 配置（可选）"></a><strong>4. 获取 LED 配置（可选）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led</span> =</span> GPIO_DT_SPEC_GET_OR(DT_ALIAS(led0), gpios, &#123;<span class="number">0</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li>使用 Devicetree (<code>led0</code> 别名) 获取 LED 的 GPIO 配置。</li><li>如果 <code>led0</code> 别名未定义，则默认值为 <code>&#123;0&#125;</code>，表示不使用 LED。</li></ul><hr><h3 id="5-按钮按下回调函数"><a href="#5-按钮按下回调函数" class="headerlink" title="5. 按钮按下回调函数"></a><strong>5. 按钮按下回调函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">button_pressed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> gpio_callback *cb, <span class="type">uint32_t</span> pins)</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_INF(<span class="string">&quot;Button pressed at %&quot;</span> PRIu32 <span class="string">&quot;\n&quot;</span>, k_cycle_get_32());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当按钮被按下时，触发此回调函数。</li><li>记录按钮按下的时间戳（以 CPU 周期为单位）。</li></ul><hr><h3 id="6-主函数逻辑"><a href="#6-主函数逻辑" class="headerlink" title="6. 主函数逻辑"></a><strong>6. 主函数逻辑</strong></h3><h4 id="6-1-初始化按钮"><a href="#6-1-初始化按钮" class="headerlink" title="6.1 初始化按钮"></a><strong>6.1 初始化按钮</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gpio_is_ready_dt(&amp;button)) &#123;</span><br><span class="line">    LOG_INF(<span class="string">&quot;Error: button device %s is not ready\n&quot;</span>, button.port-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    LOG_INF(<span class="string">&quot;Error %d: failed to configure %s pin %d\n&quot;</span>, ret, button.port-&gt;name, button.pin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查按钮的 GPIO 设备是否可用。</li><li>配置按钮引脚为输入模式。</li></ul><h4 id="6-2-配置中断"><a href="#6-2-配置中断" class="headerlink" title="6.2 配置中断"></a><strong>6.2 配置中断</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    LOG_INF(<span class="string">&quot;Error %d: failed to configure interrupt on %s pin %d\n&quot;</span>, ret, button.port-&gt;name, button.pin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置按钮引脚的中断，检测边沿触发事件（按钮按下）。</li></ul><h4 id="6-3-添加回调函数"><a href="#6-3-添加回调函数" class="headerlink" title="6.3 添加回调函数"></a><strong>6.3 添加回调函数</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin));</span><br><span class="line">gpio_add_callback(button.port, &amp;button_cb_data);</span><br><span class="line">LOG_INF(<span class="string">&quot;Set up button at %s pin %d\n&quot;</span>, button.port-&gt;name, button.pin);</span><br></pre></td></tr></table></figure><ul><li>初始化并注册按钮的回调函数 <code>button_pressed</code>。</li><li>将回调函数绑定到按钮的 GPIO 引脚。</li></ul><h4 id="6-4-初始化-LED（如果存在）"><a href="#6-4-初始化-LED（如果存在）" class="headerlink" title="6.4 初始化 LED（如果存在）"></a><strong>6.4 初始化 LED（如果存在）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (led.port &amp;&amp; !gpio_is_ready_dt(&amp;led)) &#123;</span><br><span class="line">    LOG_INF(<span class="string">&quot;Error %d: LED device %s is not ready; ignoring it\n&quot;</span>, ret, led.port-&gt;name);</span><br><span class="line">    led.port = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (led.port) &#123;</span><br><span class="line">    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_INF(<span class="string">&quot;Error %d: failed to configure LED device %s pin %d\n&quot;</span>, ret, led.port-&gt;name, led.pin);</span><br><span class="line">        led.port = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_INF(<span class="string">&quot;Set up LED at %s pin %d\n&quot;</span>, led.port-&gt;name, led.pin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查 LED 的 GPIO 设备是否可用。</li><li>如果可用，配置 LED 引脚为输出模式。</li></ul><h4 id="6-5-主循环"><a href="#6-5-主循环" class="headerlink" title="6.5 主循环"></a><strong>6.5 主循环</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG_INF(<span class="string">&quot;Press the button\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (led.port) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> val = gpio_pin_get_dt(&amp;button);</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            gpio_pin_set_dt(&amp;led, val);</span><br><span class="line">        &#125;</span><br><span class="line">        k_msleep(SLEEP_TIME_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提示用户按下按钮。</li><li>如果存在 LED：<ul><li>在主循环中读取按钮的状态。</li><li>根据按钮状态设置 LED 的亮灭。</li><li>每次循环休眠 1 毫秒。</li></ul></li></ul><hr><h3 id="7-返回值"><a href="#7-返回值" class="headerlink" title="7. 返回值"></a><strong>7. 返回值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>主函数正常结束返回 0。</li></ul><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>该程序的主要功能是：</p><ol><li>监听按钮的按下事件，并通过中断触发回调函数记录事件。</li><li>如果存在 LED，则将 LED 的状态与按钮的状态同步（按钮按下时点亮 LED，松开时熄灭 LED）。</li></ol><h2 id="修改练习"><a href="#修改练习" class="headerlink" title="修改练习"></a>修改练习</h2><p>我这边按照我对代码的理解补充一个按键控制另外一个灯的操作,</p><p>完整的代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/sys/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEP_TIME_MS1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MODULE_NAME my_module</span></span><br><span class="line">LOG_MODULE_REGISTER(LOG_MODULE_NAME);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get button configuration from the devicetree sw0 alias. This is mandatory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW0_NODEDT_ALIAS(sw0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW1_NODEDT_ALIAS(sw1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DT_NODE_HAS_STATUS_OKAY(SW0_NODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unsupported board: sw0 devicetree alias is not defined&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">button0</span> =</span> GPIO_DT_SPEC_GET_OR(SW0_NODE, gpios,&#123;<span class="number">0</span>&#125;);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">button1</span> =</span> GPIO_DT_SPEC_GET_OR(SW1_NODE, gpios,&#123;<span class="number">0</span>&#125;);</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_callback</span> <span class="title">button_cb_data0</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_callback</span> <span class="title">button_cb_data1</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The led0 devicetree alias is optional. If present, we&#x27;ll use it</span></span><br><span class="line"><span class="comment"> * to turn on the LED whenever the button is pressed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led0</span> =</span> GPIO_DT_SPEC_GET_OR(DT_ALIAS(led0), gpios,&#123;<span class="number">0</span>&#125;);</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">led1</span> =</span> GPIO_DT_SPEC_GET_OR(DT_ALIAS(led1), gpios,&#123;<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">button_pressed0</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> gpio_callback *cb,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> pins)</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_INF(<span class="string">&quot;Button pressed at %&quot;</span> PRIu32 <span class="string">&quot;\n&quot;</span>, k_cycle_get_32());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">button_pressed1</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> gpio_callback *cb,</span></span><br><span class="line"><span class="params">    <span class="type">uint32_t</span> pins)</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_INF(<span class="string">&quot;Button pressed at %&quot;</span> PRIu32 <span class="string">&quot;\n&quot;</span>, k_cycle_get_32());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!gpio_is_ready_dt(&amp;button0)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> gpio_pin_configure_dt(&amp;button0, GPIO_INPUT);</span><br><span class="line"></span><br><span class="line"> gpio_pin_interrupt_configure_dt(&amp;button0,GPIO_INT_EDGE_TO_ACTIVE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_ready_dt(&amp;button1)) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_pin_configure_dt(&amp;button1, GPIO_INPUT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gpio_pin_interrupt_configure_dt(&amp;button1, GPIO_INT_EDGE_TO_ACTIVE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">gpio_init_callback(&amp;button_cb_data0, button_pressed0, BIT(button0.pin));</span><br><span class="line">gpio_add_callback(button0.port, &amp;button_cb_data0);</span><br><span class="line">LOG_INF(<span class="string">&quot;Set up button at %s pin %d\n&quot;</span>, button0.port-&gt;name, button0.pin);</span><br><span class="line"></span><br><span class="line">    gpio_init_callback(&amp;button_cb_data1, button_pressed1, BIT(button1.pin));</span><br><span class="line">gpio_add_callback(button1.port, &amp;button_cb_data1);</span><br><span class="line">LOG_INF(<span class="string">&quot;Set up button at %s pin %d\n&quot;</span>, button1.port-&gt;name, button1.pin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (led0.port &amp;&amp; !gpio_is_ready_dt(&amp;led0)) &#123;</span><br><span class="line">led0.port = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (led0.port) </span><br><span class="line">    &#123;</span><br><span class="line">gpio_pin_configure_dt(&amp;led0, GPIO_OUTPUT);</span><br><span class="line">LOG_INF(<span class="string">&quot;Set up LED at %s pin %d\n&quot;</span>, led0.port-&gt;name, led0.pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (led1.port &amp;&amp; !gpio_is_ready_dt(&amp;led1)) &#123;</span><br><span class="line">led1.port = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (led1.port) </span><br><span class="line">    &#123;</span><br><span class="line">gpio_pin_configure_dt(&amp;led1, GPIO_OUTPUT);</span><br><span class="line">LOG_INF(<span class="string">&quot;Set up LED at %s pin %d\n&quot;</span>, led1.port-&gt;name, led1.pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOG_INF(<span class="string">&quot;Press the button\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If we have an LED, match its state to the button&#x27;s. */</span></span><br><span class="line">        <span class="type">int</span> val  = gpio_pin_get_dt(&amp;button0);</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            gpio_pin_set_dt(&amp;led0, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we have an LED, match its state to the button&#x27;s. */</span></span><br><span class="line">        <span class="type">int</span> val1 = gpio_pin_get_dt(&amp;button1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val1 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gpio_pin_set_dt(&amp;led1, val1);</span><br><span class="line">        &#125;</span><br><span class="line">        k_msleep(SLEEP_TIME_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-Thread"><a href="#5-Thread" class="headerlink" title="5 Thread"></a>5 Thread</h1><p>在做完led(输出)和button(输入)后，我们也看下线程相关的内容,实际项目操作中，非常依赖各个线程之间的操作.咱都用上实时操作系统了,避免不了线程的.</p><p>把基础过完后再去看蓝牙相关的内容.</p><p>官方的线程非常简单,没什么难度.</p><p>当然，以下是详细的代码梳理，并附带详细的说明：</p><h3 id="文件流程梳理"><a href="#文件流程梳理" class="headerlink" title="文件流程梳理"></a>文件流程梳理</h3><h3 id="1-头文件和宏定义"><a href="#1-头文件和宏定义" class="headerlink" title="1. 头文件和宏定义"></a>1. 头文件和宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/sys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/sys/__assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size of stack area used by each thread */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* scheduling priority used by each thread */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIORITY 7</span></span><br></pre></td></tr></table></figure><ul><li><strong>头文件</strong>：包含了Zephyr RTOS所需的库文件，用于设备驱动、内核功能、GPIO操作、打印输出等。</li><li><strong>宏定义</strong>：定义了每个线程的堆栈大小为1024字节，优先级为7。</li></ul><h3 id="2-设备树检查"><a href="#2-设备树检查" class="headerlink" title="2. 设备树检查"></a>2. 设备树检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_NODE DT_ALIAS(led0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_NODE DT_ALIAS(led1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DT_NODE_HAS_STATUS_OKAY(LED0_NODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unsupported board: led0 devicetree alias is not defined&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DT_NODE_HAS_STATUS_OKAY(LED1_NODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unsupported board: led1 devicetree alias is not defined&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>设备树别名</strong>：通过设备树别名获取<code>led0</code>和<code>led1</code>节点。</li><li><strong>检查设备树节点</strong>：确保设备树中定义了<code>led0</code>和<code>led1</code>节点，否则编译报错。</li></ul><h3 id="3-数据结构定义"><a href="#3-数据结构定义" class="headerlink" title="3. 数据结构定义"></a>3. 数据结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">printk_data_t</span> &#123;</span></span><br><span class="line"><span class="type">void</span> *fifo_reserved; <span class="comment">/* 1st word reserved for use by fifo */</span></span><br><span class="line"><span class="type">uint32_t</span> led;</span><br><span class="line"><span class="type">uint32_t</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">K_FIFO_DEFINE(printk_fifo);</span><br></pre></td></tr></table></figure><ul><li><strong>结构体定义</strong>：<code>printk_data_t</code>用于存储LED编号和计数器信息。</li><li><strong>FIFO队列</strong>：定义了一个FIFO队列<code>printk_fifo</code>，用于线程间通信。</li></ul><h3 id="4-LED初始化"><a href="#4-LED初始化" class="headerlink" title="4. LED初始化"></a>4. LED初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> <span class="title">spec</span>;</span></span><br><span class="line"><span class="type">uint8_t</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">led</span> <span class="title">led0</span> =</span> &#123;</span><br><span class="line">.spec = GPIO_DT_SPEC_GET_OR(LED0_NODE, gpios, &#123;<span class="number">0</span>&#125;),</span><br><span class="line">.num = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">led</span> <span class="title">led1</span> =</span> &#123;</span><br><span class="line">.spec = GPIO_DT_SPEC_GET_OR(LED1_NODE, gpios, &#123;<span class="number">0</span>&#125;),</span><br><span class="line">.num = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>结构体定义</strong>：<code>led</code>结构体用于封装LED的GPIO配置信息。</li><li><strong>LED初始化</strong>：<code>led0</code>和<code>led1</code>是两个常量结构体，分别初始化了两个LED的GPIO配置。</li></ul><h3 id="5-LED闪烁函数-blink"><a href="#5-LED闪烁函数-blink" class="headerlink" title="5. LED闪烁函数 (blink)"></a>5. LED闪烁函数 (<code>blink</code>)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blink</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> led *led, <span class="type">uint32_t</span> sleep_ms, <span class="type">uint32_t</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_dt_spec</span> *<span class="title">spec</span> =</span> &amp;led-&gt;spec;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!device_is_ready(spec-&gt;port)) &#123;</span><br><span class="line">printk(<span class="string">&quot;Error: %s device is not ready\n&quot;</span>, spec-&gt;port-&gt;name);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = gpio_pin_configure_dt(spec, GPIO_OUTPUT);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;Error %d: failed to configure pin %d (LED &#x27;%d&#x27;)\n&quot;</span>,</span><br><span class="line">ret, spec-&gt;pin, led-&gt;num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">gpio_pin_set(spec-&gt;port, spec-&gt;pin, cnt % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">printk_data_t</span> <span class="title">tx_data</span> =</span> &#123; .led = id, .cnt = cnt &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">printk_data_t</span>);</span><br><span class="line"><span class="type">char</span> *mem_ptr = k_malloc(size);</span><br><span class="line">__ASSERT_NO_MSG(mem_ptr != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(mem_ptr, &amp;tx_data, size);</span><br><span class="line"></span><br><span class="line">k_fifo_put(&amp;printk_fifo, mem_ptr);</span><br><span class="line"></span><br><span class="line">k_msleep(sleep_ms);</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数功能</strong>：<code>blink</code>函数接受一个LED结构体指针、延时时间和LED标识作为参数。</li><li><strong>设备检查</strong>：检查对应的GPIO设备是否准备好。</li><li><strong>GPIO配置</strong>：将GPIO配置为输出模式。</li><li><strong>无限循环</strong>：在无限循环中切换LED状态，并将当前状态（LED编号和计数器）放入FIFO队列中。</li><li><strong>延时</strong>：每次切换后休眠指定的时间。</li></ul><h3 id="6-线程函数定义"><a href="#6-线程函数定义" class="headerlink" title="6. 线程函数定义"></a>6. 线程函数定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blink0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">blink(&amp;led0, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blink1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">blink(&amp;led1, <span class="number">1000</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_out</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">printk_data_t</span> *<span class="title">rx_data</span> =</span> k_fifo_get(&amp;printk_fifo,</span><br><span class="line">   K_FOREVER);</span><br><span class="line">printk(<span class="string">&quot;Toggled led%d; counter=%d\n&quot;</span>,</span><br><span class="line">       rx_data-&gt;led, rx_data-&gt;cnt);</span><br><span class="line">k_free(rx_data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>blink0</code>函数</strong>：调用<code>blink</code>函数控制<code>led0</code>，每100ms切换一次。</li><li><strong><code>blink1</code>函数</strong>：调用<code>blink</code>函数控制<code>led1</code>，每1000ms切换一次。</li><li><strong><code>uart_out</code>函数</strong>：从FIFO队列中获取数据并打印到串口。</li></ul><h3 id="7-线程创建"><a href="#7-线程创建" class="headerlink" title="7. 线程创建"></a>7. 线程创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">K_THREAD_DEFINE(blink0_id, STACKSIZE, blink0, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">PRIORITY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">K_THREAD_DEFINE(blink1_id, STACKSIZE, blink1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">PRIORITY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">K_THREAD_DEFINE(uart_out_id, STACKSIZE, uart_out, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">PRIORITY, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>线程定义</strong>：使用<code>K_THREAD_DEFINE</code>宏定义了三个线程：<ul><li><code>blink0_id</code>：控制<code>led0</code>，每100ms切换一次。</li><li><code>blink1_id</code>：控制<code>led1</code>，每1000ms切换一次。</li><li><code>uart_out_id</code>：负责从FIFO队列中读取数据并通过串口打印。</li></ul></li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>该文件实现了一个简单的多线程应用程序，使用Zephyr RTOS管理多个线程来控制两个LED的闪烁，并通过FIFO队列和串口输出LED的状态信息。每个线程都有明确的功能，确保系统的模块化和可维护性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Zephyr简要说明&quot;&gt;&lt;a href=&quot;#1-Zephyr简要说明&quot; class=&quot;headerlink&quot; title=&quot;1 Zephyr简要说明&quot;&gt;&lt;/a&gt;1 Zephyr简要说明&lt;/h1&gt;&lt;p&gt;官方没有log 加载的机制说明&lt;/p&gt;
&lt;p&gt;只能自己对着代</summary>
      
    
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/categories/nodic/"/>
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/tags/nodic/"/>
    
  </entry>
  
  <entry>
    <title>nRF52832开发环境的搭建</title>
    <link href="https://joeforkyou.github.io/2025/03/06/nodic/%E6%90%AD%E5%BB%BA/"/>
    <id>https://joeforkyou.github.io/2025/03/06/nodic/%E6%90%AD%E5%BB%BA/</id>
    <published>2025-03-06T12:08:39.000Z</published>
    <updated>2025-03-06T12:47:22.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>由于工作的原因，需要搭建这个相关的开发环境，于是边写边做呗<br>本文参考的内容:<br> <a href="https://gitee.com/mingkjl/ncs_setup_note">https://gitee.com/mingkjl/ncs_setup_note</a><br> 准备工作要安装<br>    1 安装 VSCode<br>    2 安装 nRF Command Line Tools<br>    3 安装 nRF Connect for Desktop<br>    4 下载 nRF Connect SDK<br>    5 安装 nRF Connect for VS Code插件</p><h2 id="1-1-安装-VSCode"><a href="#1-1-安装-VSCode" class="headerlink" title="1.1 安装 VSCode"></a>1.1 安装 VSCode</h2><p>VSCode 官方下载的地址如下:<br><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a><br>安装对应的系统版本即可</p><h2 id="1-2-安装-nRF-Command-Line-Tools"><a href="#1-2-安装-nRF-Command-Line-Tools" class="headerlink" title="1.2 安装 nRF Command Line Tools"></a>1.2 安装 nRF Command Line Tools</h2><p>nRF Command Line Tools 是一个命令行工具，用于在 Windows、macOS 和 Linux 上安装和配置 nRF Connect SDK。<br>官方的下载地址如下:<br><a href="https://docs.nordicsemi.com/bundle/ug_nrf_cltools/page/UG/cltools/nrf_command_line_tools_lpage.html">https://docs.nordicsemi.com/bundle/ug_nrf_cltools/page/UG/cltools/nrf_command_line_tools_lpage.html</a><br>笔者这边下的文件是:<br>nrf-command-line-tools-10.24.2-x64.exe<br>这个安装的时候会把Jlink驱动也给安装了。</p><h2 id="1-3-安装-nRF-Connect-for-Desktop"><a href="#1-3-安装-nRF-Connect-for-Desktop" class="headerlink" title="1.3 安装 nRF Connect for Desktop"></a>1.3 安装 nRF Connect for Desktop</h2><p>nRF Connect for Desktop 是基于 Electron 的桌面应用程序，用于连接 nRF52832 设备并进行固件升级、调试等操作。<br>官方的下载地址如下:<br><a href="https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-desktop">https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-desktop</a></p><h2 id="1-4-下载-nRF-Connect-SDK"><a href="#1-4-下载-nRF-Connect-SDK" class="headerlink" title="1.4 下载 nRF Connect SDK"></a>1.4 下载 nRF Connect SDK</h2><p>nRF Connect SDK 是用于开发基于 nRF52832 芯片的应用程序的软件开发包。<br>官方的下载地址如下:<br><a href="https://www.nordicsemi.com/Software-and-Tools/Software/nRF-Connect-SDK">https://www.nordicsemi.com/Software-and-Tools/Software/nRF-Connect-SDK</a><br>我建议是用百度云别人下好的然后替换过去，再使用west命令进行更新，这样可以避免很多不必要的麻烦。</p><h1 id="1-5安装-nRF-Connect-for-VS-Code插件"><a href="#1-5安装-nRF-Connect-for-VS-Code插件" class="headerlink" title="1.5安装 nRF Connect for VS Code插件"></a>1.5安装 nRF Connect for VS Code插件</h1><p>nRF Connect for VS Code 是一款基于 Visual Studio Code 的插件，用于在 VS Code 中进行 nRF52832 设备的固件升级、调试等操作。<br>官方的下载地址如下:<br><a href="https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-VS-Code">https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Connect-for-VS-Code</a></p><h1 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2.配置环境"></a>2.配置环境</h1><p>nRF Connect for Desktop 安装完成后需要下载相关的APPS.<br>如果嫌弃麻烦可以所有APP都下载，也可以只下载需要的APP。<br>最主要下载的额APP是:Toolchain Manager<br>在Toolchain Manager中下载对应的SDK版本。<br>然后在VSCode中安装nRF Connect for VS Code和nRF Connect for VS Code Extension Pack插件.<br>前者是主要的插件，后者是一些辅助包插件其中包括专用终端和DTS工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;p&gt;由于工作的原因，需要搭建这个相关的开发环境，于是边写边做呗&lt;br&gt;本文参考的内容:&lt;br&gt; &lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/categories/nodic/"/>
    
    
    <category term="nodic" scheme="https://joeforkyou.github.io/tags/nodic/"/>
    
  </entry>
  
  <entry>
    <title>【水果】【水果营养成分速查】</title>
    <link href="https://joeforkyou.github.io/2024/12/29/%E6%A4%8D%E7%89%A9/%E6%B0%B4%E6%9E%9C/"/>
    <id>https://joeforkyou.github.io/2024/12/29/%E6%A4%8D%E7%89%A9/%E6%B0%B4%E6%9E%9C/</id>
    <published>2024-12-29T10:37:22.000Z</published>
    <updated>2024-12-29T10:43:14.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热量"><a href="#热量" class="headerlink" title="热量"></a>热量</h1><h2 id="热量有三大来源"><a href="#热量有三大来源" class="headerlink" title="热量有三大来源"></a>热量有三大来源</h2><p>  热量，即食物中含有的能量，主要来源于食物中的三大营养物质:碳水化合物,脂类，蛋白质</p><ul><li>碳水化合物:主要是碳水化合物，如水果、蔬菜、肉类、蛋类等。</li><li>脂类:主要是脂肪、胆固醇、维生素等。</li><li>蛋白质:主要是蛋白质，如蔬菜蛋白、肉蛋白、蛋黄等。</li></ul><h2 id="热量是人类生命活动的基础"><a href="#热量是人类生命活动的基础" class="headerlink" title="热量是人类生命活动的基础"></a>热量是人类生命活动的基础</h2><p>  热量是人类生命活动的基础，是人体赖以存活的能量。<br>  富含热量的水果:</p><ol><li><strong>香蕉</strong>：香蕉富含碳水化合物，尤其是天然糖分，能够快速提供能量。</li><li><strong>牛油果</strong>：牛油果含有丰富的健康脂肪，尤其是单不饱和脂肪酸，热量较高。</li><li><strong>椰子</strong>：椰子的果肉和椰子油都含有较高的脂肪，热量丰富。</li><li><strong>榴莲</strong>：榴莲被称为“水果之王”，含有较高的碳水化合物和脂肪，热量非常高。</li><li><strong>枣</strong>：枣类水果如红枣、椰枣等，含有丰富的天然糖分，热量较高。</li><li><strong>葡萄</strong>：葡萄尤其是葡萄干，含有较高的糖分，能够提供较多的能量。</li><li><strong>芒果</strong>：芒果含有丰富的碳水化合物和天然糖分，热量较高。</li><li><strong>柠檬</strong>：柠檬含有丰富的碳水化合物和脂肪酸，热量较高。</li></ol><p>这些水果在日常饮食中可以作为能量补充的来源，但也要注意适量摄入，避免过量导致热量过剩。</p><h1 id="蛋白质"><a href="#蛋白质" class="headerlink" title="蛋白质"></a>蛋白质</h1><h2 id="蛋白质的作用"><a href="#蛋白质的作用" class="headerlink" title="蛋白质的作用"></a>蛋白质的作用</h2><p>蛋白质是人体必需的营养物质，它能够帮助人体进行代谢、组织形成、免疫调节、免疫功能、免疫诱导等功能。</p><ol><li><strong>牛油果</strong>：每100克牛油果约含2克蛋白质，同时还富含健康脂肪。</li><li><strong>番石榴</strong>：每100克番石榴约含2.6克蛋白质，是水果中蛋白质含量较高的选择。</li><li><strong>黑莓</strong>：每100克黑莓约含1.4克蛋白质，同时富含纤维和抗氧化剂。</li><li><strong>猕猴桃</strong>：每100克猕猴桃约含1.1克蛋白质，还含有丰富的维生素C。</li><li><strong>杏子</strong>：每100克杏子约含1.4克蛋白质，尤其是干杏的蛋白质含量更高。</li></ol><p>虽然这些水果的蛋白质含量相对较高，但若想补充蛋白质，仍需依赖豆类、坚果、肉类、鱼类和乳制品等更丰富的蛋白质来源。</p><h1 id="脂肪"><a href="#脂肪" class="headerlink" title="脂肪"></a>脂肪</h1><p>脂肪中的热量是蛋白质的2倍多<br>脂肪的主要作用是存储能量，并为人体提供必要的营养素。</p><ol><li><p><strong>牛油果（鳄梨）</strong><br>牛油果是脂肪含量最高的水果之一，富含健康的不饱和脂肪酸，尤其是单不饱和脂肪酸，对心脏健康有益。</p></li><li><p><strong>椰子</strong><br>椰子肉和椰子油中含有较高的饱和脂肪，但同时也富含中链脂肪酸，易于消化和吸收。</p></li><li><p><strong>橄榄</strong><br>橄榄（尤其是橄榄油）富含单不饱和脂肪酸，是地中海饮食的重要组成部分。</p></li><li><p><strong>榴莲</strong><br>榴莲虽然以高热量著称，但其脂肪含量也相对较高，同时富含多种营养素。</p></li></ol><p>这些水果虽然脂肪含量较高，但大多含有健康的脂肪酸，适量食用对身体有益。</p><h1 id="碳水化合物"><a href="#碳水化合物" class="headerlink" title="碳水化合物"></a>碳水化合物</h1><p>碳水化合物是能量的供应源.<br>碳水化合物是构成细胞的主要成分。<br>富含碳水化合物的水果:</p><ol><li><p><strong>香蕉</strong>：香蕉是碳水化合物含量较高的水果之一，尤其是成熟的香蕉，含有较多的天然糖分。</p></li><li><p><strong>葡萄</strong>：葡萄中的碳水化合物主要来自葡萄糖和果糖，尤其是干葡萄（葡萄干）的碳水化合物含量更高。</p></li><li><p><strong>芒果</strong>：芒果不仅富含维生素和矿物质，碳水化合物含量也较高。</p></li><li><p><strong>无花果</strong>：无花果的碳水化合物含量较高，尤其是干无花果。</p></li><li><p><strong>枣</strong>：枣类水果（如红枣、椰枣）的碳水化合物含量非常高，尤其是干枣。</p></li><li><p><strong>菠萝</strong>：菠萝含有较多的碳水化合物，尤其是其天然糖分。</p></li><li><p><strong>苹果</strong>：苹果的碳水化合物含量适中，尤其是甜度较高的品种。</p></li><li><p><strong>梨</strong>：梨的碳水化合物含量也较高，尤其是成熟的梨。</p></li><li><p><strong>柿子</strong>：柿子的碳水化合物含量较高，尤其是甜柿。</p></li><li><p><strong>榴莲</strong>：榴莲不仅热量高，碳水化合物含量也较高。</p></li></ol><p>这些水果虽然富含碳水化合物，但同时也含有丰富的维生素、矿物质和膳食纤维，适量食用对健康有益。不过，对于需要控制碳水化合物摄入的人群（如糖尿病患者），应注意适量食用。</p><h1 id="膳食纤维"><a href="#膳食纤维" class="headerlink" title="膳食纤维"></a>膳食纤维</h1><p>膳食纤维对人体健康至关重要，它有助于维持肠道健康、降低胆固醇水平、控制体重等。<br>富含膳食纤维的水果:</p><ol><li><strong>牛油果</strong>：虽然牛油果含有较高的脂肪和热量，但其膳食纤维含量也很高，尤其是未成熟的绿色部分。</li><li><strong>番石榴</strong>：番石榴是一种热带水果，其皮和果实都富含膳食纤维。</li><li><strong>黑莓</strong>：黑莓不仅含有丰富的维生素C和抗氧化剂，还富含膳食纤维。</li><li><strong>梨</strong>：梨的果肉中含有较多的膳食纤维，特别是成熟的梨。</li><li><strong>苹果</strong>：苹果是膳食纤维的良好来源，尤其是带皮的苹果。</li><li><strong>无花果</strong>：无花果的膳食纤维含量较高，尤其是干无花果。</li><li><strong>枣</strong>：枣类水果（如红枣）的膳食纤维含量也相对较高。</li><li><strong>菠萝</strong>：菠萝的果肉中含有一部分的膳食纤维。</li><li><strong>芒果</strong>：芒果的果肉中也含有一定的膳食纤维。</li></ol><p>这些水果在提供丰富营养的同时，也能帮助增加膳食纤维的摄入量，对维护肠道健康非常有益。不过，对于需要控制膳食纤维摄入的人群（如高血脂患者），应注意适量食用。</p><h1 id="维生素A"><a href="#维生素A" class="headerlink" title="维生素A"></a>维生素A</h1><p>维生素A对人体健康至关重要，它有助于维持皮肤和眼睛的健康。<br>富含维生素A的水果:<br>富含维生素A的水果包括：</p><ol><li><strong>芒果</strong>：芒果是维生素A的丰富来源，尤其是成熟的芒果。</li><li><strong>哈密瓜</strong>：哈密瓜含有大量的维生素A，对眼睛健康特别有益。</li><li><strong>杏</strong>：杏子不仅美味，还富含维生素A。</li><li><strong>木瓜</strong>：木瓜中的维生素A含量较高，有助于皮肤和眼睛健康。</li><li><strong>柿子</strong>：柿子也是维生素A的良好来源，尤其是成熟的柿子。</li></ol><p>这些水果不仅美味，还能帮助补充维生素A，对维持皮肤和眼睛健康非常有益。</p><h1 id="胡萝卜素"><a href="#胡萝卜素" class="headerlink" title="胡萝卜素"></a>胡萝卜素</h1><p>富含胡萝卜素的水果包括：</p><ol><li><strong>芒果</strong>：芒果不仅富含维生素A，还含有丰富的胡萝卜素，有助于保护视力和皮肤健康。</li><li><strong>哈密瓜</strong>：哈密瓜中的胡萝卜素含量较高，对眼睛和免疫系统有益。</li><li><strong>杏</strong>：杏子中的胡萝卜素有助于维持皮肤和眼睛的健康。</li><li><strong>木瓜</strong>：木瓜不仅含有维生素A，还富含胡萝卜素，对皮肤和眼睛健康有显著效果。</li><li><strong>柿子</strong>：柿子中的胡萝卜素含量丰富，有助于增强免疫力和保护视力。</li></ol><p>这些水果不仅美味，还能帮助补充胡萝卜素，对维持皮肤和眼睛健康非常有益。</p><h1 id="维生素B1"><a href="#维生素B1" class="headerlink" title="维生素B1"></a>维生素B1</h1><p>维生素B1对人体健康至关重要，它有助于维持骨骼健康、抗氧化作用、抗癌作用。<br>富含维生素B1的水果:</p><ol><li><strong>橙子</strong>：橙子不仅富含维生素C，还含有一定量的维生素B1，有助于维持神经系统健康。</li><li><strong>香蕉</strong>：香蕉是维生素B1的良好来源，有助于能量代谢和神经系统功能。</li><li><strong>菠萝</strong>：菠萝中含有维生素B1，有助于消化和免疫系统的健康。</li><li><strong>草莓</strong>：草莓不仅美味，还含有维生素B1，有助于维持心脏和神经系统的健康。</li><li><strong>猕猴桃</strong>：猕猴桃富含维生素B1，有助于提高免疫力和促进新陈代谢。</li></ol><p>这些水果不仅美味，还能帮助补充维生素B1，对维持身体健康非常有益。</p><h1 id="维生素B2"><a href="#维生素B2" class="headerlink" title="维生素B2"></a>维生素B2</h1><p> 维生素B2对人体健康至关重要，它有助于维持骨骼健康、抗氧化作用、抗癌作用。<br> 富含维生素B2的水果:<br> 富含维生素B2的水果包括：</p><ol><li><strong>鳄梨（牛油果）</strong>：鳄梨不仅富含健康脂肪，还含有丰富的维生素B2，有助于维持皮肤和眼睛健康。</li><li><strong>香蕉</strong>：香蕉除了是维生素B1的良好来源外，也含有一定量的维生素B2，有助于能量代谢和细胞功能。</li><li><strong>猕猴桃</strong>：猕猴桃不仅富含维生素C和B1，还含有维生素B2，有助于提高免疫力和促进新陈代谢。</li><li><strong>草莓</strong>：草莓不仅美味，还含有维生素B2，有助于维持皮肤和眼睛健康。</li><li><strong>橙子</strong>：橙子不仅富含维生素C，还含有一定量的维生素B2，有助于维持皮肤和眼睛健康。</li></ol><p>这些水果不仅美味，还能帮助补充维生素B2，对维持身体健康非常有益。</p><p>水果主要是上述的一些营养成分，还有一些烟酸，维生素c,钙的以后再去做整理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热量&quot;&gt;&lt;a href=&quot;#热量&quot; class=&quot;headerlink&quot; title=&quot;热量&quot;&gt;&lt;/a&gt;热量&lt;/h1&gt;&lt;h2 id=&quot;热量有三大来源&quot;&gt;&lt;a href=&quot;#热量有三大来源&quot; class=&quot;headerlink&quot; title=&quot;热量有三大来源&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="植物" scheme="https://joeforkyou.github.io/categories/%E6%A4%8D%E7%89%A9/"/>
    
    
    <category term="植物" scheme="https://joeforkyou.github.io/tags/%E6%A4%8D%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>字符串相等</title>
    <link href="https://joeforkyou.github.io/2024/12/15/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
    <id>https://joeforkyou.github.io/2024/12/15/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</id>
    <published>2024-12-15T02:55:20.000Z</published>
    <updated>2024-12-15T02:55:47.224Z</updated>
    
    <content type="html"><![CDATA[<p>在C和C++中判断字符串是否相等的方法有所不同。</p><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p>在C语言中，字符串是以字符数组的形式存储的，比较字符串是否相等通常使用 <code>strcmp</code> 函数。该函数在 <code>&lt;string.h&gt;</code> 头文件中声明。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串相等\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串不相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h1><p>在C++中，可以使用标准库中的 <code>std::string</code> 类来处理字符串，这提供了更方便和直观的方法来比较字符串。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在C中使用 <code>strcmp</code> 函数比较字符串。</li><li>在C++中可以直接使用 <code>==</code> 运算符比较 <code>std::string</code> 对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C和C++中判断字符串是否相等的方法有所不同。&lt;/p&gt;
&lt;h1 id=&quot;C语言&quot;&gt;&lt;a href=&quot;#C语言&quot; class=&quot;headerlink&quot; title=&quot;C语言&quot;&gt;&lt;/a&gt;C语言&lt;/h1&gt;&lt;p&gt;在C语言中，字符串是以字符数组的形式存储的，比较字符串是否相等通常使</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>AndroidBp</title>
    <link href="https://joeforkyou.github.io/2024/12/15/Android/AndroidBp/"/>
    <id>https://joeforkyou.github.io/2024/12/15/Android/AndroidBp/</id>
    <published>2024-12-15T02:30:39.000Z</published>
    <updated>2024-12-15T02:39:51.275Z</updated>
    
    <content type="html"><![CDATA[<p>Android.bp 是 Android Build System 中使用的一种构建描述文件格式，类似于 Makefile，但以更简洁的方式定义构建模块。以下是一个基本的 Android.bp 文件示例，展示了其基本语法和用法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个库模块</span><br><span class="line">cc_library &#123;</span><br><span class="line">    name: &quot;my_library&quot;,  # 模块名称</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;file1.cpp&quot;,      # 源文件</span><br><span class="line">        &quot;file2.cpp&quot;,</span><br><span class="line">    ],</span><br><span class="line">    cflags: [            # 编译选项</span><br><span class="line">        &quot;-Wall&quot;,</span><br><span class="line">        &quot;-Werror&quot;,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [      # 依赖的共享库</span><br><span class="line">        &quot;liblog&quot;,       # 依赖的库名称</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义一个可执行程序模块</span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;my_executable&quot;,  # 执行文件名称</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;main.cpp&quot;,           # 主源文件</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [</span><br><span class="line">        &quot;my_library&quot;,        # 依赖的静态库</span><br><span class="line">    ],</span><br><span class="line">    cflags: [</span><br><span class="line">        &quot;-O2&quot;,               # 优化选项</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义一个测试模块</span><br><span class="line">cc_test &#123;</span><br><span class="line">    name: &quot;my_library_test&quot;,  # 测试模块名称</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;my_library_test.cpp&quot;,  # 测试源文件</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [</span><br><span class="line">        &quot;my_library&quot;,           # 被测试的库</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ol><li><strong>模块类型</strong>：可以定义多种类型的模块，比如 <code>cc_library</code>（C++库），<code>cc_binary</code>（可执行程序），<code>cc_test</code>（测试）等。</li><li><strong>name</strong>：每个模块都有一个唯一的名称。</li><li><strong>srcs</strong>：指定源文件列表，可以是相对路径。</li><li><strong>cflags</strong>：编译标志，用于设置编译时的选项。</li><li><strong>shared_libs&#x2F;static_libs</strong>：分别指定依赖的共享库和静态库。</li></ol><p>了解这些基本组件后，你可以根据自己的项目需求，进一步扩展和修改 Android.bp 文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android.bp 是 Android Build System 中使用的一种构建描述文件格式，类似于 Makefile，但以更简洁的方式定义构建模块。以下是一个基本的 Android.bp 文件示例，展示了其基本语法和用法。&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="Android" scheme="https://joeforkyou.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://joeforkyou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>CPP生成so</title>
    <link href="https://joeforkyou.github.io/2024/12/14/CPP/CPP%E7%94%9F%E6%88%90so/"/>
    <id>https://joeforkyou.github.io/2024/12/14/CPP/CPP%E7%94%9F%E6%88%90so/</id>
    <published>2024-12-14T09:53:22.000Z</published>
    <updated>2024-12-14T09:53:55.371Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中生成共享库（.so文件）并使用它，涉及到以下几个步骤。假设我们要创建一个简单的共享库并在一个主程序中调用它。</p><h1 id="1-创建共享库"><a href="#1-创建共享库" class="headerlink" title="1: 创建共享库"></a>1: 创建共享库</h1><ol><li><strong>创建头文件</strong>（例如 <code>example.h</code>）:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建实现文件</strong>（例如 <code>example.cpp</code>）:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>编译生成共享库</strong>:</li></ol><p>使用以下命令编译 <code>example.cpp</code> 为共享库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared example.cpp -o libexample.so</span><br></pre></td></tr></table></figure><ul><li><code>-fPIC</code> 表示生成位置无关代码（Position Independent Code），适合共享库。</li><li><code>-shared</code> 指定生成共享库。</li></ul><h1 id="2-使用共享库"><a href="#2-使用共享库" class="headerlink" title="2: 使用共享库"></a>2: 使用共享库</h1><ol><li><strong>创建主程序文件</strong>（例如 <code>main.cpp</code>）:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>编译并链接共享库</strong>:</li></ol><p>使用以下命令编译 <code>main.cpp</code> 并链接到生成的共享库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -L. -lexample -o main</span><br></pre></td></tr></table></figure><ul><li><code>-L.</code> 指定当前目录为查找库的目录。</li><li><code>-lexample</code> 指定链接名为 <code>libexample.so</code> 的库（省略 <code>lib</code> 和 <code>.so</code>）。</li></ul><ol start="3"><li><strong>运行程序</strong>:</li></ol><p>在运行时，可能需要设置 <code>LD_LIBRARY_PATH</code> 环境变量，以便程序能够找到共享库。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，你可以成功创建并使用一个简单的共享库。在实际应用中，可能会有更多的复杂性，比如处理多个源文件，或者使用构建工具（如 CMake）来管理构建流程。希望这个示例对你有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C++中生成共享库（.so文件）并使用它，涉及到以下几个步骤。假设我们要创建一个简单的共享库并在一个主程序中调用它。&lt;/p&gt;
&lt;h1 id=&quot;1-创建共享库&quot;&gt;&lt;a href=&quot;#1-创建共享库&quot; class=&quot;headerlink&quot; title=&quot;1: 创建共享库&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>字符串包含</title>
    <link href="https://joeforkyou.github.io/2024/12/14/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB/"/>
    <id>https://joeforkyou.github.io/2024/12/14/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB/</id>
    <published>2024-12-14T06:23:04.000Z</published>
    <updated>2024-12-14T06:24:06.736Z</updated>
    
    <content type="html"><![CDATA[<p>在实际项目应用中我们经常要去做一些字符相关的判断.<br>比较常用的是判断字符串是否包含另外一个字符串的内容<br>在cpp中有不少可以直接拿来使用的<br>直接添加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后写个判断的函数即可如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">const</span> std::string&amp; substr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">find</span>(substr) != std::string::npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是判断str是否包含substr,如果包含则返回true,否则返回false.<br>完整的使用demo如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">const</span> std::string&amp; substr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">find</span>(substr) != std::string::npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    std::string substr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contains</span>(str, substr)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串包含子字符串&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符串不包含子字符串&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c中我们没有这些类的概念，可以参考如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(str, substr) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* substr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contains</span>(str, substr)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串包含子字符串\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串不包含子字符串\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在实际项目应用中我们经常要去做一些字符相关的判断.&lt;br&gt;比较常用的是判断字符串是否包含另外一个字符串的内容&lt;br&gt;在cpp中有不少可以直接拿来使用的&lt;br&gt;直接添加头文件&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【CPP基础】【四】【申请释放】</title>
    <link href="https://joeforkyou.github.io/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_4_%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE/"/>
    <id>https://joeforkyou.github.io/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_4_%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE/</id>
    <published>2024-11-24T13:30:36.000Z</published>
    <updated>2024-11-24T13:55:14.748Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，<code>new</code>和<code>delete</code>是用于动态内存分配和释放的运算符。它们与堆内存相关，允许程序在运行时分配和管理内存。</p><h1 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h1><p><code>new</code>运算符用于在堆上分配内存。它可以用于分配单个对象或对象数组，并返回指向所分配内存的指针。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol><li><p><strong>分配单个对象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure><p>这行代码在堆上分配一个<code>MyClass</code>对象，并调用其构造函数。返回值是指向这个对象的指针。</p></li><li><p><strong>分配数组：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这里在堆上分配了一个包含10个整数的数组，返回指向数组首元素的指针。</p></li><li><p><strong>初始化：</strong><br><code>new</code>还可以用来初始化对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); <span class="comment">// 分配内存并将其初始化为5</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="delete-运算符"><a href="#delete-运算符" class="headerlink" title="delete 运算符"></a>delete 运算符</h1><p><code>delete</code>运算符用于释放之前使用<code>new</code>分配的内存。它可以释放单个对象或对象数组。</p><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><ol><li><p><strong>释放单个对象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj;</span><br></pre></td></tr></table></figure><p>这行代码会调用<code>obj</code>指向的对象的析构函数，并释放该对象占用的内存。</p></li><li><p><strong>释放数组：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure><p>这里使用<code>delete[]</code>来释放使用<code>new[]</code>分配的数组。需要注意，使用<code>delete[]</code>和<code>delete</code>不可以互换。</p></li></ol><h2 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h2><p>在释放内存后，将指针设置为<code>nullptr</code>是一个良好的编程习惯。这可以防止悬挂指针问题，即指针仍然指向已经被释放的内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p><strong>配对使用：</strong> 每个由<code>new</code>分配的内存都应该用<code>delete</code>释放，每个<code>new[]</code>分配的数组都应该用<code>delete[]</code>释放，以避免内存泄漏。</p></li><li><p><strong>避免重复释放：</strong> 在释放指针后，应该清楚指针的状态，避免重复释放同一内存区域。</p></li><li><p><strong>自定义析构函数：</strong> 如果类中有动态内存分配的成员，确保在类的析构函数中适当释放这些资源，避免内存泄漏。</p></li></ol><p>通过正确使用<code>new</code>和<code>delete</code>，可以有效地管理C++程序中的动态内存。<br>详细demo代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">/* 构造函数代码 */</span> &#125;</span><br><span class="line">    <span class="comment">// 如果需要，可以添加析构函数、其他成员函数和数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;        <span class="comment">// 为一个整数分配内存</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];    <span class="comment">// 为一个整数数组分配内存</span></span><br><span class="line"></span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();  <span class="comment">// 调用构造函数</span></span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptr;    <span class="comment">// 释放单个对象 这边释放后ptr指向的内存区域将被释放，,详细debug看ptr指向的值以及变成其他值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr;  <span class="comment">// 释放数组</span></span><br><span class="line">    ptr = <span class="literal">nullptr</span>; <span class="comment">// 防止悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果MyClass有自定义的析构函数，也应该在此处释放obj</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    obj = <span class="literal">nullptr</span>; <span class="comment">// 防止悬挂指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C++中，&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;是用于动态内存分配和释放的运算符。它们与堆内存相关，允许程序在运行时分配和管理内存。&lt;/p&gt;
&lt;h1 id=&quot;new-运算符&quot;&gt;&lt;a href=&quot;#new-运算符&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>字符串常见操作</title>
    <link href="https://joeforkyou.github.io/2024/11/24/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>https://joeforkyou.github.io/2024/11/24/CPP/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</id>
    <published>2024-11-24T10:21:23.000Z</published>
    <updated>2024-11-24T10:22:12.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用字符串操作函数"><a href="#常用字符串操作函数" class="headerlink" title="常用字符串操作函数"></a>常用字符串操作函数</h1><ol><li><p>**<code>strcpy</code>**：用于将源字符串复制到目标字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(dest, src);  <span class="comment">// dest 现在包含 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strncpy</code>**：用于复制指定长度的源字符串到目标字符串，防止缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="number">5</span>);  <span class="comment">// dest 现在包含 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strlen</code>**：用于计算字符串的长度（不包括终止字符 <code>\0</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> length = <span class="built_in">strlen</span>(str);  <span class="comment">// length 现在是 5</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strcat</code>**：用于将源字符串连接到目标字符串的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(dest, src);  <span class="comment">// dest 现在包含 &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strncat</code>**：用于将指定长度的源字符串连接到目标字符串的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strncat</span>(dest, src, <span class="number">3</span>);  <span class="comment">// dest 现在包含 &quot;Hello Wo&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strcmp</code>**：用于比较两个字符串。如果相等返回0，如果第一个字符串小于第二个字符串返回负数，大于返回正数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(str1, str2);  <span class="comment">// result 为 0</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strncmp</code>**：用于比较指定长度的两个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;abcdx&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strncmp</span>(str1, str2, <span class="number">4</span>);  <span class="comment">// result 为 0 (前4个字符相等)</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strchr</code>**：用于查找字符在字符串中第一次出现的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;e&#x27;</span>);  <span class="comment">// ptr 指向 &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>strstr</code>**：用于查找一个字符串在另一个字符串中首次出现的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> haystack[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> needle[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr = <span class="built_in">strstr</span>(haystack, needle);  <span class="comment">// ptr 指向 &quot;World!&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些函数是处理C语言字符串时非常有用的工具，掌握它们可以让你的字符串操作更加得心应手。注意在使用这些函数时，要确保目标字符数组够大，以防止发生缓冲区溢出。</p><h1 id="字符串相等判断"><a href="#字符串相等判断" class="headerlink" title="字符串相等判断"></a>字符串相等判断</h1><p>在C++中，判断字符串相等一般使用 <code>std::string</code> 类的 <code>==</code> 运算符或者 <code>compare</code> 方法。以下是这两种方法的示例：</p><ol><li><p><strong>使用 <code>==</code> 运算符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str3 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str1 == str3) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>compare</code> 方法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str3 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str<span class="number">1.</span><span class="built_in">compare</span>(str2) == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str2 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str<span class="number">1.</span><span class="built_in">compare</span>(str3) == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 和 str3 不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在这两种方法中，使用 <code>==</code> 运算符更为简洁和直观，因此在日常编程中更为常用。 <code>compare</code> 方法则提供了更丰富的比较功能，例如可以用于比较字符串的部分内容和不同的比较规则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用字符串操作函数&quot;&gt;&lt;a href=&quot;#常用字符串操作函数&quot; class=&quot;headerlink&quot; title=&quot;常用字符串操作函数&quot;&gt;&lt;/a&gt;常用字符串操作函数&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;**&lt;code&gt;strcpy&lt;/code&gt;**：用于将源字符串复制</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>AndroidMk基础</title>
    <link href="https://joeforkyou.github.io/2024/11/24/Android/AndroidMk%E5%9F%BA%E7%A1%80/"/>
    <id>https://joeforkyou.github.io/2024/11/24/Android/AndroidMk%E5%9F%BA%E7%A1%80/</id>
    <published>2024-11-24T07:49:34.000Z</published>
    <updated>2024-11-24T07:55:10.404Z</updated>
    
    <content type="html"><![CDATA[<p>Android.mk 文件是 Android 系统中用于描述构建过程的文件，主要用在 Android NDK（Native Development Kit）中。它们是用来定义模块的构建规则和依赖关系。以下是 Android.mk 文件的基础和常用语法：</p><h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><ol><li><p><strong>变量定义</strong>：</p><ul><li>可以使用 <code>:=</code>、<code>+=</code> 等方式定义变量。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>模块类型</strong>：</p><ul><li>使用 <code>LOCAL_MODULE</code> 来指定模块名称。</li><li>使用 <code>include</code> 来包含其他 mk 文件。</li></ul></li><li><p><strong>模块的属性</strong>：</p><ul><li><code>LOCAL_SRC_FILES</code>：指定源文件。</li><li><code>LOCAL_C_INCLUDES</code>：指定 C&#x2F;C++ 头文件的搜索路径。</li><li><code>LOCAL_LDLIBS</code>：链接时需要的库。</li></ul></li></ol><h1 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h1><ol><li><p><strong>定义静态库</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := my_static_lib</span><br><span class="line">LOCAL_SRC_FILES := my_static_lib.cpp</span><br><span class="line">LOCAL_C_INCLUDES := <span class="variable">$(LOCAL_PATH)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义动态库</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := my_shared_lib</span><br><span class="line">LOCAL_SRC_FILES := my_shared_lib.cpp</span><br><span class="line">LOCAL_LDLIBS := -llog</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义可执行文件</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := my_executable</span><br><span class="line">LOCAL_SRC_FILES := main.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>清理变量</strong>：</p><ul><li>使用 <code>include $(CLEAR_VARS)</code> 可以清除之前定义的变量，避免冲突。</li></ul></li><li><p><strong>依赖关系</strong>：</p><ul><li>可以使用 <code>LOCAL_WHOLE_STATIC_LIBRARIES</code> 来定义静态库的依赖。</li></ul></li></ol><h1 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h1><ul><li><p><strong>链接库</strong>：</p><ul><li><code>LOCAL_LDLIBS</code> 用于定义需要链接的库，例如 <code>-lc</code>、<code>-lm</code>等。</li></ul></li><li><p><strong>编译选项</strong>：</p><ul><li>还可以使用 <code>LOCAL_CPPFLAGS</code> 和 <code>LOCAL_CFLAGS</code> 来添加编译选项。</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android.mk 文件通过模块定义和构建规则来构建 C&#x2F;C++ 代码。在编写文件时，需要注意规范和模块间的依赖关系。随着 Android 的发展，渐渐地 CMake 也被广泛使用作为构建系统，但 Android.mk 仍然是一个重要的部分，特别是在 NDK 项目中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android.mk 文件是 Android 系统中用于描述构建过程的文件，主要用在 Android NDK（Native Development Kit）中。它们是用来定义模块的构建规则和依赖关系。以下是 Android.mk 文件的基础和常用语法：&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="Android" scheme="https://joeforkyou.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://joeforkyou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【CPP基础】【三】【继承多态封装】</title>
    <link href="https://joeforkyou.github.io/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_3_%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%B0%81%E8%A3%85/"/>
    <id>https://joeforkyou.github.io/2024/11/24/CPP/CPP%E5%9F%BA%E7%A1%80_3_%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%B0%81%E8%A3%85/</id>
    <published>2024-11-24T05:33:54.000Z</published>
    <updated>2024-11-24T05:36:14.312Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，继承、多态和封装是面向对象编程的三大基本特性。下面我将分别介绍这三者，并给出相应的示例。</p><h1 id="1-封装（Encapsulation）"><a href="#1-封装（Encapsulation）" class="headerlink" title="1. 封装（Encapsulation）"></a>1. 封装（Encapsulation）</h1><p>封装是指将数据（成员变量）和操作数据的方法（成员函数）放在一起，形成一个类，通过访问控制来限制对类内部数据的直接访问，从而保护数据的完整性。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> balance; <span class="comment">// 私有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">double</span> initialBalance) &#123;</span><br><span class="line">        balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BankAccount <span class="title">account</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    account.<span class="built_in">deposit</span>(<span class="number">500</span>);</span><br><span class="line">    account.<span class="built_in">withdraw</span>(<span class="number">200</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前余额: &quot;</span> &lt;&lt; account.<span class="built_in">getBalance</span>() &lt;&lt; endl; <span class="comment">// 输出: 当前余额: 1300</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-继承（Inheritance）"><a href="#2-继承（Inheritance）" class="headerlink" title="2. 继承（Inheritance）"></a>2. 继承（Inheritance）</h1><p>继承是指一个类可以从另一个类中继承成员变量和方法，从而实现代码的重用。子类（派生类）可以扩展或重写父类（基类）的行为。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物发声&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123; <span class="comment">// Dog类继承自Animal类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写父类的方法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal animal;</span><br><span class="line">    animal.<span class="built_in">speak</span>(); <span class="comment">// 输出: 动物发声</span></span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.<span class="built_in">speak</span>(); <span class="comment">// 输出: 汪汪</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-多态（Polymorphism）"><a href="#3-多态（Polymorphism）" class="headerlink" title="3. 多态（Polymorphism）"></a>3. 多态（Polymorphism）</h1><p>多态是指同一个操作可以作用于不同的对象上，不同的对象可以根据其具体类型表现出不同的行为。C++中的多态通常通过虚函数实现。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制形状&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写父类的虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制圆形&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写父类的虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制正方形&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(Shape* shape)</span> </span>&#123; <span class="comment">// 接受基类指针</span></span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>(); <span class="comment">// 调用虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Square square;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(&amp;circle); <span class="comment">// 输出: 绘制圆形</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;square); <span class="comment">// 输出: 绘制正方形</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>封装通过访问控制保护数据，提供了安全性。</li><li>继承实现了代码的复用，允许子类扩展父类的功能。</li><li>多态让程序更加灵活，同一操作可以作用于多个类型，增强了代码的可扩展性和可维护性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C++中，继承、多态和封装是面向对象编程的三大基本特性。下面我将分别介绍这三者，并给出相应的示例。&lt;/p&gt;
&lt;h1 id=&quot;1-封装（Encapsulation）&quot;&gt;&lt;a href=&quot;#1-封装（Encapsulation）&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Kernel加时间戳</title>
    <link href="https://joeforkyou.github.io/2024/11/18/Android/Kernel%E5%8A%A0%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <id>https://joeforkyou.github.io/2024/11/18/Android/Kernel%E5%8A%A0%E6%97%B6%E9%97%B4%E6%88%B3/</id>
    <published>2024-11-18T14:23:59.000Z</published>
    <updated>2024-11-18T14:31:21.879Z</updated>
    
    <content type="html"><![CDATA[<hr><p>添加对应的头文件和包装函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ktime.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">thermal_get_current_time_ms</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec64</span> t;</span><br><span class="line">    <span class="built_in">ktime_get_ts64</span>(&amp;t);</span><br><span class="line">    temp = (((<span class="type">long</span> <span class="type">long</span>) t.tv_sec) * <span class="number">1000000</span> + (<span class="type">long</span>)t.tv_nsec/<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> (temp/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c中static 受到编译器的影响 禁止使用long long类型.所以debug的时候还是去掉static的申明.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> time_diff,start_timestamp,end_timestamp;</span><br><span class="line"></span><br><span class="line">start_timestamp = <span class="built_in">thermal_get_current_time_ms</span>();</span><br><span class="line"></span><br><span class="line">end_timestamp = <span class="built_in">thermal_get_current_time_ms</span>();</span><br><span class="line">time_diff = end_timestamp - start_timestamp;</span><br><span class="line"><span class="built_in">printk</span>(<span class="string">&quot;[time] timestamp_diff = %lld ms&quot;</span>,time_diff);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;添加对应的头文件和包装函数:&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="Android" scheme="https://joeforkyou.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://joeforkyou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【CPP基础】【二】【设计模式】</title>
    <link href="https://joeforkyou.github.io/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_2_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1/"/>
    <id>https://joeforkyou.github.io/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_2_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_1/</id>
    <published>2024-11-17T13:58:49.000Z</published>
    <updated>2024-11-17T14:00:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我其实是想把指针当做我学习的第二部分，奈何指针很麻烦，智能指针一时半会也说不完.<br>于是先整理下设计模式<br>因为我在实际项目中开发用到不少的工厂模式，就先以工厂模式为主要的研究内容开始进行复习和拓展。</p><p>设计模式是一种在软件开发中常用的解决方案，旨在帮助开发者解决常见问题，提高软件的可维护性、可重用性和可扩展性。设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。</p><ol><li><p><strong>创建型模式</strong>：这些模式主要关注对象的创建机制，以适应不同的需求和场景。</p><ul><li><strong>单例模式</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>工厂方法模式</strong>：定义一个创建对象的接口，让子类决定实例化哪一个类。</li><li><strong>抽象工厂模式</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</li></ul></li><li><p><strong>结构型模式</strong>：这些模式主要关注对象之间的组合关系。</p><ul><li><strong>适配器模式</strong>：将一个类的接口转换成客户端期望的另一个接口，从而使不兼容的接口能够合作。</li><li><strong>装饰者模式</strong>：动态地给一个对象添加额外的职责，就增加功能来说，这种模式比生成子类更为灵活。</li><li><strong>代理模式</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li></ul></li><li><p><strong>行为型模式</strong>：这些模式主要关注对象之间的交互和职责分配。</p><ul><li><strong>观察者模式</strong>：定义了一种一对多的依赖关系，使得一当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。</li><li><strong>策略模式</strong>：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换，策略模式让算法的变化独立于使用算法的客户。</li><li><strong>命令模式</strong>：将一个请求封装成一个对象，从而使你能够使用不同的请求、队列或日志请求，并支持可撤销的操作。</li></ul></li></ol><p>设计模式是软件开发的宝贵经验积累，通过运用这些模式，可以有效地解决许多普遍存在的问题，使代码更加简洁、清晰和易于维护。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>这个在我是实际开发中用到的比较多</p><p>单例模式是一种创建型设计模式，它的主要目的是确保一个类只有一个实例，并提供一个全局访问点。这种模式在需要控制对某些资源的访问时尤其有用，比如数据库连接或配置管理等。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li><strong>唯一性</strong>：单例模式确保任何时候都只有一个类的实例存在。</li><li><strong>全局访问</strong>：提供一个静态方法，让用户可以获取到这个唯一实例。</li><li><strong>延迟初始化</strong>：可以实现懒汉式单例，只有在第一次使用时才创建实例。</li></ol><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>单例模式的实现方式有多种，以下是最常见的几种：</p><ol><li><p><strong>懒汉式</strong>：</p><ul><li>在需要时才创建实例，在多线程环境下需要加锁以保证线程安全。</li><li>完整的代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 加锁以保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>饿汉式</strong>：</p><ul><li>在类加载时就创建实例，线程安全，但不支持延迟加载。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态方法来获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 在第一次调用时创建实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值运算符，以防意外复制</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例对象并调用方法</span></span><br><span class="line">    Singleton::<span class="built_in">getInstance</span>().<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>双重检查锁定</strong>：</p><ul><li>在懒汉式的基础上，使用双重检查加锁，减少了同步的性能开销。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态方法来获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 首次检查</span></span><br><span class="line">        <span class="keyword">if</span> (!instance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对共享资源加锁</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="comment">// 再次检查</span></span><br><span class="line">            <span class="keyword">if</span> (!instance)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">// 创建实例</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值运算符，以防意外复制</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton *instance; <span class="comment">// 单例指针</span></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;   <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量初始化</span></span><br><span class="line">Singleton *Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例对象并调用方法</span></span><br><span class="line">    Singleton::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">someMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li>配置管理：一个应用程序通常只需要一个配置对象来管理配置参数。</li><li>日志记录：通常使用单例模式来管理日志记录，以确保日志的统一性。</li><li>数据库连接或线程池：避免创建多个连接，节省资源。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>单例模式通过控制实例的创建，提供了对共享资源的管理，避免了资源浪费和状态不一致的问题。在实际应用中，选择合适的实现方式以满足线程安全、性能和资源利用的需求非常重要。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是一种常见的设计模式，其主要目的是通过创建一个工厂来集中创建对象。工厂模式的主要类型包括：</p><ol><li><p><strong>简单工厂模式</strong>：</p><ul><li>定义一个工厂类，根据传入的参数决定创建哪一种产品类的实例。虽然简单工厂模式本身不是GoF设计模式，但它在很多项目中得到了广泛应用。</li></ul></li><li><p><strong>工厂方法模式</strong>：</p><ul><li>定义一个接口用于创建对象，但将实例化的工作推迟到子类中。每个子类都实现了自己的工厂方法，负责创建特定类型的对象。</li></ul></li><li><p><strong>抽象工厂模式</strong>：</p><ul><li>提供一个接口，用于创建一系列相关或依赖的对象，而不需要指定具体类。这种模式通常用于创建一组相关产品，适用于产品族的设计。</li></ul></li><li><p><strong>静态工厂方法</strong>：</p><ul><li>工厂方法被定义为静态方法，可以在没有创建工厂类实例的情况下调用。通常用于简单的对象创建操作。</li></ul></li></ol><p>这些工厂模式各有优缺点，根据具体需求选择合适的模式可以提高代码的可维护性和可扩展性。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>简单工厂模式使用一个工厂类根据给定的信息返回不同类型的对象。这个模式不推荐用于复杂的系统，因为它违反了开闭原则，但对于简单的应用场景非常有用。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Product* <span class="title">createProduct</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;B&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product* productA = SimpleFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    productA-&gt;<span class="built_in">use</span>();</span><br><span class="line">    <span class="keyword">delete</span> productA;</span><br><span class="line"></span><br><span class="line">    Product* productB = SimpleFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    productB-&gt;<span class="built_in">use</span>();</span><br><span class="line">    <span class="keyword">delete</span> productB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h3><p>工厂方法模式定义一个用于创建产品的接口，但由子类来决定实例化哪一个产品。这样可以更好地遵循开闭原则。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">factoryMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product* product = <span class="built_in">factoryMethod</span>();</span><br><span class="line">        product-&gt;<span class="built_in">use</span>();</span><br><span class="line">        <span class="keyword">delete</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorA</span> : <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">factoryMethod</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorB</span> : <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">factoryMethod</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Creator* creatorA = <span class="keyword">new</span> <span class="built_in">ConcreteCreatorA</span>();</span><br><span class="line">    creatorA-&gt;<span class="built_in">someOperation</span>();</span><br><span class="line">    <span class="keyword">delete</span> creatorA;</span><br><span class="line"></span><br><span class="line">    Creator* creatorB = <span class="keyword">new</span> <span class="built_in">ConcreteCreatorB</span>();</span><br><span class="line">    creatorB-&gt;<span class="built_in">someOperation</span>();</span><br><span class="line">    <span class="keyword">delete</span> creatorB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h3><p>抽象工厂模式提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定具体的类。这种模式非常适合用于需要创建多个不同类型的产品的场景。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> : <span class="keyword">public</span> ProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> : <span class="keyword">public</span> ProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品A2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;使用产品B2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductA* <span class="title">createProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductB* <span class="title">createProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ProductB* <span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ProductB* <span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* factory1 = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">    ProductA* productA1 = factory1-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">    ProductB* productB1 = factory1-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">    </span><br><span class="line">    productA1-&gt;<span class="built_in">use</span>();</span><br><span class="line">    productB1-&gt;<span class="built_in">use</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> productA1;</span><br><span class="line">    <span class="keyword">delete</span> productB1;</span><br><span class="line">    <span class="keyword">delete</span> factory1;</span><br><span class="line"></span><br><span class="line">    AbstractFactory* factory2 = <span class="keyword">new</span> <span class="built_in">ConcreteFactory2</span>();</span><br><span class="line">    ProductA* productA2 = factory2-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">    ProductB* productB2 = factory2-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">    </span><br><span class="line">    productA2-&gt;<span class="built_in">use</span>();</span><br><span class="line">    productB2-&gt;<span class="built_in">use</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> productA2;</span><br><span class="line">    <span class="keyword">delete</span> productB2;</span><br><span class="line">    <span class="keyword">delete</span> factory2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>简单工厂模式</strong>适合用于简单的对象创建，便于使用和管理。</li><li><strong>工厂方法模式</strong>通过子类化来实现扩展功能，更符合面向对象的原则。</li><li><strong>抽象工厂模式</strong>能够创建一系列相关的产品，适用性更广。</li></ul><p>这些工厂模式在软件开发中非常常见，尤其在需要解耦对象创建与使用逻辑时，能够有效提高代码的可维护性和可扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我其实是想把指针当做我学习的第二部分，奈何指针很麻烦，智能指针一时半会也说不完.&lt;br&gt;于是先整理下设计模式&lt;br&gt;因为我在实际项目中开发用</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【CPP基础】【一】</title>
    <link href="https://joeforkyou.github.io/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_1/"/>
    <id>https://joeforkyou.github.io/2024/11/17/CPP/CPP%E5%9F%BA%E7%A1%80_1/</id>
    <published>2024-11-17T12:06:49.000Z</published>
    <updated>2024-11-17T14:00:08.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这是对c++的泛式编程的梳理<br>c++的基础就那边点,无非就是流程控制和对象继承等<br>剩下的就是STL的内容。<br>所以我觉得还是有必要深究下来，一来就是我这个人的性格是这样的.<br>学习链接:<br><a href="https://www.learncpp.com/">https://www.learncpp.com/</a></p><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整型: int, long, long long</li><li>浮点型: float, double, long double</li><li>字符型: char, wchar_t</li><li>布尔型: bool</li><li>指针型: pointer, reference</li><li>数组型: array</li><li>枚举型: enum</li><li>结构体型: struct</li><li>类型: class</li></ul><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>布尔型</td><td>bool</td></tr><tr><td>字符型</td><td>char</td></tr><tr><td>整型</td><td>int</td></tr><tr><td>浮点型</td><td>float</td></tr><tr><td>双浮点型</td><td>double</td></tr><tr><td>无类型</td><td>void</td></tr><tr><td>宽字符型</td><td>wchar_t</td></tr></tbody></table><p>补充表格</p><table><thead><tr><th>类型</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1字节</td><td>-128~127</td></tr><tr><td>unsigned char</td><td>1字节</td><td>0~255</td></tr><tr><td>signed char</td><td>1字节</td><td>-128~127</td></tr><tr><td>int</td><td>4字节</td><td>-2^31~2^31-1</td></tr><tr><td>unsigned int</td><td>4字节</td><td></td></tr><tr><td>signed int</td><td>4字节</td><td></td></tr><tr><td>short int</td><td>2字节</td><td></td></tr><tr><td>unsigned short int</td><td>2字节</td><td></td></tr><tr><td>signed short int</td><td>2字节</td><td></td></tr><tr><td>long int</td><td>8字节</td><td></td></tr><tr><td>signed long int</td><td>8字节</td><td></td></tr><tr><td>unsigned long int</td><td>8字节</td><td></td></tr><tr><td>float</td><td>4字节</td><td></td></tr><tr><td>double</td><td>8字节</td><td></td></tr><tr><td>long long</td><td>8字节</td><td></td></tr><tr><td>long double</td><td>16字节</td><td></td></tr></tbody></table><p>typedef 使用格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type newname;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line">INT INI16;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p><p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p><p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 静态将int类型转换为float类型</span></span><br></pre></td></tr></table></figure><h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">    Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br><span class="line">    ptr_derived-&gt;<span class="built_in">func</span>(); <span class="comment">// 调用派生类函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常量转换"><a href="#常量转换" class="headerlink" title="常量转换"></a>常量转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 常量转换，将const int转换为int</span></span><br></pre></td></tr></table></figure><h3 id="重新解释转换"><a href="#重新解释转换" class="headerlink" title="重新解释转换"></a>重新解释转换</h3><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p><p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 重新解释将int类型转换为float类型</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一般来说有三个地方可以定义变量：</p><ul><li>在函数或一个代码块内部声明的变量，称为<strong>局部变量</strong>。</li><li>在函数参数的定义中声明的变量，称为<strong>形式参数</strong>。</li><li>在所有函数外部声明的变量，称为<strong>全局变量</strong>。</li></ul><p>作用域是程序的一个区域，变量的作用域可以分为以下几种：</p><ul><li><strong>局部作用域</strong>：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。</li><li><strong>全局作用域</strong>：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。</li><li><strong>块作用域</strong>：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。</li><li><strong>类作用域</strong>：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>常用的几个如下</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>strcpy(s1,s2)</strong></td><td>复制字符串s2到字符串s1</td></tr><tr><td><strong>strcat(s1, s2);</strong></td><td>连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如:<br/>string str1 &#x3D; “demo1”;<br/>string str2 &#x3D; “demo2”;<br/>string str &#x3D; str1 + str2;</td></tr><tr><td><strong>strlen(s1);</strong></td><td>返回字符串 s1 的长度。</td></tr><tr><td><strong>strcmp(s1, s2);</strong></td><td>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td></tr><tr><td><strong>strchr(s1, ch);</strong></td><td>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td><strong>strstr(s1, s2);</strong></td><td>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span>  var1 = <span class="number">10</span>;</span><br><span class="line">   <span class="type">char</span> var2[<span class="number">12</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">   cout &lt;&lt; &amp;var1 &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; var1 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">   cout &lt;&lt; &amp;var2 &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; var2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="type">int</span>    i;</span><br><span class="line">   <span class="type">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="type">int</span>&amp;    r = i;</span><br><span class="line">   <span class="type">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>直接放代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 提供接口框架的纯虚函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      width = w;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="type">int</span> width;</span><br><span class="line">   <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height)/<span class="number">2</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   Triangle  Tri;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   Tri.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Tri.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class="built_in">getArea</span>() &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><p>格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;return-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>举例如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这是对c++的泛式编程的梳理&lt;br&gt;c++的基础就那边点,无非就是流程控制和对象继承等&lt;br&gt;剩下的就是STL的内容。&lt;br&gt;所以我觉得还是</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp标准</title>
    <link href="https://joeforkyou.github.io/2024/11/14/CPP/cpp%E6%A0%87%E5%87%86/"/>
    <id>https://joeforkyou.github.io/2024/11/14/CPP/cpp%E6%A0%87%E5%87%86/</id>
    <published>2024-11-14T14:47:09.000Z</published>
    <updated>2024-11-14T15:10:01.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>‌C++标准‌是C++编程语言的规范，由国际标准化组织（ISO）制定。<br>C++标准的发展历程可以追溯到1998年,<br>当时ISO&#x2F;IEC 14882:1998标准被发布，这被认为是第一个C++标准，常被称为C++98。<br>随后，C++标准经历了多次更新和修订，<br>包括C++03（2003年）、C++11（2011年）、C++14（2014年）和C++17（2017年）。最新的C++标准是C++20，于2020年发布，引入了许多新特性，如概念（concepts）、范围库（ranges）、协程（coroutines）等。此外，C++23标准也在2023年确定，但目前支持完整的编译器较少。<br>C++标准的发展历程</p><p>‌C++98‌：1998年发布的第一个C++标准，常被称为C++98。<br>‌C++03‌：2003年发布的修订版，增加了对自动存储期变量的支持等新特性。<br>‌C++11‌：2011年发布的版本，增加了lambda表达式、自动类型推导等功能。<br>‌C++14‌：2014年发布的版本，增加了基于范围的for循环、constexpr等功能。<br>‌C++17‌：2017年发布的版本，增加了结构化绑定、文件系统库等功能。<br>‌C++20‌：2020年发布的版本，引入了概念（concepts）、范围库（ranges）、协程（coroutines）等新特性。<br>‌C++23‌：2023年确定的版本，目前支持完整的编译器较少。<br>目前按照我接触的标准来说.<br>市面上大部分项目都是以C++11&#x2F;14&#x2F;17&#x2F;20为主, 而C++98&#x2F;03则是少数.  这主要是因为一些老项目的历史原因, 也有一些公司的项目使用C++98&#x2F;03, 这也是C++标准的发展历程.<br>本文先介绍个大概,后续再介绍C++11&#x2F;14&#x2F;17&#x2F;20的详细新特性。</p><h1 id="2-C-11-新特性"><a href="#2-C-11-新特性" class="headerlink" title="2 C++11 新特性"></a>2 C++11 新特性</h1><p>C++11标准引入了许多新特性，以下是一些重要的特性及其代码示例：</p><ol><li><p><strong>自动类型推导（auto）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;      <span class="comment">// x 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2.5</span>;    <span class="comment">// y 被推导为 double</span></span><br></pre></td></tr></table></figure></li><li><p><strong>范围for循环（for each）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : vec) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出每个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型：nullptr</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>; <span class="comment">// nullptr 是类型安全的空指针</span></span><br></pre></td></tr></table></figure><p>早期一直用的是NULL, 后来发现NULL是int类型, 所以就引入了nullptr, 它是一个空指针常量, 类型安全, 避免了类型转换错误。这使得代码更加安全和可读性更高。</p></li><li><p><strong>右值引用和移动语义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>lambda表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">lambda</span>(<span class="number">5</span>); <span class="comment">// 输出25</span></span><br></pre></td></tr></table></figure><p><strong>注意lambda是最后使用发射的,在用QT的时候,我经常会使用connect函数, 它会自动生成一个lambda表达式, 这个时候要注意局部变量和全局变量的生命周期，如果在外层申明了一个局部变量，在lambda表达式中使用这个变量，就会出现未定义行为导致程序崩溃。</strong></p></li><li><p><strong>智能指针（std::unique_ptr和std::shared_ptr）</strong><br>智能指针单独开一个章节说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 独占所有权的智能指针</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>; <span class="comment">// 共享所有权的智能指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong>线程支持库（std::thread）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br></pre></td></tr></table></figure></li><li><p><strong>静态断言（static_assert）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;Size of int is not 4 bytes!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>变长模板（Variadic templates）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="comment">// 使用折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;text&quot;</span>); <span class="comment">// 输出: 123text</span></span><br></pre></td></tr></table></figure></li><li><p><strong>枚举类（enum class）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">Color c = Color::Red; <span class="comment">// 强类型枚举</span></span><br></pre></td></tr></table></figure></li></ol><p>以上是C++11引入的一些主要新特性及其简单示例，这些特性极大地增强了C++的功能和灵活性。</p><h1 id="3-C-14-新特性"><a href="#3-C-14-新特性" class="headerlink" title="3 C++14 新特性"></a>3 C++14 新特性</h1><h2 id="1-二进制字面量"><a href="#1-二进制字面量" class="headerlink" title="1. 二进制字面量"></a>1. 二进制字面量</h2><p>C++14 引入了二进制字面量，允许使用 <code>0b</code> 或 <code>0B</code> 前缀来表示二进制数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> binaryNum = <span class="number">0b101010</span>; <span class="comment">// 二进制 101010 等于十进制 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;二进制 101010 的十进制值是: &quot;</span> &lt;&lt; binaryNum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 使用二进制字面量时，必须在编译器开启 C++14 标准的情况下编译代码。</p><h2 id="2-泛型-Lambda-表达式"><a href="#2-泛型-Lambda-表达式" class="headerlink" title="2. 泛型 Lambda 表达式"></a>2. 泛型 Lambda 表达式</h2><p>在 C++14 中，Lambda 表达式支持模板参数，可以使用 <code>auto</code> 作为参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">auto</span> n) &#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        <span class="built_in">print</span>(num); <span class="comment">// 调用 泛型 Lambda</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 泛型 Lambda 可能在某些老旧的编译器上不被支持，请确认编译器版本。</p><h2 id="3-std-make-unique"><a href="#3-std-make-unique" class="headerlink" title="3. std::make_unique"></a>3. std::make_unique</h2><p>C++14 引入了 <code>std::make_unique</code> 来简化 <code>std::unique_ptr</code> 的创建，避免手动使用 <code>new</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 创建一个 unique_ptr 并初始化</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 使用 <code>std::make_unique</code> 可以防止内存泄漏，但是请确保使用 C++14 或更高版本编译。</p><h2 id="4-返回类型推导"><a href="#4-返回类型推导" class="headerlink" title="4. 返回类型推导"></a>4. 返回类型推导</h2><p>C++14 允许推导函数的返回类型，可以使用 <code>auto</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 返回类型自动推导</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3 + 5 = &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 使用返回类型推导时，确保函数体简单，编译器能够清晰推导出返回类型。</p><h2 id="5-std-shared-timed-mutex-和-std-shared-lock"><a href="#5-std-shared-timed-mutex-和-std-shared-lock" class="headerlink" title="5. std::shared_timed_mutex 和 std::shared_lock"></a>5. std::shared_timed_mutex 和 std::shared_lock</h2><p>C++14 引入了 <code>std::shared_timed_mutex</code> 和 <code>std::shared_lock</code>，支持更灵活的多线程锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reading data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writing data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(read)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(write)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>: 当在多线程环境下使用锁时，确保正确地管理锁的生命周期，避免死锁和资源竞争。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++14 引入了多项新特性，增强了语言的灵活性和表达能力。在使用这些特性时，请注意兼容性和编译器支持情况，以确保代码的可移植性和稳定性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;‌C++标准‌是C++编程语言的规范，由国际标准化组织（ISO）制定。&lt;br&gt;C++标准的发展历程可以追溯到1998年,&lt;b</summary>
      
    
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://joeforkyou.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【uiautomator】自动化测试camera【一】</title>
    <link href="https://joeforkyou.github.io/2024/11/11/Python/uiautomator2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95camera_1/"/>
    <id>https://joeforkyou.github.io/2024/11/11/Python/uiautomator2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95camera_1/</id>
    <published>2024-11-11T14:46:49.000Z</published>
    <updated>2024-11-17T12:17:14.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>本文档是自己写andorid camera自动化测试的随笔<br>测试机器为<br>OPPO Find x7<br>测试Apk为oppo的系统相机.</p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><p>我电脑是有装conda环境的,所以我直接用conda创建虚拟环境专门用于相关的测试.<br>官网下的巨慢，直接去清华大学的镜像源下载速度快很多.<br><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>下载对应的系统版本即可<br>linux对应sh文件.<br>windows直接双击exe文件安装即可.<br>我不是很喜欢直接破坏本机电脑的python环境,所以我创建了一个新的虚拟环境. 这种包管理更为安全，pip炸了就炸了 打不了删了重新建一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py3 python=3.7  #创建python3.7的虚拟环境</span><br><span class="line">conda activate  py3             #激活虚拟环境</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">conda deactivate               <span class="comment">#退出虚拟环境</span></span></span><br><span class="line">conda info --envs               #查看虚拟环境</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda environments:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">py2                      C:\Users\Admin\.conda\envs\py2</span></span><br><span class="line">py3                      C:\Users\Admin\.conda\envs\py3</span><br><span class="line">base                     D:\conda</span><br></pre></td></tr></table></figure><p>激活后会显示当前所在的环境名字，比如我这边是py3.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(py3) D:\Pr\demo&gt;</span><br></pre></td></tr></table></figure><p>安装需要的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uiautomator2</span><br><span class="line">pip install pyyaml</span><br></pre></td></tr></table></figure><p>电脑要提前安装好相关的adb.直接去谷歌官网下就行，linux下直接apt-get install adb就行.<br>如果adb 版本有问题，可以到<a href="https://developer.android.com/studio/releases/platform-tools%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88.%E7%84%B6%E5%90%8E%E6%B7%BB%E5%8A%A0%E5%88%B0">https://developer.android.com/studio/releases/platform-tools下载最新版.然后添加到</a><br>我需要先获得测试apk的包名,本质上我都去调用一些api接口.<br>这个包名可以替换的.<br>清下log,然后开始抓log.开始抓log后打开你所用的camera app.<br>adb logcat -c<br>adb logcat -G 20M<br>adb logcat -b all &gt;main.txt<br>打开main.txt log<br>过滤log 关键字connect call<br>看到我这边打印的一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11-11 21:42:43.435  1458  8995 I CameraService: CameraService::connect call (PID 6159 &quot;com.oplus.camera&quot;, camera ID 5) and Camera API version 2</span><br></pre></td></tr></table></figure><p>com.oplus.camera 就是我用的测试apk的包名,对应的camera ID 5 就是我打开的相机的ID.<br>话说为什么是5,我记得后摄一般项目都是做成0.<br>一般remosaic的相机ID是会做别的映射，我打了好多不同模式的，没明白他的映射id是怎么做的.<br>等有机会我自己写个apk，给这个手机hal的信息慢慢剖出来看下人家产品是怎么做的.<br>11-11 21:53:24.108  1458 10185 I CameraService: CameraService::connect call (PID 6159 “com.oplus.camera”, camera ID 5) and Camera API version 2<br>11-11 21:53:27.274  1458  9223 I CameraService: CameraService::connect call (PID 6159 “com.oplus.camera”, camera ID 1) and Camera API version 2<br>11-11 21:53:46.899  1458  2400 I CameraService: CameraService::connect call (PID 6159 “com.oplus.camera”, camera ID 2) and Camera API version 2<br>扯远了.</p><h1 id="3-写个demo"><a href="#3-写个demo" class="headerlink" title="3 写个demo"></a>3 写个demo</h1><p>新建一个python文件,名字为oppoCam.py<br>写个简单的demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2</span><br><span class="line"><span class="keyword">import</span> yaml                         <span class="comment"># 引入yaml模块 预留我后续用这个做基本配置文件</span></span><br><span class="line"><span class="keyword">import</span> time                         <span class="comment"># 引入time模块 预留我后续用这个做延时</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    package = <span class="string">&quot;com.mediatek.camera&quot;</span> <span class="comment"># 设置需要运行的包名</span></span><br><span class="line"></span><br><span class="line">    sn = <span class="string">&#x27;YD9HVGXGZLA6ZHCQ&#x27;</span>         <span class="comment"># 设置手机序列号 adb devices -l 获取</span></span><br><span class="line"></span><br><span class="line">    d = u2.connect(sn)              <span class="comment"># 连接手机</span></span><br><span class="line">    d.app_start(package)            <span class="comment"># 启动app</span></span><br><span class="line">    <span class="built_in">print</span>(d.info)                   <span class="comment"># 打印手机信息</span></span><br></pre></td></tr></table></figure><p>第一次运行好像还会从github上下载ATX和uiautomator2的包,下载完后就可以运行了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oppoCam.py</span><br></pre></td></tr></table></figure><p>第二次运行就很快了.<br>我这边打印出来了一些信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(py3) D:\Pr\demo\py&gt;python oppoCam.py</span><br><span class="line">&#123;&#x27;currentPackageName&#x27;: &#x27;com.android.launcher&#x27;, &#x27;displayHeight&#x27;: 2256, &#x27;displayRotation&#x27;: 0, &#x27;displaySizeDpX&#x27;: 360, &#x27;displaySizeDpY&#x27;: 792, &#x27;displayWidth&#x27;: 1080, &#x27;productName&#x27;: &#x27;PHZ110&#x27;, &#x27;screenOn&#x27;: True, &#x27;sdkInt&#x27;: 34, &#x27;naturalOrientation&#x27;: True&#125;</span><br></pre></td></tr></table></figure><p>自此相关的准备工作都已经完成可以做后续的拍照&#x2F;切换&#x2F;录像等操作了.<br>剩余部分另外整理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;本文档是自己写andorid camera自动化测试的随笔&lt;br&gt;测试机器为&lt;br&gt;OPPO Find x7&lt;br&gt;测试Ap</summary>
      
    
    
    
    <category term="python" scheme="https://joeforkyou.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://joeforkyou.github.io/tags/python/"/>
    
  </entry>
  
</feed>
